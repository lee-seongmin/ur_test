def samho_main_Fillet_2023_10_18():
  modbus_add_signal("127.0.0.1", 255, 171, 2, "MODBUS_1", False)
  modbus_set_signal_update_frequency("MODBUS_1", 1)
  modbus_add_signal("127.0.0.1", 255, 153, 2, "MODBUS_2", False)
  modbus_set_signal_update_frequency("MODBUS_2", 10)
  modbus_add_signal("127.0.0.1", 255, 154, 2, "MODBUS_3", False)
  modbus_set_signal_update_frequency("MODBUS_3", 10)
  modbus_add_signal("127.0.0.1", 255, 240, 2, "MODBUS_4", False)
  modbus_set_signal_update_frequency("MODBUS_4", 10)
  step_count_98ba61fd_7ce8_44f6_bff3_5143d008eee6 = 0.0
  thread Step_Counter_Thread_eafa4915_b51c_49e2_aeb6_49c02b475471():
    while (True):
      step_count_98ba61fd_7ce8_44f6_bff3_5143d008eee6 = step_count_98ba61fd_7ce8_44f6_bff3_5143d008eee6 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_eafa4915_b51c_49e2_aeb6_49c02b475471()
  set_tool_voltage(24)
  set_tcp(p[-0.20715,-0.003,0.38467,1.2578,0.0098,-2.8767])
  set_payload(2.4, [-0.085, 0.00191, 0.125])
  set_safety_mode_transition_hardness(1)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 1)
  set_analog_outputdomain(1, 1)
  set_input_actions_to_default()
  set_tool_digital_input_action(1, "freedrive")
  set_runstate_standard_digital_outputs([0])
  set_runstate_standard_digital_output_to_value(0, 1)
  set_runstate_standard_digital_output_to_value(7, 3)
  set_gravity([0.0, 0.0, 9.82])
  global A_Touch_trig_l=[False, False, False, False, True, False, False, False, False, False, False]
  global Auto_cur_cell=0
  global Auto_trig=False
  global A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0.52449, -0.29611, -0.03135, -1.44433, -1.03764, -1.44433], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0.5215, -0.2959, 0.14321, -1.44433, -1.03764, -1.44433], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
  global last_pose=p[0, 0, 0, 0, 0, 0]
  global A_Distance_list=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global Auto_total_cell=1
  global A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0.47946, -0.33036, 0.01979, 1.89026, -1.12958, 1.54553], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
  global Reset_Trig=False
  global Auto_W_num=[4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global A_Speed_list=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global Base=p[0.0,0.0,0.0,0.0,0.0,0.0]
  global save_timer=0
  global timer_1=0
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global save_timer_is_counting=False
  global timer_1_is_counting=False
  thread Timer_Thread():
    while (True):
      if (save_timer_is_counting):
        save_timer = save_timer + get_steptime()
      end
      if (timer_1_is_counting):
        timer_1 = timer_1 + get_steptime()
      end
      sync()
    end
  end
  run Timer_Thread()
  def cell_info():
    $ 1483 "cell_info" "noBreak"
    $ 1484 "'cell_setting'"
    # 'cell_setting'
    $ 1485 "a7_f_distance≔get_center"
    global a7_f_distance=get_center
    $ 1486 "'dis + 125'"
    # 'dis + 125'
    $ 1487 "If simulation_mode"
    if (simulation_mode):
      $ 1488 "a6_f_height_l≔190"
      global a6_f_height_l=190
      $ 1489 "a6_f_height_r≔190"
      global a6_f_height_r=190
      $ 1490 "a6_f_width≔690"
      global a6_f_width=690
      $ 1491 "a6_callar_hor≔100"
      global a6_callar_hor=100
      $ 1492 "a6_callar_vert≔100"
      global a6_callar_vert=100
      $ 1493 "center_height≔50"
      global center_height=50
      $ 1494 "EXT_flag1≔integer_to_binary_list(2048)"
      global EXT_flag1= integer_to_binary_list (2048)
      $ 1495 "get_margin_z≔50"
      global get_margin_z=50
    else:
      $ 1496 "Else" "noBreak"
      $ 1497 "a6_f_height_l≔read_port_register(173)"
      global a6_f_height_l= read_port_register (173)
      $ 1498 "a6_f_height_r≔read_port_register(174)"
      global a6_f_height_r= read_port_register (174)
      $ 1499 "a6_f_width≔read_port_register(175)"
      global a6_f_width= read_port_register (175)
      $ 1500 "a6_callar_hor≔read_port_register(181)"
      global a6_callar_hor= read_port_register (181)
      $ 1501 "a6_callar_vert≔read_port_register(182)"
      global a6_callar_vert= read_port_register (182)
      $ 1502 "center_height≔read_port_register(237)"
      global center_height=read_port_register(237)
      $ 1503 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
      global EXT_flag1= integer_to_binary_list ( read_port_register (179))
      $ 1505 "get_margin_z≔read_port_register(238)"
      global get_margin_z=read_port_register(238)
      $ 1507 "If center_height>32765"
      if (center_height>32765):
        $ 1508 "center_height≔center_height-65535"
        global center_height=center_height-65535
      end
      $ 1509 "If get_margin_z>32765"
      if (get_margin_z>32765):
        $ 1510 "get_margin_z≔get_margin_z-65535"
        global get_margin_z=get_margin_z-65535
      end
    end
    $ 1511 "Initialization"
    $ 1512 "CELL_ROBOT_DIST≔a7_f_distance"
    global CELL_ROBOT_DIST=a7_f_distance
    $ 1513 "CELL_WIDTH≔a6_f_width"
    global CELL_WIDTH=a6_f_width
  end
  def robotand_cell_initalizat():
    $ 1514 "robotand_cell_initalizat" "noBreak"
    $ 1515 "If Auto_trig≟ True "
    if (Auto_trig ==   True  ):
      $ 1516 "Auto_trig≔ False "
      global Auto_trig=  False  
      $ 1517 "init"
      $ 1518 "write_port_register(cell_3f_2f_151,0)"
      write_port_register(cell_3f_2f_151,0)
      $ 1519 "write_port_register(cell_info_152,0)"
      write_port_register(cell_info_152,0)
      $ 1520 "write_port_register(weld_req_153,0)"
      write_port_register(weld_req_153,0)
      $ 1521 "write_port_register(touch_cell_155,0)"
      write_port_register(touch_cell_155,0)
      $ 1522 "write_port_register(touch_num_156,0)"
      write_port_register(touch_num_156,0)
      $ 1523 "write_port_register(touch_done_157,0)"
      write_port_register(touch_done_157,0)
      $ 1524 "write_port_register(weld_done_137,0)"
      write_port_register(weld_done_137,0)
      $ 1525 "write_port_register(135,0)"
      write_port_register(135,0)
      $ 1526 "write_port_register(136,0)"
      write_port_register(136,0)
      $ 1527 "write_port_register(165,0)"
      write_port_register(165,0)
      $ 1528 "write_port_register(166,0)"
      write_port_register(166,0)
      $ 1529 "write_port_register(167,0)"
      write_port_register(167,0)
      $ 1530 "write_port_register(169,0)"
      write_port_register(169,0)
      $ 1531 "write_port_register(170,0)"
      write_port_register(170,0)
      $ 1532 "write_port_register(221,0)"
      write_port_register(221,0)
      $ 1533 "write_port_register(222,0)"
      write_port_register(222,0)
      $ 1534 "write_port_register(223,0)"
      write_port_register(223,0)
      $ 1535 "write_port_register(224,0)"
      write_port_register(224,0)
      $ 1536 "write_port_register(225,0)"
      write_port_register(225,0)
      $ 1537 "write_port_register(226,0)"
      write_port_register(226,0)
      $ 1538 "write_port_register(227,0)"
      write_port_register(227,0)
      $ 1539 "write_port_register(228,0)"
      write_port_register(228,0)
      $ 1540 "write_port_register(240,0)"
      write_port_register(240,0)
      $ 1541 "write_port_register(176,0)"
      write_port_register(176,0)
      $ 1542 "write_port_register(177,0)"
      write_port_register(177,0)
      $ 1543 "write_port_register(154,0)"
      write_port_register(154,0)
    end
    $ 1544 "sync()"
    sync()
  end
  def welding_parameter_init():
    $ 1545 "welding_parameter_init" "noBreak"
    $ 1546 "init"
    $ 1547 "If A_sel_v≟A_VL1 or A_sel_v≟A_VL2 or A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL1  or  A_sel_v == A_VL2  or  A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1548 "position_3f2f≔position_3F"
      global position_3f2f=position_3F
      $ 1549 "write_port_register(cell_3f_2f_151,A_sel_v)"
      write_port_register(cell_3f_2f_151,A_sel_v)
      $ 1550 "b8_wv_2f≔ False "
      global b8_wv_2f=  False  
      $ 1551 "d_lean_degree≔0"
      global d_lean_degree=0
    else:
      $ 1552 "Else" "noBreak"
      $ 1553 "position_3f2f≔position_2F"
      global position_3f2f=position_2F
      $ 1554 "b8_wv_2f≔ True "
      global b8_wv_2f=  True  
      $ 1555 "d_lean_degree≔30"
      global d_lean_degree=30
      $ 1556 "write_port_register(cell_3f_2f_151,A_HOR)"
      write_port_register(cell_3f_2f_151,A_HOR)
    end
    $ 1557 "If current_path≥2"
    if (current_path >= 2):
      $ 1558 "write_port_register(cell_info_152,current_path)"
      write_port_register(cell_info_152,current_path)
    else:
      $ 1559 "Else" "noBreak"
      $ 1560 "write_port_register(cell_info_152,1)"
      write_port_register(cell_info_152,1)
    end
    $ 1561 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 1562 "Wait: 0.3"
    sleep(0.3)
    $ 1563 "write_port_register(weld_req_153,1)"
    write_port_register(weld_req_153,1)
    $ 1564 "Wait read_port_register(return_done_240)≟1"
    while (not( read_port_register (return_done_240) == 1)):
      sync()
    end
    $ 1565 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 1566 "touch_m_check≔0"
    global touch_m_check=0
    $ 1567 "start_end_from_pendant"
    $ 1568 "d_start_current≔read_port_register(244)/10"
    global d_start_current= read_port_register (244)/10
    $ 1569 "d_start_voltage≔read_port_register(245)/10"
    global d_start_voltage= read_port_register (245)/10
    $ 1570 "d_start_time≔read_port_register(241)/10"
    global d_start_time= read_port_register (241)/10
    $ 1571 "d_end_current≔read_port_register(249)/10"
    global d_end_current= read_port_register (249)/10
    $ 1572 "d_end_voltage≔read_port_register(250)/10"
    global d_end_voltage= read_port_register (250)/10
    $ 1573 "d_end_time≔read_port_register(246)/10"
    global d_end_time= read_port_register (246)/10
    $ 1574 "d_end_current_2≔read_port_register(254)/10"
    global d_end_current_2= read_port_register (254)/10
    $ 1575 "d_end_voltage_2≔read_port_register(255)/10"
    global d_end_voltage_2= read_port_register (255)/10
    $ 1576 "d_end_time_2≔read_port_register(251)/10"
    global d_end_time_2= read_port_register (251)/10
    $ 1577 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]"
    global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]
    $ 1578 "a0_volt_ref≔read_port_register(231)/10"
    global a0_volt_ref= read_port_register (231)/10
    $ 1579 "a1_amp_ref≔read_port_register(232)/10"
    global a1_amp_ref= read_port_register (232)/10
    $ 1580 "a2_speed_cpm≔read_port_register(233)/10"
    global a2_speed_cpm= read_port_register (233)/10
    $ 1581 "a3_wv_amplitude≔read_port_register(234)/10"
    global a3_wv_amplitude= read_port_register (234)/10
    $ 1582 "a4_wv_frequency≔read_port_register(225)/10"
    global a4_wv_frequency= read_port_register (225)/10
    $ 1583 "b1_appro_param≔0"
    global b1_appro_param=0
    $ 1584 "b4_wv_delay2≔read_port_register(226)/10"
    global b4_wv_delay2= read_port_register (226)/10
    $ 1585 "b6_wv_delay4≔read_port_register(227)/10"
    global b6_wv_delay4= read_port_register (227)/10
    $ 1586 "b3_wv_delay1≔0"
    global b3_wv_delay1=0
    $ 1587 "b5_wv_delay3≔0"
    global b5_wv_delay3=0
    $ 1588 "b3_dealy_all≔[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]"
    global b3_dealy_all=[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]
    $ 1589 "get_width_182≔read_port_register(182)"
    global get_width_182= read_port_register (182)
    $ 1590 "b9_touch_sens≔20"
    global b9_touch_sens=20
    $ 1591 "task_angle≔register_read(228)/10"
    global task_angle=register_read(228)/10
    $ 1592 "Circle_Speed≔a2_speed_cpm"
    global Circle_Speed=a2_speed_cpm
    $ 1593 "CELL_BOTTOM≔a7_cell_bottom"
    global CELL_BOTTOM=a7_cell_bottom
    $ 1594 "a6_scallup_left≔read_port_register(176)"
    global a6_scallup_left= read_port_register (176)
    $ 1595 "a6_scallup_righ≔read_port_register(177)"
    global a6_scallup_righ= read_port_register (177)
    $ 1596 "a5_f_hole≔[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]"
    global a5_f_hole=[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]
    $ 1630 "폴더"
    $ 1631 "offset_2f_x≔7"
    global offset_2f_x=7
    $ 1632 "offset_3f_z≔-5"
    global offset_3f_z=-5
    $ 1633 "If A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1634 "'3F'"
      # '3F'
      $ 1635 "b2_left_par≔ False "
      global b2_left_par=  False  
      $ 1636 "b8_wv_type≔1"
      global b8_wv_type=1
      $ 1637 "If A_sel_v≟A_VR2 and (b1_cell_info_R≟c or b1_cell_info_R≟d)"
      if (A_sel_v == A_VR2  and  (b1_cell_info_R == c  or  b1_cell_info_R == d)):
        $ 1638 "b7_tilt_degree≔[0,0,0]"
        global b7_tilt_degree=[0,0,0]
      else:
        $ 1639 "Else" "noBreak"
        $ 1640 "b7_tilt_degree≔[task_angle,-27,0]"
        global b7_tilt_degree=[task_angle,-27,0]
      end
      $ 1641 "c3_arc_enable≔1"
      global c3_arc_enable=1
    else:
      $ 1642 "ElseIf A_sel_v≟A_VL1 or A_sel_v≟A_VL2"
      if (A_sel_v == A_VL1  or  A_sel_v == A_VL2):
        $ 1643 "'3F'"
        # '3F'
        $ 1644 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1645 "b8_wv_type≔1"
        global b8_wv_type=1
        $ 1646 "If A_sel_v≟A_VL2 and (b1_cell_info_L≟c or b1_cell_info_L≟d)"
        if (A_sel_v == A_VL2  and  (b1_cell_info_L == c  or  b1_cell_info_L == d)):
          $ 1647 "b7_tilt_degree≔[0,0,0]"
          global b7_tilt_degree=[0,0,0]
        else:
          $ 1648 "Else" "noBreak"
          $ 1649 "b7_tilt_degree≔[task_angle,-27,0]"
          global b7_tilt_degree=[task_angle,-27,0]
        end
        $ 1650 "c3_arc_enable≔1"
        global c3_arc_enable=1
      else:
        $ 1651 "Else" "noBreak"
        $ 1652 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1653 "b8_wv_type≔2"
        global b8_wv_type=2
        $ 1654 "If A_sel_v≟A_HOR"
        if (A_sel_v == A_HOR):
          $ 1655 "b7_tilt_degree≔[30,-1*task_angle,0]"
          global b7_tilt_degree=[30,-1*task_angle,0]
        else:
          $ 1656 "Else" "noBreak"
          $ 1658 "b7_tilt_degree≔[30,-1*task_angle,0]"
          global b7_tilt_degree=[30,-1*task_angle,0]
        end
        $ 1660 "c3_arc_enable≔0"
        global c3_arc_enable=0
      end
    end
    $ 1661 "If A_sel_v≟A_VL2 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL2  or  A_sel_v == A_VR2):
      $ 1662 "If b1_cell_info_L≟E or b1_cell_info_L≟e or b1_cell_info_R≟E or b1_cell_info_R≟e"
      if (b1_cell_info_L == E  or  b1_cell_info_L == e  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
        $ 1663 "a8_wv_distance≔read_port_register(182)-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance= read_port_register (182)-a5_f_hole[1]-offset_3f_begin
      else:
        $ 1664 "Else" "noBreak"
        $ 1665 "a8_wv_distance≔read_port_register(182)-offset_3f_begin"
        global a8_wv_distance= read_port_register (182)-offset_3f_begin
      end
    else:
      $ 1670 "Else" "noBreak"
      $ 1671 "If b2_left_par"
      if (b2_left_par):
        $ 1672 "Comment"
        # Comment
        $ 1673 "a8_wv_distance≔a6_f_height_l-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance=a6_f_height_l-a5_f_hole[1]-offset_3f_begin
        $ 1674 "Comment"
        # Comment
      else:
        $ 1675 "Else" "noBreak"
        $ 1676 "a8_wv_distance≔a6_f_height_r-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance=a6_f_height_r-a5_f_hole[1]-offset_3f_begin
      end
    end
    $ 1677 "Ext fun & Squash"
    $ 1678 "If (A_sel_v≟A_VL1 or A_sel_v≟A_VL2) and (b1_cell_info_L≟B or b1_cell_info_L≟D)"
    if ((A_sel_v == A_VL1  or  A_sel_v == A_VL2)  and  (b1_cell_info_L == B  or  b1_cell_info_L == D)):
      $ 1679 "Scallup_check≔ True "
      global Scallup_check=  True  
    else:
      $ 1680 "ElseIf (A_sel_v≟A_VR1 or A_sel_v≟A_VR2) and (b1_cell_info_R≟B or b1_cell_info_R≟D)"
      if ((A_sel_v == A_VR1  or  A_sel_v == A_VR2)  and  (b1_cell_info_R == B  or  b1_cell_info_R == D)):
        $ 1681 "Scallup_check≔ True "
        global Scallup_check=  True  
      else:
        $ 1682 "Else" "noBreak"
        $ 1683 "Scallup_check≔ False "
        global Scallup_check=  False  
      end
    end
    $ 1684 "If (EXT_flag1[7]≟ True ) and (A_sel_v≠A_HOR) and (A_sel_v≠A_VL2) and (A_sel_v≠A_VR2) and (Scallup_check≟ False )"
    if ((EXT_flag1[7] ==   True  )  and  (A_sel_v != A_HOR)  and  (A_sel_v != A_VL2)  and  (A_sel_v != A_VR2)  and  (Scallup_check ==   False  )):
      $ 1685 "squash"
      $ 1686 "squash_enable≔1"
      global squash_enable=1
      $ 1687 "squash_voltage≔24.5"
      global squash_voltage=24.5
      $ 1688 "squash_current≔190"
      global squash_current=190
      $ 1689 "squash_amp≔7"
      global squash_amp=7
      $ 1690 "squash_speed≔10"
      global squash_speed=10
      $ 1691 "squash_cycle≔8"
      global squash_cycle=8
    else:
      $ 1692 "Else" "noBreak"
      $ 1693 "squash"
      $ 1694 "squash_enable≔0"
      global squash_enable=0
      $ 1695 "squash_voltage≔0"
      global squash_voltage=0
      $ 1696 "squash_current≔0"
      global squash_current=0
      $ 1697 "squash_amp≔0"
      global squash_amp=0
      $ 1698 "squash_speed≔0"
      global squash_speed=0
      $ 1699 "squash_cycle≔0"
      global squash_cycle=0
    end
    $ 1700 "If EXT_flag1[8]≟ True  and EXT_flag1[9]≟ False "
    if (EXT_flag1[8] ==   True    and  EXT_flag1[9] ==   False  ):
      $ 1701 "sludge≔1"
      global sludge=1
    else:
      $ 1702 "ElseIf EXT_flag1[8]≟ False  and EXT_flag1[9]≟ True "
      if (EXT_flag1[8] ==   False    and  EXT_flag1[9] ==   True  ):
        $ 1703 "sludge≔2"
        global sludge=2
      else:
        $ 1704 "Else" "noBreak"
        $ 1705 "sludge≔0"
        global sludge=0
      end
    end
    $ 1706 "waste_cycle≔2"
    global waste_cycle=2
    $ 1707 "c0_offset_x≔read_port_register(229)/10"
    global c0_offset_x= read_port_register (229)/10
    $ 1708 "c0_offset_z≔read_port_register(230)/10"
    global c0_offset_z= read_port_register (230)/10
    $ 1709 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
    global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
    $ 1710 "WV_gap"
    $ 1711 "c5_wv_gap_y≔read_port_register(236)/10"
    global c5_wv_gap_y= read_port_register (236)/10
    $ 1712 "c6_wv_gap_cpm≔read_port_register(235)/10"
    global c6_wv_gap_cpm= read_port_register (235)/10
    $ 1713 "c9_wv_gap_freq≔a4_wv_frequency"
    global c9_wv_gap_freq=a4_wv_frequency
    $ 1714 "If c6_wv_gap_cpm≟a2_speed_cpm and a3_wv_amplitude≟c5_wv_gap_y"
    if (c6_wv_gap_cpm == a2_speed_cpm  and  a3_wv_amplitude == c5_wv_gap_y):
      $ 1715 "c4_gap_enable≔0"
      global c4_gap_enable=0
    else:
      $ 1716 "Else" "noBreak"
      $ 1717 "c4_gap_enable≔1"
      global c4_gap_enable=1
    end
    $ 1718 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
    global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
    $ 1719 "arc_sen"
    $ 1720 "c3_X_p_gain≔read_port_register(186)/10"
    global c3_X_p_gain= read_port_register (186)/10
    $ 1721 "c3_X_i_gain≔read_port_register(187)/10"
    global c3_X_i_gain= read_port_register (187)/10
    $ 1722 "c3_Z_p_gain≔read_port_register(184)/10"
    global c3_Z_p_gain= read_port_register (184)/10
    $ 1723 "c3_Z_i_gain≔read_port_register(185)/10"
    global c3_Z_i_gain= read_port_register (185)/10
    $ 1724 "c3_wv_arc_fix≔0"
    global c3_wv_arc_fix=0
    $ 1725 "c3_wv_arc≔[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]"
    global c3_wv_arc=[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]
    $ 1726 "volt and current"
    $ 1727 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
    set_current_voltage(a1_amp_ref,a0_volt_ref)
    $ 1728 "write_port_register(154,1)"
    write_port_register(154,1)
    $ 1729 "Wait read_port_register(return_done_240)≟0"
    while (not( read_port_register (return_done_240) == 0)):
      sync()
    end
    $ 1730 "write_port_register(154,0)"
    write_port_register(154,0)
  end
  def welding_parameter_sim():
    $ 1731 "welding_parameter_sim" "noBreak"
    $ 1732 "init"
    $ 1733 "If A_sel_v≟A_VL1 or A_sel_v≟A_VL2 or A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL1  or  A_sel_v == A_VL2  or  A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1734 "position_3f2f≔position_3F"
      global position_3f2f=position_3F
      $ 1735 "write_port_register(cell_3f_2f_151,A_sel_v)"
      write_port_register(cell_3f_2f_151,A_sel_v)
      $ 1736 "b8_wv_2f≔ False "
      global b8_wv_2f=  False  
      $ 1737 "d_lean_degree≔0"
      global d_lean_degree=0
    else:
      $ 1738 "Else" "noBreak"
      $ 1739 "position_3f2f≔position_2F"
      global position_3f2f=position_2F
      $ 1740 "b8_wv_2f≔ True "
      global b8_wv_2f=  True  
      $ 1741 "d_lean_degree≔30"
      global d_lean_degree=30
      $ 1742 "write_port_register(cell_3f_2f_151,A_HOR)"
      write_port_register(cell_3f_2f_151,A_HOR)
    end
    $ 1743 "If current_path≥2"
    if (current_path >= 2):
      $ 1744 "write_port_register(cell_info_152,current_path)"
      write_port_register(cell_info_152,current_path)
    else:
      $ 1745 "Else" "noBreak"
      $ 1746 "write_port_register(cell_info_152,1)"
      write_port_register(cell_info_152,1)
    end
    $ 1747 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 1748 "Wait: 0.3"
    sleep(0.3)
    $ 1749 "write_port_register(weld_req_153,1)"
    write_port_register(weld_req_153,1)
    $ 1751 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 1752 "touch_m_check≔0"
    global touch_m_check=0
    $ 1753 "start_end_from_pendant"
    $ 1754 "d_start_current≔read_port_register(244)/10"
    global d_start_current= read_port_register (244)/10
    $ 1755 "d_start_voltage≔read_port_register(245)/10"
    global d_start_voltage= read_port_register (245)/10
    $ 1756 "d_start_time≔read_port_register(241)/10"
    global d_start_time= read_port_register (241)/10
    $ 1757 "d_end_current≔read_port_register(249)/10"
    global d_end_current= read_port_register (249)/10
    $ 1758 "d_end_voltage≔read_port_register(250)/10"
    global d_end_voltage= read_port_register (250)/10
    $ 1759 "d_end_time≔read_port_register(246)/10"
    global d_end_time= read_port_register (246)/10
    $ 1760 "d_end_current_2≔read_port_register(254)/10"
    global d_end_current_2= read_port_register (254)/10
    $ 1761 "d_end_voltage_2≔read_port_register(255)/10"
    global d_end_voltage_2= read_port_register (255)/10
    $ 1762 "d_end_time_2≔read_port_register(251)/10"
    global d_end_time_2= read_port_register (251)/10
    $ 1763 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]"
    global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]
    $ 1764 "a0_volt_ref≔read_port_register(231)/10"
    global a0_volt_ref= read_port_register (231)/10
    $ 1765 "a1_amp_ref≔read_port_register(232)/10"
    global a1_amp_ref= read_port_register (232)/10
    $ 1766 "b1_appro_param≔0"
    global b1_appro_param=0
    $ 1767 "Folder"
    $ 1768 "a2_speed_cpm≔17"
    global a2_speed_cpm=17
    $ 1769 "a3_wv_amplitude≔5"
    global a3_wv_amplitude=5
    $ 1770 "a4_wv_frequency≔1.4"
    global a4_wv_frequency=1.4
    $ 1771 "b4_wv_delay2≔0.3"
    global b4_wv_delay2=0.3
    $ 1772 "b6_wv_delay4≔0.3"
    global b6_wv_delay4=0.3
    $ 1773 "b9_touch_sens≔10"
    global b9_touch_sens=10
    $ 1774 "task_angle≔0"
    global task_angle=0
    $ 1775 "a6_scallup_left≔0"
    global a6_scallup_left=0
    $ 1776 "a6_scallup_righ≔0"
    global a6_scallup_righ=0
    $ 1777 "b3_wv_delay1≔0"
    global b3_wv_delay1=0
    $ 1778 "b5_wv_delay3≔0"
    global b5_wv_delay3=0
    $ 1779 "b3_dealy_all≔[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]"
    global b3_dealy_all=[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]
    $ 1780 "get_width_182≔a6_callar_vert"
    global get_width_182=a6_callar_vert
    $ 1781 "task_angle≔register_read(228)/10"
    global task_angle=register_read(228)/10
    $ 1782 "Circle_Speed≔a2_speed_cpm"
    global Circle_Speed=a2_speed_cpm
    $ 1783 "CELL_BOTTOM≔a7_cell_bottom"
    global CELL_BOTTOM=a7_cell_bottom
    $ 1784 "a5_f_hole≔[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]"
    global a5_f_hole=[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]
    $ 1785 "폴더"
    $ 1786 "offset_2f_x≔7"
    global offset_2f_x=7
    $ 1787 "offset_3f_z≔-5"
    global offset_3f_z=-5
    $ 1788 "If A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1789 "'3F'"
      # '3F'
      $ 1790 "b2_left_par≔ False "
      global b2_left_par=  False  
      $ 1791 "b8_wv_type≔1"
      global b8_wv_type=1
      $ 1792 "b7_tilt_degree≔[task_angle,-27,0]"
      global b7_tilt_degree=[task_angle,-27,0]
      $ 1793 "c3_arc_enable≔1"
      global c3_arc_enable=1
    else:
      $ 1794 "ElseIf A_sel_v≟A_VL1 or A_sel_v≟A_VL2"
      if (A_sel_v == A_VL1  or  A_sel_v == A_VL2):
        $ 1795 "'3F'"
        # '3F'
        $ 1796 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1797 "b8_wv_type≔1"
        global b8_wv_type=1
        $ 1798 "b7_tilt_degree≔[task_angle,-27,0]"
        global b7_tilt_degree=[task_angle,-27,0]
        $ 1799 "c3_arc_enable≔1"
        global c3_arc_enable=1
      else:
        $ 1800 "Else" "noBreak"
        $ 1801 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1802 "b8_wv_type≔2"
        global b8_wv_type=2
        $ 1803 "b7_tilt_degree≔[30,-1*task_angle,0]"
        global b7_tilt_degree=[30,-1*task_angle,0]
        $ 1805 "c3_arc_enable≔0"
        global c3_arc_enable=0
      end
    end
    $ 1806 "If A_sel_v≟A_VL2 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL2  or  A_sel_v == A_VR2):
      $ 1807 "a8_wv_distance≔read_port_register(182)"
      global a8_wv_distance= read_port_register (182)
    else:
      $ 1812 "Else" "noBreak"
      $ 1813 "If b2_left_par"
      if (b2_left_par):
        $ 1814 "Comment"
        # Comment
        $ 1815 "a8_wv_distance≔a6_f_height_l-a5_f_hole[1]"
        global a8_wv_distance=a6_f_height_l-a5_f_hole[1]
        $ 1816 "Comment"
        # Comment
      else:
        $ 1817 "Else" "noBreak"
        $ 1818 "a8_wv_distance≔a6_f_height_r-a5_f_hole[1]"
        global a8_wv_distance=a6_f_height_r-a5_f_hole[1]
      end
    end
    $ 1819 "Ext fun & Squash"
    $ 1820 "If (A_sel_v≟A_VL1 or A_sel_v≟A_VL2) and (b1_cell_info_L≟B or b1_cell_info_L≟D)"
    if ((A_sel_v == A_VL1  or  A_sel_v == A_VL2)  and  (b1_cell_info_L == B  or  b1_cell_info_L == D)):
      $ 1821 "Scallup_check≔ True "
      global Scallup_check=  True  
    else:
      $ 1822 "ElseIf (A_sel_v≟A_VR1 or A_sel_v≟A_VR2) and (b1_cell_info_R≟B or b1_cell_info_R≟D)"
      if ((A_sel_v == A_VR1  or  A_sel_v == A_VR2)  and  (b1_cell_info_R == B  or  b1_cell_info_R == D)):
        $ 1823 "Scallup_check≔ True "
        global Scallup_check=  True  
      else:
        $ 1824 "Else" "noBreak"
        $ 1825 "Scallup_check≔ False "
        global Scallup_check=  False  
      end
    end
    $ 1826 "If (EXT_flag1[7]≟ True ) and (A_sel_v≠A_HOR) and (A_sel_v≠A_VL2) and (A_sel_v≠A_VR2) and (Scallup_check≟ False )"
    if ((EXT_flag1[7] ==   True  )  and  (A_sel_v != A_HOR)  and  (A_sel_v != A_VL2)  and  (A_sel_v != A_VR2)  and  (Scallup_check ==   False  )):
      $ 1827 "squash"
      $ 1828 "squash_enable≔1"
      global squash_enable=1
      $ 1829 "squash_voltage≔24.5"
      global squash_voltage=24.5
      $ 1830 "squash_current≔190"
      global squash_current=190
      $ 1831 "squash_amp≔7"
      global squash_amp=7
      $ 1832 "squash_speed≔10"
      global squash_speed=10
      $ 1833 "squash_cycle≔8"
      global squash_cycle=8
    else:
      $ 1834 "Else" "noBreak"
      $ 1835 "squash"
      $ 1836 "squash_enable≔0"
      global squash_enable=0
      $ 1837 "squash_voltage≔0"
      global squash_voltage=0
      $ 1838 "squash_current≔0"
      global squash_current=0
      $ 1839 "squash_amp≔0"
      global squash_amp=0
      $ 1840 "squash_speed≔0"
      global squash_speed=0
      $ 1841 "squash_cycle≔0"
      global squash_cycle=0
    end
    $ 1842 "waste_cycle≔2"
    global waste_cycle=2
    $ 1843 "c0_offset_x≔read_port_register(229)/10"
    global c0_offset_x= read_port_register (229)/10
    $ 1844 "c0_offset_z≔read_port_register(230)/10"
    global c0_offset_z= read_port_register (230)/10
    $ 1845 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
    global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
    $ 1846 "WV_gap"
    $ 1847 "c5_wv_gap_y≔a3_wv_amplitude"
    global c5_wv_gap_y=a3_wv_amplitude
    $ 1848 "c6_wv_gap_cpm≔a2_speed_cpm"
    global c6_wv_gap_cpm=a2_speed_cpm
    $ 1849 "c9_wv_gap_freq≔a4_wv_frequency"
    global c9_wv_gap_freq=a4_wv_frequency
    $ 1850 "If c6_wv_gap_cpm≟a2_speed_cpm and a3_wv_amplitude≟c5_wv_gap_y"
    if (c6_wv_gap_cpm == a2_speed_cpm  and  a3_wv_amplitude == c5_wv_gap_y):
      $ 1851 "c4_gap_enable≔0"
      global c4_gap_enable=0
    else:
      $ 1852 "Else" "noBreak"
      $ 1853 "c4_gap_enable≔1"
      global c4_gap_enable=1
    end
    $ 1854 "c4_gap_enable≔0"
    global c4_gap_enable=0
    $ 1855 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
    global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
    $ 1856 "arc_sen"
    $ 1857 "c3_X_p_gain≔read_port_register(186)/10"
    global c3_X_p_gain= read_port_register (186)/10
    $ 1858 "c3_X_i_gain≔read_port_register(187)/10"
    global c3_X_i_gain= read_port_register (187)/10
    $ 1859 "c3_Z_p_gain≔read_port_register(184)/10"
    global c3_Z_p_gain= read_port_register (184)/10
    $ 1860 "c3_Z_i_gain≔read_port_register(185)/10"
    global c3_Z_i_gain= read_port_register (185)/10
    $ 1861 "c3_wv_arc_fix≔0"
    global c3_wv_arc_fix=0
    $ 1862 "c3_wv_arc≔[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]"
    global c3_wv_arc=[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]
    $ 1863 "volt and current"
    $ 1864 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
    set_current_voltage(a1_amp_ref,a0_volt_ref)
    $ 1865 "write_port_register(154,1)"
    write_port_register(154,1)
    $ 1867 "write_port_register(154,0)"
    write_port_register(154,0)
  end
  def Move_done():
    $ 1868 "Move_done" "noBreak"
    $ 1869 "write_port_register(robot_move_163,0)"
    write_port_register(robot_move_163,0)
    $ 1870 "write_port_register(robot_pose_164,0)"
    write_port_register(robot_pose_164,0)
    $ 1871 "write_port_register(robot_ready_141,1)"
    write_port_register(robot_ready_141,1)
  end
  def MoveFun():
    $ 1872 "MoveFun" "noBreak"
    $ 1873 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1874 "MoveL"
    $ 1875 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
  end
  def MoveFun_cd():
    $ 1876 "MoveFun_cd" "noBreak"
    $ 1877 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1878 "If A_sel_v≟A_VR2 and (b1_cell_info_R≟c or b1_cell_info_R≟d)"
    if (A_sel_v == A_VR2  and  (b1_cell_info_R == c  or  b1_cell_info_R == d)):
      $ 1879 "tilt_deg≔27"
      global tilt_deg=27
      $ 1880 "tilt_deg_ry≔19"
      global tilt_deg_ry=19
      $ 1881 "tilt_deg_rz≔0"
      global tilt_deg_rz=0
    else:
      $ 1882 "Else" "noBreak"
      $ 1883 "tilt_deg≔10"
      global tilt_deg=10
      $ 1884 "tilt_deg_ry≔5"
      global tilt_deg_ry=5
      $ 1885 "tilt_deg_rz≔0"
      global tilt_deg_rz=0
    end
    $ 1886 "If b2_left_par"
    if (b2_left_par):
      $ 1887 "b_touch_pos≔pose_add(b_touch_pos, p[0,18/1000,0,0,0,0])"
      global b_touch_pos= pose_add (b_touch_pos, p[0,18/1000,0,0,0,0])
      $ 1888 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0,0,d2r(-tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0,0,d2r(-tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 1889 "Else" "noBreak"
      $ 1890 "b_touch_pos≔pose_add(b_touch_pos, p[0,-18/1000,0,0,0,0])"
      global b_touch_pos= pose_add (b_touch_pos, p[0,-18/1000,0,0,0,0])
      $ 1891 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
    end
    $ 1892 "MoveL"
    $ 1893 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
  end
  def MoveandTouchFun_2f():
    $ 1894 "MoveandTouchFun_2f" "noBreak"
    $ 1895 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1896 "tilt_deg≔3"
    global tilt_deg=3
    $ 1897 "tilt_deg_ry≔3"
    global tilt_deg_ry=3
    $ 1898 "tilt_deg_rz≔0"
    global tilt_deg_rz=0
    $ 1899 "If b2_left_par"
    if (b2_left_par):
      $ 1900 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 1901 "Else" "noBreak"
      $ 1902 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
    end
    $ 1903 "MoveL"
    $ 1904 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
    $ 1905 "Touch_2f"
    $ 1906 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos,b2_left_par,b9_touch_sens)"
    global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos,b2_left_par,b9_touch_sens)
    $ 1908 "If b2_left_par"
    if (b2_left_par):
      $ 1909 "touch_result≔pose_trans(touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])
    else:
      $ 1910 "Else" "noBreak"
      $ 1911 "touch_result≔pose_trans(touch_result,p[(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[(Touch_dis)/1000,0,0,0,0,0])
    end
    $ 1912 "A_Touch_p[A_sel_v]=touch_result"
    A_Touch_p[A_sel_v]=touch_result
    $ 1913 "If EXT_flag1[3]≟ True "
    if (EXT_flag1[3] ==   True  ):
      $ 1914 "MoveL"
      $ 1915 "manual_tp≔tilt_2f_fun(touch_result,basic_tilt_2f,wv_direction)"
      global manual_tp=tilt_2f_fun(touch_result,basic_tilt_2f,wv_direction)
      $ 1916 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
      global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
      $ 1917 "manual_tp" "breakAfter"
      movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
      $ 1918 "Wait: 1.5"
      sleep(1.5)
    end
  end
  def MoveandTouchFun_3f():
    $ 1919 "MoveandTouchFun_3f" "noBreak"
    $ 1920 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1921 "tilt_deg_ry≔0"
    global tilt_deg_ry=0
    $ 1922 "tilt_deg_rz≔0"
    global tilt_deg_rz=0
    $ 1923 "If b2_left_par"
    if (b2_left_par):
      $ 1924 "tilt_deg≔6"
      global tilt_deg=6
      $ 1925 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 1926 "Else" "noBreak"
      $ 1927 "tilt_deg≔0.5"
      global tilt_deg=0.5
      $ 1928 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(-tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(-tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])
    end
    $ 1939 "move_pre"
    $ 1940 "If (b2_left_par≟ True  and point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.03) or (b2_left_par≟ False  and point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.03)"
    if ((b2_left_par ==   True    and  point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.03)  or  (b2_left_par ==   False    and  point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.03)):
      $ 1941 "if move from home"
      $ 1942 "j_cp≔get_actual_joint_positions()"
      global j_cp= get_actual_joint_positions ()
      $ 1943 "If b2_left_par"
      if (b2_left_par):
        $ 1944 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 1945 "inner_p≔p[-10/1000,-35/1000,0,0,0,0]"
          global inner_p=p[-10/1000,-35/1000,0,0,0,0]
        else:
          $ 1946 "Else" "noBreak"
          $ 1947 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 1948 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=left_j)"
        global j_tp= get_inverse_kin (pose_add(b_touch_pos,inner_p),qnear=left_j)
      else:
        $ 1949 "Else" "noBreak"
        $ 1950 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 1951 "inner_p≔p[-10/1000,35/1000,0,0,0,0]"
          global inner_p=p[-10/1000,35/1000,0,0,0,0]
        else:
          $ 1952 "Else" "noBreak"
          $ 1953 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 1954 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=right_j)"
        global j_tp= get_inverse_kin ( pose_add (b_touch_pos,inner_p),qnear=right_j)
      end
      $ 1955 "j_cp[0]=j_tp[0]"
      j_cp[0]=j_tp[0]
      $ 1956 "j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2"
      j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2
      $ 1957 "j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/3"
      j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/3
      $ 1958 "j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/3"
      j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/3
      $ 1959 "j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/1"
      j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/1
      $ 1960 "j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1"
      j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1
      $ 1961 "MoveJ"
      $ 1962 "j_cp" "breakAfter"
      movej(j_cp, a=1.3962634015954636, v=1.0471975511965976)
      $ 1963 "j_tp≔[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]"
      global j_tp=[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]
      $ 1964 "MoveJ"
      $ 1965 "j_tp" "breakAfter"
      movej(j_tp, a=1.3962634015954636, v=1.0471975511965976)
    end
    $ 1966 "MoveL"
    $ 1967 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
    $ 1970 "touch_3f_down"
    $ 1972 "touch_result≔touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens,b2_par_cd)"
    global touch_result=touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens,b2_par_cd)
    $ 1973 "If Scallup_check≟ False "
    if (Scallup_check ==   False  ):
      $ 1974 "touch_result≔pose_trans(touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])
    else:
      $ 1975 "Else" "noBreak"
      $ 1976 "Scallup_check≔ False "
      global Scallup_check=  False  
    end
    $ 1979 "A_Touch_p[A_sel_v]=touch_result"
    A_Touch_p[A_sel_v]=touch_result
    $ 1980 "If EXT_flag1[3]≟ True "
    if (EXT_flag1[3] ==   True  ):
      $ 1981 "MoveL"
      $ 1982 "manual_tp≔tilt_3f_fun(A_Touch_p[A_sel_v],basic_tilt_3f,0)"
      global manual_tp=tilt_3f_fun(A_Touch_p[A_sel_v],basic_tilt_3f,0)
      $ 1983 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
      global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
      $ 1984 "manual_tp" "breakAfter"
      movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
      $ 1985 "Wait: 1.5"
      sleep(1.5)
    end
    $ 1986 "touch_3f_up"
    $ 1987 "If A_Prepos_l[A_sel_v_end]≟p[0,0,0,0,0,0]"
    if (A_Prepos_l[A_sel_v_end] == p[0,0,0,0,0,0]):
      $ 1988 "A_Touch_p[A_sel_v_end]=p[0,0,0,0,0,0]"
      A_Touch_p[A_sel_v_end]=p[0,0,0,0,0,0]
    else:
      $ 1989 "Else" "noBreak"
      $ 1990 "b_touch_pos≔A_Prepos_l[A_sel_v_end]"
      global b_touch_pos=A_Prepos_l[A_sel_v_end]
      $ 1991 "MoveL"
      $ 1992 "b_touch_pos" "breakAfter"
      movel(pose_trans(Base, b_touch_pos), a=0.7, v=0.5)
      $ 1993 "touch_result≔touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens)"
      global touch_result=touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens)
      $ 1994 "A_Touch_p[A_sel_v_end]=touch_result"
      A_Touch_p[A_sel_v_end]=touch_result
      $ 1995 "If EXT_flag1[3]≟ True "
      if (EXT_flag1[3] ==   True  ):
        $ 1996 "MoveL"
        $ 1997 "manual_tp≔A_Touch_p[A_sel_v_end]"
        global manual_tp=A_Touch_p[A_sel_v_end]
        $ 1998 "manual_tp≔tilt_3f_fun(A_Touch_p[A_sel_v_end],basic_tilt_3f,0)"
        global manual_tp=tilt_3f_fun(A_Touch_p[A_sel_v_end],basic_tilt_3f,0)
        $ 1999 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
        global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
        $ 2000 "manual_tp" "breakAfter"
        movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
        $ 2001 "Wait: 1.5"
        sleep(1.5)
      end
    end
  end
  def weav_welding_3f():
    $ 2005 "weav_welding_3f" "noBreak"
    $ 2006 "If running_trig≟ True "
    global thread_flag_2006=0
    thread Thread_if_2006():
      $ 2007 "inv_inching(inv_inch_time)"
      inv_inching(inv_inch_time)
      $ 2008 "b_touch_pos≔A_Prepos_l[A_sel_v]"
      global b_touch_pos=A_Prepos_l[A_sel_v]
      $ 2009 "move_pre"
      $ 2010 "j_cp≔get_actual_joint_positions()"
      global j_cp= get_actual_joint_positions ()
      $ 2011 "If b2_left_par"
      if (b2_left_par):
        $ 2012 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 2013 "inner_p≔p[-10/1000,-35/1000,0,0,0,0]"
          global inner_p=p[-10/1000,-35/1000,0,0,0,0]
        else:
          $ 2014 "Else" "noBreak"
          $ 2015 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 2016 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=left_j)"
        global j_tp= get_inverse_kin (pose_add(b_touch_pos,inner_p),qnear=left_j)
      else:
        $ 2017 "Else" "noBreak"
        $ 2018 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 2019 "inner_p≔p[-10/1000,35/1000,0,0,0,0]"
          global inner_p=p[-10/1000,35/1000,0,0,0,0]
        else:
          $ 2020 "Else" "noBreak"
          $ 2021 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 2022 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=right_j)"
        global j_tp= get_inverse_kin ( pose_add (b_touch_pos,inner_p),qnear=right_j)
      end
      $ 2023 "j_cp[0]=j_tp[0]"
      j_cp[0]=j_tp[0]
      $ 2024 "j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2"
      j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2
      $ 2025 "j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/3"
      j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/3
      $ 2026 "j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/3"
      j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/3
      $ 2027 "j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/1"
      j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/1
      $ 2028 "j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1"
      j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1
      $ 2029 "MoveJ"
      $ 2030 "j_cp" "breakAfter"
      movej(j_cp, a=1.3962634015954636, v=1.0471975511965976)
      $ 2031 "j_tp≔[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]"
      global j_tp=[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]
      $ 2032 "MoveJ"
      $ 2033 "j_tp" "breakAfter"
      movej(j_tp, a=1.3962634015954636, v=1.0471975511965976)
      $ 2034 "MoveL"
      $ 2035 "b_touch_pos" "breakAfter"
      movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
      $ 2036 "If (b2_left_par≟ True ) and (b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c) and (A_sel_v≠A_VL2)"
      if ((b2_left_par ==   True  )  and  (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c)  and  (A_sel_v != A_VL2)):
        $ 2037 "begin_3f_p≔pose_trans(A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])"
        global begin_3f_p= pose_trans (A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])
      else:
        $ 2038 "ElseIf (b2_left_par≟ False ) and (b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c) and (A_sel_v≠A_VR2)"
        if ((b2_left_par ==   False  )  and  (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c)  and  (A_sel_v != A_VR2)):
          $ 2039 "begin_3f_p≔pose_trans(A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])"
          global begin_3f_p= pose_trans (A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])
        else:
          $ 2040 "Else" "noBreak"
          $ 2041 "begin_3f_p≔A_Touch_p[A_sel_v]"
          global begin_3f_p=A_Touch_p[A_sel_v]
        end
      end
      $ 2042 "If b2_left_par≟ False "
      if (b2_left_par ==   False  ):
        $ 2043 "If (b1_cell_info_R≟c or b1_cell_info_R≟d) and A_sel_v≟A_VR2"
        if ((b1_cell_info_R == c  or  b1_cell_info_R == d)  and  A_sel_v == A_VR2):
          $ 2045 "b7_tilt_degree≔[-72,-20,15]"
          global b7_tilt_degree=[-72,-20,15]
          $ 2046 "begin_3f_p=pose_add(begin_3f_p,p[-6/1000,-1.5/1000,0,0,0,0])"
          begin_3f_p= pose_add (begin_3f_p,p[-6/1000,-1.5/1000,0,0,0,0])
          $ 2047 "a2_speed_cpm≔a2_speed_cpm*1"
          global a2_speed_cpm=a2_speed_cpm*1
          $ 2048 "a3_wv_amplitude≔a3_wv_amplitude*1"
          global a3_wv_amplitude=a3_wv_amplitude*1
          $ 2049 "a4_wv_frequency≔a4_wv_frequency*1"
          global a4_wv_frequency=a4_wv_frequency*1
          $ 2050 "b3_dealy_all≔[0,b4_wv_delay2*1,0,b6_wv_delay4*1]"
          global b3_dealy_all=[0,b4_wv_delay2*1,0,b6_wv_delay4*1]
          $ 2051 "a0_volt_ref≔a0_volt_ref*1"
          global a0_volt_ref=a0_volt_ref*1
          $ 2052 "a1_amp_ref≔a1_amp_ref*1"
          global a1_amp_ref=a1_amp_ref*1
          $ 2053 "volt and current"
          $ 2054 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
          global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
          $ 2055 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
          set_current_voltage(a1_amp_ref,a0_volt_ref)
        end
      end
      $ 2064 "welding_result = line_weaving_tp(begin_3f_p,A_Touch_p[A_sel_v_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
      welding_result = line_weaving_tp(begin_3f_p,A_Touch_p[A_sel_v_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
      thread_flag_2006 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2006=run Thread_if_2006()
      while (thread_flag_2006 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2006
          thread_flag_2006 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2006 = 2
    end
    $ 2065 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2066 "homeing()"
    homeing()
    $ 2067 "If sludge≟1"
    if (sludge == 1):
      $ 2068 "pause_trig≔ True "
      global pause_trig=  True  
    end
  end
  def weav_welding_2f():
    $ 2069 "weav_welding_2f" "noBreak"
    $ 2070 "If running_trig≟ True "
    global thread_flag_2070=0
    thread Thread_if_2070():
      $ 2071 "Calculation"
      $ 2072 "If Auto_W_num[Auto_cur_cell]≟31 or Auto_W_num[Auto_cur_cell]≟32 or Auto_W_num[Auto_cur_cell]≟30"
      if (Auto_W_num[Auto_cur_cell] == 31  or  Auto_W_num[Auto_cur_cell] == 32  or  Auto_W_num[Auto_cur_cell] == 30):
        $ 2073 "cal_single"
        $ 2074 "pos_m_path≔A_Touch_p[A_HOR]"
        global pos_m_path=A_Touch_p[A_HOR]
        $ 2075 "pos_m_path_end≔A_Touch_p[A_HOR_R]"
        global pos_m_path_end=A_Touch_p[A_HOR_R]
        $ 2076 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
      else:
        $ 2077 "Else" "noBreak"
        $ 2078 "side_offset≔10*current_path"
        global side_offset=10*current_path
        $ 2079 "side_offset≔0"
        global side_offset=0
        $ 2080 "If current_path≟2 or current_path≟4"
        if (current_path == 2  or  current_path == 4):
          $ 2081 "center_offset≔15"
          global center_offset=15
        else:
          $ 2082 "Else" "noBreak"
          $ 2083 "center_offset≔0"
          global center_offset=0
        end
        $ 2084 "cal_multi"
        $ 2085 "pos_m_path≔A_Touch_p[A_HOR]"
        global pos_m_path=A_Touch_p[A_HOR]
        $ 2086 "pos_m_path≔pose_trans(pos_m_path, p[side_offset/1000,0,0,0,0,0])"
        global pos_m_path= pose_trans (pos_m_path, p[side_offset/1000,0,0,0,0,0])
        $ 2087 "pos_m_path_end≔A_Touch_p[A_HOR_R]"
        global pos_m_path_end=A_Touch_p[A_HOR_R]
        $ 2088 "pos_m_path_end≔pose_trans(pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])"
        global pos_m_path_end= pose_trans (pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])
        $ 2089 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2090 "A_middle_weld≔pose_trans(A_middle_weld, p[-center_offset/1000,0,0,0,0,0])"
        global A_middle_weld= pose_trans (A_middle_weld, p[-center_offset/1000,0,0,0,0,0])
      end
      $ 2091 "gap_half"
      $ 2092 "gap_amp_bak≔c5_wv_gap_y"
      global gap_amp_bak=c5_wv_gap_y
      $ 2093 "gap_speed_bak≔c6_wv_gap_cpm"
      global gap_speed_bak=c6_wv_gap_cpm
      $ 2094 "gap_freq_bak≔c9_wv_gap_freq"
      global gap_freq_bak=c9_wv_gap_freq
      $ 2095 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
      global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
      $ 2096 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
      global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
      $ 2097 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
      global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
      $ 2098 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
      global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
      $ 2099 "Weaving"
      $ 2100 "If EXT_flag1[6]"
      if (EXT_flag1[6]):
        $ 2101 "If Auto_W_num[Auto_cur_cell]%10≟1"
        if (Auto_W_num[Auto_cur_cell]%10 == 1):
          $ 2102 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2103 "wv_direction≔1"
          global wv_direction=1
          $ 2104 "welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          $ 2105 "Wait: 0.5"
          sleep(0.5)
        end
        $ 2106 "If Auto_W_num[Auto_cur_cell]%10≟2"
        if (Auto_W_num[Auto_cur_cell]%10 == 2):
          $ 2107 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2108 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
          global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
          $ 2109 "gap_half_right"
          $ 2110 "a3_wv_amplitude≔gap_amp_bak"
          global a3_wv_amplitude=gap_amp_bak
          $ 2111 "a2_speed_cpm≔gap_speed_bak"
          global a2_speed_cpm=gap_speed_bak
          $ 2112 "a4_wv_frequency≔gap_freq_bak"
          global a4_wv_frequency=gap_freq_bak
          $ 2113 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
          global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
          $ 2114 "wv_direction≔-1"
          global wv_direction=-1
          $ 2115 "A_middle_weld≔feature_offset(A_middle_weld,p[-20/1000,0,0,0,0,0],A_Touch_p[A_sel_v])"
          global A_middle_weld=feature_offset(A_middle_weld,p[-20/1000,0,0,0,0,0],A_Touch_p[A_sel_v])
          $ 2116 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
        end
      else:
        $ 2118 "Else" "noBreak"
        $ 2119 "If Auto_W_num[Auto_cur_cell]%10≟0"
        if (Auto_W_num[Auto_cur_cell]%10 == 0):
          $ 2120 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2121 "wv_direction≔1"
          global wv_direction=1
          $ 2122 "welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
        else:
          $ 2123 "Else" "noBreak"
          $ 2124 "write_port_register(142,142)"
          write_port_register(142,142)
          $ 2125 "Halt"
          halt
        end
      end
      thread_flag_2070 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2070=run Thread_if_2070()
      while (thread_flag_2070 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2070
          thread_flag_2070 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2070 = 2
    end
    $ 2126 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2127 "MoveL"
    $ 2128 "Direction: Tool Z-"
    global move_thread_flag_2128=0
    thread move_thread_2128():
      enter_critical
      move_thread_flag_2128 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.03)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_2128 = 2
      exit_critical
    end
    move_thread_flag_2128 = 0
    move_thread_han_2128 = run move_thread_2128()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_2128 > 1):
        join move_thread_han_2128
        $ 2129 "Until (distance)"
        break
      end
      sync()
    end
    $ 2130 "homeing()"
    homeing()
    $ 2131 "If sludge≟1 or (sludge≟2 and current_path>1)"
    if (sludge == 1  or  (sludge == 2  and  current_path>1)):
      $ 2132 "If  not (Auto_W_num[Auto_cur_cell]%10≟1)"
      if (  not  (Auto_W_num[Auto_cur_cell]%10 == 1)):
        $ 2133 "pause_trig≔ True "
        global pause_trig=  True  
      end
    end
  end
  def weav_welding_2f_CD():
    $ 2134 "weav_welding_2f_CD" "noBreak"
    $ 2135 "If running_trig≟ True "
    global thread_flag_2135=0
    thread Thread_if_2135():
      $ 2136 "CD_calculation"
      $ 2137 "If (Auto_W_num[Auto_cur_cell]≥100 and Auto_W_num[Auto_cur_cell]<106)  or (Auto_W_num[Auto_cur_cell]≥150 and Auto_W_num[Auto_cur_cell]<156)"
      if ((Auto_W_num[Auto_cur_cell] >= 100  and  Auto_W_num[Auto_cur_cell]<106)   or  (Auto_W_num[Auto_cur_cell] >= 150  and  Auto_W_num[Auto_cur_cell]<156)):
        $ 2138 "cal single"
        $ 2139 "cal_1"
        $ 2140 "pos_m_path_cd≔A_Touch_p[A_sel_v]"
        global pos_m_path_cd=A_Touch_p[A_sel_v]
        $ 2141 "pos_m_p_end_cd≔A_Touch_p[A_sel_v_end]"
        global pos_m_p_end_cd=A_Touch_p[A_sel_v_end]
        $ 2142 "cal_2"
        $ 2143 "pos_m_path≔A_Touch_p[A_sel_v2]"
        global pos_m_path=A_Touch_p[A_sel_v2]
        $ 2144 "pos_m_path_end≔A_Touch_p[A_sel_v_end2]"
        global pos_m_path_end=A_Touch_p[A_sel_v_end2]
        $ 2145 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
      else:
        $ 2146 "Else" "noBreak"
        $ 2147 "cal multi"
        $ 2148 "side_offset≔0"
        global side_offset=0
        $ 2149 "If current_path≟2 or current_path≟4"
        if (current_path == 2  or  current_path == 4):
          $ 2150 "center_offset≔15"
          global center_offset=15
        else:
          $ 2151 "Else" "noBreak"
          $ 2152 "center_offset≔0"
          global center_offset=0
        end
        $ 2153 "cal_1_multi"
        $ 2154 "pos_m_path_cd≔A_Touch_p[A_sel_v]"
        global pos_m_path_cd=A_Touch_p[A_sel_v]
        $ 2155 "pos_m_path_cd≔pose_trans(pos_m_path_cd, p[side_offset/1000,0,0,0,0,0])"
        global pos_m_path_cd= pose_trans (pos_m_path_cd, p[side_offset/1000,0,0,0,0,0])
        $ 2156 "pos_m_p_end_cd≔A_Touch_p[A_sel_v_end]"
        global pos_m_p_end_cd=A_Touch_p[A_sel_v_end]
        $ 2157 "pos_m_p_end_cd≔pose_trans(pos_m_p_end_cd, p[-side_offset/1000,0,0,0,0,0])"
        global pos_m_p_end_cd= pose_trans (pos_m_p_end_cd, p[-side_offset/1000,0,0,0,0,0])
        $ 2158 "cal_2_multi"
        $ 2159 "pos_m_path≔A_Touch_p[A_sel_v2]"
        global pos_m_path=A_Touch_p[A_sel_v2]
        $ 2160 "pos_m_path≔pose_trans(pos_m_path, p[side_offset/1000,0,0,0,0,0])"
        global pos_m_path= pose_trans (pos_m_path, p[side_offset/1000,0,0,0,0,0])
        $ 2161 "pos_m_path_end≔A_Touch_p[A_sel_v_end2]"
        global pos_m_path_end=A_Touch_p[A_sel_v_end2]
        $ 2162 "pos_m_path_end≔pose_trans(pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])"
        global pos_m_path_end= pose_trans (pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])
        $ 2163 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2164 "A_middle_weld≔pose_trans(A_middle_weld, p[center_offset*wv_direction/1000,0,0,0,0,0])"
        global A_middle_weld= pose_trans (A_middle_weld, p[center_offset*wv_direction/1000,0,0,0,0,0])
      end
      $ 2165 "gap_half"
      $ 2166 "gap_amp_bak≔c5_wv_gap_y"
      global gap_amp_bak=c5_wv_gap_y
      $ 2167 "gap_speed_bak≔c6_wv_gap_cpm"
      global gap_speed_bak=c6_wv_gap_cpm
      $ 2168 "gap_freq_bak≔c9_wv_gap_freq"
      global gap_freq_bak=c9_wv_gap_freq
      $ 2169 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
      global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
      $ 2170 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
      global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
      $ 2171 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
      global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
      $ 2172 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
      global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
      $ 2173 "If EXT_flag1[4]≟ True  and (b1_cell_info_L≠c and b1_cell_info_L≠d and b1_cell_info_R≠c and b1_cell_info_R≠d)"
      if (EXT_flag1[4] ==   True    and  (b1_cell_info_L != c  and  b1_cell_info_L != d  and  b1_cell_info_R != c  and  b1_cell_info_R != d)):
        $ 2174 "If EXT_flag1[6]"
        if (EXT_flag1[6]):
          $ 2175 "If Auto_W_num[Auto_cur_cell]%10≟1"
          if (Auto_W_num[Auto_cur_cell]%10 == 1):
            $ 2176 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2177 "welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,A_middle_weld],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,A_middle_weld],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
          $ 2178 "If Auto_W_num[Auto_cur_cell]%10≟4"
          if (Auto_W_num[Auto_cur_cell]%10 == 4):
            $ 2179 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2180 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
            global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
            $ 2181 "gap_half"
            $ 2182 "a3_wv_amplitude≔gap_amp_bak"
            global a3_wv_amplitude=gap_amp_bak
            $ 2183 "a2_speed_cpm≔gap_speed_bak"
            global a2_speed_cpm=gap_speed_bak
            $ 2184 "a4_wv_frequency≔gap_freq_bak"
            global a4_wv_frequency=gap_freq_bak
            $ 2185 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2186 "wv_direction≔-1*wv_direction"
            global wv_direction=-1*wv_direction
            $ 2187 "A_middle_weld≔feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])"
            global A_middle_weld=feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])
            $ 2188 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
        else:
          $ 2189 "Else" "noBreak"
          $ 2190 "If Auto_W_num[Auto_cur_cell]%10≟0"
          if (Auto_W_num[Auto_cur_cell]%10 == 0):
            $ 2191 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2192 "welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,pos_m_path_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,pos_m_path_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          else:
            $ 2193 "Else" "noBreak"
            $ 2194 "write_port_register(142,142)"
            write_port_register(142,142)
            $ 2195 "Halt"
            halt
          end
        end
      else:
        $ 2196 "Else" "noBreak"
        $ 2197 "If EXT_flag1[6]"
        if (EXT_flag1[6]):
          $ 2198 "If Auto_W_num[Auto_cur_cell]%10≟2"
          if (Auto_W_num[Auto_cur_cell]%10 == 2):
            $ 2199 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2200 "gap_half"
            $ 2201 "gap_amp_bak≔c5_wv_gap_y"
            global gap_amp_bak=c5_wv_gap_y
            $ 2202 "gap_speed_bak≔c6_wv_gap_cpm"
            global gap_speed_bak=c6_wv_gap_cpm
            $ 2203 "gap_freq_bak≔c9_wv_gap_freq"
            global gap_freq_bak=c9_wv_gap_freq
            $ 2204 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
            global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
            $ 2205 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
            global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
            $ 2206 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
            global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
            $ 2207 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2208 "welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2209 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2210 "If Auto_W_num[Auto_cur_cell]%10≟3"
          if (Auto_W_num[Auto_cur_cell]%10 == 3):
            $ 2211 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2212 "welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2213 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2214 "If Auto_W_num[Auto_cur_cell]%10≟4"
          if (Auto_W_num[Auto_cur_cell]%10 == 4):
            $ 2215 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2216 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
            global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
            $ 2217 "gap_half"
            $ 2218 "a3_wv_amplitude≔gap_amp_bak"
            global a3_wv_amplitude=gap_amp_bak
            $ 2219 "a2_speed_cpm≔gap_speed_bak"
            global a2_speed_cpm=gap_speed_bak
            $ 2220 "a4_wv_frequency≔gap_freq_bak"
            global a4_wv_frequency=gap_freq_bak
            $ 2221 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2222 "wv_direction≔-1*wv_direction"
            global wv_direction=-1*wv_direction
            $ 2223 "A_middle_weld≔feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])"
            global A_middle_weld=feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])
            $ 2224 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
        else:
          $ 2225 "Else" "noBreak"
          $ 2226 "If Auto_W_num[Auto_cur_cell]%10≟2"
          if (Auto_W_num[Auto_cur_cell]%10 == 2):
            $ 2227 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2228 "c7_wv_gap≔[0,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[0,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2229 "welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2230 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2231 "If Auto_W_num[Auto_cur_cell]%10≟5"
          if (Auto_W_num[Auto_cur_cell]%10 == 5):
            $ 2232 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2233 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2234 "welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2235 "Wait: 0.5"
            sleep(0.5)
          end
        end
      end
      thread_flag_2135 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2135=run Thread_if_2135()
      while (thread_flag_2135 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2135
          thread_flag_2135 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2135 = 2
    end
    $ 2236 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2240 "wv_direction≔1"
    global wv_direction=1
    $ 2241 "MoveL"
    $ 2242 "Direction: Tool Z-"
    global move_thread_flag_2242=0
    thread move_thread_2242():
      enter_critical
      move_thread_flag_2242 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.03)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_2242 = 2
      exit_critical
    end
    move_thread_flag_2242 = 0
    move_thread_han_2242 = run move_thread_2242()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_2242 > 1):
        join move_thread_han_2242
        $ 2243 "Until (distance)"
        break
      end
      sync()
    end
    $ 2244 "homeing()"
    homeing()
    $ 2245 "If sludge≟1 or (sludge≟2 and current_path>1)"
    if (sludge == 1  or  (sludge == 2  and  current_path>1)):
      $ 2246 "If  not (Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2 or Auto_W_num[Auto_cur_cell]%10≟3)"
      if (  not  (Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2  or  Auto_W_num[Auto_cur_cell]%10 == 3)):
        $ 2247 "pause_trig≔ True "
        global pause_trig=  True  
      end
    end
  end
  def reset_weld_param():
    $ 2248 "reset_weld_param" "noBreak"
    $ 2249 "start_num≔225"
    global start_num=225
    $ 2250 "Loop start_num<237"
    while (start_num<237):
      $ 2251 "write_port_register(start_num,0)"
      write_port_register(start_num,0)
      $ 2252 "start_num≔start_num+1"
      global start_num=start_num+1
    end
    $ 2253 "start_num≔240"
    global start_num=240
    $ 2254 "Loop start_num<256"
    while (start_num<256):
      $ 2255 "write_port_register(start_num,0)"
      write_port_register(start_num,0)
      $ 2256 "start_num≔start_num+1"
      global start_num=start_num+1
    end
  end
  def touch_sub():
    $ 2257 "touch_sub" "noBreak"
    $ 2258 "freedrive"
    $ 2259 "save_timer: Start"
    save_timer_is_counting = True
    $ 2260 "Loop save_tool≟ False  and save_timer≤0.5"
    while (get_tool_digital_in(0) ==   False    and  save_timer <= 0.5):
      $ 2261 "If save_tool≟ False "
      if (get_tool_digital_in(0) ==   False  ):
        $ 2262 "save_timer≔0"
        global save_timer=0
      end
      $ 2263 "If freedrive≟ True  and freedrive_trg≟ False "
      if (get_tool_digital_in(1) ==   True    and  freedrive_trg ==   False  ):
        $ 2264 "'Manual - Freedrive'"
        # 'Manual - Freedrive'
        $ 2265 "freedrive_mode()"
        freedrive_mode()
        $ 2266 "freedrive_trg≔ True "
        global freedrive_trg=  True  
      else:
        $ 2267 "ElseIf freedrive≟ False  and freedrive_trg≟ True "
        if (get_tool_digital_in(1) ==   False    and  freedrive_trg ==   True  ):
          $ 2268 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 2269 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
      end
      $ 2270 "If lamp_trig≟ False "
      if (lamp_trig ==   False  ):
        $ 2271 "lamp_trig≔ True "
        global lamp_trig=  True  
      end
      $ 2272 "sync()"
      sync()
    end
    $ 2273 "save_timer: Stop"
    save_timer_is_counting = False
    $ 2274 "save_timer: Reset"
    save_timer = 0
    $ 2275 "write_port_register(touch_done_157,1)"
    write_port_register(touch_done_157,1)
    $ 2276 "Wait read_port_register(touch_done_157)≟0"
    while (not( read_port_register (touch_done_157) == 0)):
      sync()
    end
    $ 2277 "Wait save_tool=LO"
    while (get_tool_digital_in(0) == True):
      sync()
    end
  end
  $ 2 "BeforeStart"
  $ 3 "'RobotVersion'"
  # 'RobotVersion'
  $ 4 "write_port_register(160,45)"
  write_port_register(160,45)
  $ 5 "Teaching for Touch"
  $ 6 "g_current_p≔get_actual_tcp_pose()"
  global g_current_p= get_actual_tcp_pose ()
  $ 7 "MoveJ"
  $ 8 "g_current_p" "breakAfter"
  movej(g_current_p, a=1.3962634015954636, v=1.0471975511965976, r=0.05)
  $ 9 "If  False "
  if (  False  ):
    $ 10 "MoveJ"
    $ 11 "'Home'"
    # 'Home'
    $ 12 "first_p" "breakAfter"
    movej([0.6572912931442261, -1.1853707472430628, -1.1612256209002894, -2.29183799425234, 1.5053011178970337, 2.249363422393799], a=1.3962634015954636, v=1.0471975511965976)
    $ 13 "'3F Left Right'"
    # '3F Left Right'
    $ 14 "left" "breakAfter"
    movej([1.0434843552115187, -1.5100991608390455, -1.7306758129700324, -1.1948061631169296, 1.4628666284450171, 1.848321797880608], a=1.3962634015954636, v=1.0471975511965976)
    $ 15 "right" "breakAfter"
    movej([-0.10351455753530914, -1.3302576856500608, -2.115934992292752, -0.862193753976749, 1.3219395896157813, 2.4264792168573246], a=1.3962634015954636, v=1.0471975511965976)
    $ 16 "'2F Left Right'"
    # '2F Left Right'
    $ 17 "up_left" "breakAfter"
    movej([1.1752926889699076, -1.8019900427886952, -1.320977727654376, -1.5255442863405975, 1.3476341406937622, 2.041365262351603], a=1.3962634015954636, v=1.0471975511965976)
    $ 18 "up_right" "breakAfter"
    movej([-0.490858516659304, -1.5854285429454542, -1.6450882962874376, -1.2830655228732084, 1.6157391701919699, 1.9100727821897805], a=1.3962634015954636, v=1.0471975511965976)
    $ 19 "Packing_pos" "breakAfter"
    movej([1.5877798795700073, -0.0173419157611292, -2.4983108679400843, -1.4065726439105433, 1.626846194267273, 3.0169763565063477], a=1.3962634015954636, v=1.0471975511965976)
    $ 20 "pre_position" "breakAfter"
    movej([1.2637099027633667, -0.695505444203512, -2.0481718222247522, -1.9413569609271448, 2.573765277862549, 1.3775802850723267], a=1.3962634015954636, v=1.0471975511965976)
    $ 21 "middle_pos" "breakAfter"
    movej([-1.8762093791333925, -1.0408674059020342, -1.3551139327963426, -1.843592441478755, 1.9056326083560464, 0.7075109167810423], a=1.3962634015954636, v=1.0471975511965976)
    $ 22 "Mounting_pos" "breakAfter"
    movej([0.6231353085164267, -0.6300961531972575, -0.9034285948871803, -1.770059340221131, 1.417516049558281, 1.7792033261567348], a=1.3962634015954636, v=1.0471975511965976)
    $ 23 "pre_mounting" "breakAfter"
    movej([1.2356762886047363, -0.8703244368182581, -0.942230526600973, -2.3905327955829065, 1.3216267824172974, 2.6514604091644287], a=1.3962634015954636, v=1.0471975511965976)
    $ 24 "'firstly touch center and side, side_L is side touch pose'"
    # 'firstly touch center and side, side_L is side touch pose'
    $ 25 "side_p_L" "breakAfter"
    movej([0.7063748268745771, -1.3604975314992132, -1.990433834727808, -1.0668367667667118, 1.6921872781537495, 1.2509236145111355], a=1.3962634015954636, v=1.0471975511965976)
    $ 26 "side_p_R" "breakAfter"
    movej([0.05431400611996651, -1.4896310011493128, -1.8839471975909632, -1.079590145741598, 1.21127450466156, 2.729013204574585], a=1.3962634015954636, v=1.0471975511965976)
    $ 27 "top_right" "breakAfter"
    movej([-0.02242371234582219, -0.9682979219978707, -1.1486403794481532, -1.814672356578109, 1.0564512116488283, 1.9516847799391646], a=1.3962634015954636, v=1.0471975511965976)
    $ 28 "down_right" "breakAfter"
    movej([-0.10387097169690396, -0.8634965401570085, -1.6224404602167288, -1.9527388322769834, 1.2604034373302166, 1.9362943911099855], a=1.3962634015954636, v=1.0471975511965976)
    $ 29 "way_600_3F_VL1" "breakAfter"
    movej([1.4495428629911409, -0.8691188832486789, -1.6280015865128723, -1.109862842185814, 0.958613460846621, 1.8600136596738885], a=1.3962634015954636, v=1.0471975511965976)
    $ 30 "way_3F_42" "breakAfter"
    movej([0.36805654405146704, -0.7862968504575107, -2.173257016154224, -1.4479178800416523, 0.8821879504915225, 2.8855763836420314], a=1.3962634015954636, v=1.0471975511965976)
    $ 31 "Waypoint_3" "breakAfter"
    movej([1.1380372507706311, -0.9407851141189099, -1.233329099346161, -2.2390373632318763, 1.2601061328687342, 1.8320151492624872], a=1.3962634015954636, v=1.0471975511965976)
  end
  $ 32 "waypoint"
  $ 33 "first_p_wp≔first_p"
  global first_p_wp=p[.431245807847, -.007259877891, .087796870964, 2.814824648791, -.024151220978, 1.380109909682]
  $ 34 "home_pos_j≔get_inverse_kin(first_p,qnear=[0.788235068321228, -1.101443115864889, -1.2219904104815882, -2.3243168036090296, 1.506469488143921, 2.3651483058929443])"
  global home_pos_j= get_inverse_kin (p[.431245807847, -.007259877891, .087796870964, 2.814824648791, -.024151220978, 1.380109909682],qnear=[0.788235068321228, -1.101443115864889, -1.2219904104815882, -2.3243168036090296, 1.506469488143921, 2.3651483058929443])
  $ 35 "left_j≔get_inverse_kin(left,qnear=[1.0260889556530308, -1.5106289215345097, -1.741216762689402, -1.178962336228949, 1.4987324920877318, 1.8103628938054515])"
  global left_j= get_inverse_kin (p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605],qnear=[1.0260889556530308, -1.5106289215345097, -1.741216762689402, -1.178962336228949, 1.4987324920877318, 1.8103628938054515])
  $ 36 "right_j≔get_inverse_kin(right,qnear=[-0.04005625546610858, -1.5553040811514833, -1.9086689348599588, -0.877043115030812, 1.298887151057777, 2.511237649551841])"
  global right_j= get_inverse_kin (p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292],qnear=[-0.04005625546610858, -1.5553040811514833, -1.9086689348599588, -0.877043115030812, 1.298887151057777, 2.511237649551841])
  $ 37 "Packing_pos_wp≔Packing_pos"
  global Packing_pos_wp=p[.278714911898, .357008020042, .025408199530, -2.146966801259, .195978635494, -.919933898512]
  $ 38 "pre_position_wp≔pre_position"
  global pre_position_wp=p[-.206981089246, .377817475970, .184983176991, -1.570600793609, -.863923490888, -.089005332274]
  $ 39 "pre_mounting_wp≔pre_mounting"
  global pre_mounting_wp=p[.460443249232, .114922015113, .277198878359, -2.240057458299, .067416497001, -1.614091004704]
  $ 40 "mounting_wp≔Mounting_pos"
  global mounting_wp=p[.365658114054, -.003207132620, .718667154922, -1.220752075696, -.066673751622, -2.363385143972]
  $ 41 "Setting"
  $ 42 "inv_inch_time≔0.4"
  global inv_inch_time=0.4
  $ 43 "a7_cell_bottom≔-50.2"
  global a7_cell_bottom=-50.2
  $ 44 "get_center≔470"
  global get_center=470
  $ 45 "work_touch_dis≔50"
  global work_touch_dis=50
  $ 46 "cd_extra_dis≔6"
  global cd_extra_dis=6
  $ 47 "side_pos_x≔-10"
  global side_pos_x=-10
  $ 48 "sec_touch_dis≔35"
  global sec_touch_dis=35
  $ 49 "Touch_dis≔30"
  global Touch_dis=30
  $ 50 "offset_2f_begin≔5"
  global offset_2f_begin=5
  $ 51 "offset_3f_begin≔5"
  global offset_3f_begin=5
  $ 52 "multi_offset_z≔3"
  global multi_offset_z=3
  $ 53 "simulation_mode≔ False "
  global simulation_mode=  False  
  $ 54 "tilt_deg_man≔7"
  global tilt_deg_man=7
  $ 55 "Initialization"
  $ 56 "reset_revolution_counter()"
  reset_revolution_counter()
  $ 57 "get_center_bak≔get_center"
  global get_center_bak=get_center
  $ 58 "welding_program≔ False "
  global welding_program=  False  
  $ 59 "vr2_p1≔p[0,0,0,0,0,0]"
  global vr2_p1=p[0,0,0,0,0,0]
  $ 60 "running_trig≔ False "
  global running_trig=  False  
  $ 61 "pb_comm_count≔0"
  global pb_comm_count=0
  $ 62 "pendant_hb≔read_port_register(161)"
  global pendant_hb= read_port_register (161)
  $ 63 "pause_trig≔ False "
  global pause_trig=  False  
  $ 64 "multi_path≔1"
  global multi_path=1
  $ 65 "reset_trig≔ False "
  global reset_trig=  False  
  $ 66 "heartbeat≔0"
  global heartbeat=0
  $ 67 "back_2f≔ False "
  global back_2f=  False  
  $ 68 "t_time≔0"
  global t_time=0
  $ 69 "cd_offset≔35"
  global cd_offset=35
  $ 70 "write_port_register(144,0)"
  write_port_register(144,0)
  $ 71 "time_cal_trig≔ False "
  global time_cal_trig=  False  
  $ 72 "current_2f≔0"
  global current_2f=0
  $ 73 "A_cur_2f≔0"
  global A_cur_2f=0
  $ 74 "CD_MLR≔ True "
  global CD_MLR=  True  
  $ 75 "auto_on≔ False "
  global auto_on=  False  
  $ 76 "event_cal_on≔ False "
  global event_cal_on=  False  
  $ 77 "event_side_on≔ False "
  global event_side_on=  False  
  $ 78 "Auto_trig≔ False "
  global Auto_trig=  False  
  $ 79 "lamp_trig≔ False "
  global lamp_trig=  False  
  $ 80 "calcu_trig≔ False "
  global calcu_trig=  False  
  $ 81 "current_path≔1"
  global current_path=1
  $ 82 "freedrive_trg≔ False "
  global freedrive_trg=  False  
  $ 83 "Inch_trg≔ False "
  global Inch_trg=  False  
  $ 84 "wv_direction≔1"
  global wv_direction=1
  $ 85 "Move_trig≔ False "
  global Move_trig=  False  
  $ 86 "CELL_ROBOT_DIST≔500"
  global CELL_ROBOT_DIST=500
  $ 87 "CELL_WIDTH≔700"
  global CELL_WIDTH=700
  $ 88 "CELL_BOTTOM≔a7_cell_bottom"
  global CELL_BOTTOM=a7_cell_bottom
  $ 89 "scallop_info≔ False "
  global scallop_info=  False  
  $ 90 "Carl_info≔ False "
  global Carl_info=  False  
  $ 91 "touch_done_2f≔ False "
  global touch_done_2f=  False  
  $ 92 "get_pose_side≔0"
  global get_pose_side=0
  $ 93 "get_pose_side_t≔0"
  global get_pose_side_t=0
  $ 94 "ba_trig≔ False "
  global ba_trig=  False  
  $ 95 "touch_m_check≔0"
  global touch_m_check=0
  $ 96 "basic_tilt_2f≔[30,5,0]"
  global basic_tilt_2f=[30,5,0]
  $ 98 "basic_tilt_3f≔[0,-27,0]"
  global basic_tilt_3f=[0,-27,0]
  $ 100 "modbus_name"
  $ 101 "weld_done_137≔137"
  global weld_done_137=137
  $ 102 "robot_ready_141≔141"
  global robot_ready_141=141
  $ 103 "cell_3f_2f_151≔151"
  global cell_3f_2f_151=151
  $ 104 "cell_info_152≔152"
  global cell_info_152=152
  $ 105 "weld_req_153≔153"
  global weld_req_153=153
  $ 106 "touch_cell_155≔155"
  global touch_cell_155=155
  $ 107 "touch_num_156≔156"
  global touch_num_156=156
  $ 108 "touch_done_157≔157"
  global touch_done_157=157
  $ 109 "robot_move_163≔163"
  global robot_move_163=163
  $ 110 "robot_pose_164≔164"
  global robot_pose_164=164
  $ 111 "work_type_165≔165"
  global work_type_165=165
  $ 112 "arc_onoff_168≔168"
  global arc_onoff_168=168
  $ 113 "beforeafter_170≔170"
  global beforeafter_170=170
  $ 114 "return_done_240≔240"
  global return_done_240=240
  $ 115 "a0_Job_Mode≔0"
  global a0_Job_Mode=0
  $ 116 "position_3F≔1"
  global position_3F=1
  $ 117 "position_2F≔2"
  global position_2F=2
  $ 118 "cell_par"
  $ 119 "A≔1"
  global A=1
  $ 120 "B≔2"
  global B=2
  $ 121 "C≔3"
  global C=3
  $ 122 "c≔4"
  global c=4
  $ 123 "D≔5"
  global D=5
  $ 124 "d≔6"
  global d=6
  $ 125 "E≔7"
  global E=7
  $ 126 "e≔8"
  global e=8
  $ 127 "A_VL1≔1"
  global A_VL1=1
  $ 128 "A_VL2≔2"
  global A_VL2=2
  $ 129 "A_VR1≔3"
  global A_VR1=3
  $ 130 "A_VR2≔4"
  global A_VR2=4
  $ 131 "A_HOR≔5"
  global A_HOR=5
  $ 132 "A_HOR_R≔7"
  global A_HOR_R=7
  $ 133 "A_HOR_ML≔6"
  global A_HOR_ML=6
  $ 134 "A_HOR_MR≔8"
  global A_HOR_MR=8
  $ 135 "A_HOR_M≔9"
  global A_HOR_M=9
  $ 136 "A_VL1_END≔10"
  global A_VL1_END=10
  $ 137 "A_VL2_END≔11"
  global A_VL2_END=11
  $ 138 "A_VR1_END≔12"
  global A_VR1_END=12
  $ 139 "A_VR2_END≔13"
  global A_VR2_END=13
  $ 140 "A_HOR_2path≔14"
  global A_HOR_2path=14
  $ 141 "A_HOR_3path≔15"
  global A_HOR_3path=15
  $ 142 "A_HOR_4path≔16"
  global A_HOR_4path=16
  $ 143 "A_HOR_2path_CD≔17"
  global A_HOR_2path_CD=17
  $ 144 "A_HOR_3path_CD≔18"
  global A_HOR_3path_CD=18
  $ 145 "A_HOR_4path_CD≔19"
  global A_HOR_4path_CD=19
  $ 146 "Script: UR_samho_weaving_V6.8_CB.script"
  wv_wp1 = p[0,0,0,0,0,0]
  dumy_p = p[0,0,0,0,0,0]
  global background_cal = 0
  global background_pose = [dumy_p,dumy_p,dumy_p]
  global background_ready = 0
  global timer_counter = 0
  global timer_counting = False
  global wcr_counter = 0
  global wcr_counting = False
  global get_wcr = False
  global arc_sens_onoff = 0
  global welding_off_t = 55
  global weld_onoff = False
  global isHicomm = True
  global isTouchWCR = True
  global welding_program = False
  global arc_sens_2F = False
  
  thread thread_timer():
    error_time = 5
    start_gas_time = 2
    while (True):
      if (timer_counting):
        timer_counter = timer_counter + get_steptime()
        write_output_float_register(0,timer_counter)
  
        get_wcr = read_welder(5)
        weld_onoff = read_welder_control(0)
  
        welding_off_t = read_port_register(168)
        if(get_wcr):
          global arc_sens_onoff = 1
        else:
          global arc_sens_onoff = 0
        end
        if(get_wcr and welding_off_t == 2 and weld_onoff == True):
          wcr_counter=0
        elif(wcr_counter>(error_time+start_gas_time) and welding_off_t == 2 and weld_onoff == True):
          write_port_register(202,0)
          write_port_register(149,0)
          write_welder(0,False)
          set_standard_digital_out(0,False)
          write_port_register(142,131)
          sleep(0.5)
          halt
        elif(get_wcr == False and welding_off_t == 2 and weld_onoff == True):
          wcr_counter = wcr_counter + get_steptime()
        end
      end
      sync()
    end
  end
  
  def RTDE_init():
    # timer
    write_output_float_register(0,0)
    # WCR IN
    write_output_float_register(1,0)
    # Welding Current
    write_output_float_register(2,0)
    # Welding Voltage
    write_output_float_register(3,0)
    # X offset
    write_output_float_register(4,0)
    # Z offset
    write_output_float_register(5,0)
    # PLUS Integral
    write_output_float_register(6,0)
    # MINUS Integral
    write_output_float_register(7,0)
    # Standard_Arc_Current
    write_output_float_register(8,0)
    # ALL Integral
    write_output_float_register(9,0)
    # x up
    write_output_float_register(10,0)
    # x ui
    write_output_float_register(11,0)
    # z up
    write_output_float_register(12,0)
    # z ui
    write_output_float_register(13,0)
    # x
    write_output_float_register(14,0)
    # y
    write_output_float_register(15,0)
    # z
    write_output_float_register(16,0)
    # welding on/off polyscope
    write_output_float_register(17,0)
    # touch on/off polyscope
    write_output_float_register(18,0)
    # ratio_t
    write_output_float_register(19,0)
    # get_wcr polyscope
    write_output_float_register(20,0)
    # get_touch polyscope
    write_output_float_register(21,0)
    # write_welder
    write_output_float_register(22,0)
    # MIDDLE_Integral_org
    write_output_float_register(23,0)
    # PLUS Integral_org
    write_output_float_register(24,0)
    # MINUS Integral_org
    write_output_float_register(25,0)
  
    #init
    global cycle_number = 0
    global cycle_done = False
    global cycle1_plus = 0
    global cycle1_minus = 0
    global cycle1_middle = 0
    global current_to_welding_m = read_port_register(133)
    global voltage_to_welding_m = read_port_register(134)/10
    global c_maxcut = current_to_welding_m*1.2
    global c_mincut = current_to_welding_m*0.8
    global v_maxcut = voltage_to_welding_m*1.2
    global v_mincut = voltage_to_welding_m*0.8
    global Standard_Arc_Current = current_to_welding_m
    global Standard_Arc_voltage = voltage_to_welding_m
    global FB_CURRENT_UR = 0
    global FB_VOLTAGE_UR = 0
    global FB_CURRENT_UR_org = 0
    global FB_VOLTAGE_UR_org = 0
    global one_cycle_p_count = 0
    global one_cycle_m_count = 0
    global one_cycle_p_accum = 0
    global one_cycle_m_accum = 0
    global one_cycle_p_accum_org = 0
    global one_cycle_m_accum_org = 0
    global cal_off_ang_rx = 0
    global cal_off_ang_ry = 0
    global Up = 0
    global Ui = 0
    global Pi_sum = 0
    global Up_z = 0
    global Ui_z = 0
    global Pi_sum_z = 0
    global peak_value = 0
    global ratio_t = 0
    global welding_off_t = 55
    global program_weld_on = False
    global next_path_c = False
    global move_p = [dumy_p,dumy_p,dumy_p]
    global hicomm = True
    global current_on = False
    timer_counter = 0
    sync()
  end
  
  # get line distance without caring orientation
  def get_line_dist(get_wp1,get_wp2):
    return sqrt((get_wp2[0]-get_wp1[0])*(get_wp2[0]-get_wp1[0])+(get_wp2[1]-get_wp1[1])*(get_wp2[1]-get_wp1[1])+(get_wp2[2]-get_wp1[2])*(get_wp2[2]-get_wp1[2]))
  end
  
  def plus_minus(num):
    if(num<0):
      return -1
    else:
      return 1
    end
  end
  
  def get_feature_plane_xz(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dy = cross_product(d13, d12)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dy)
    uy = [ dy[0]/temp, dy[1]/temp, dy[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uz = cross_product(ux, uy)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def get_feature_plane_yz(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dx = cross_product(d12, d13)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    uy = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dx)
    ux = [ dx[0]/temp, dx[1]/temp, dx[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uz = cross_product(ux, uy)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def get_feature_plane_xy(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dz = cross_product(d12, d13)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dz)
    uz = [ dz[0]/temp, dz[1]/temp, dz[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uy = cross_product(uz, ux)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  #### ur_weaving_rev1 by Henry
  #  x_feature = pose_trans(N_Pose,pose_inv(p[0,0,x,0,0,0])
  def feature_offset(fun_pose,fun_offset,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    fun_offrot = rotvec2rpy([fun_p_feature[3],fun_p_feature[4],fun_p_feature[5]])
    fun_offset = p[fun_offset[0],fun_offset[1],fun_offset[2],fun_offrot[0]+fun_offset[3],fun_offrot[1]+fun_offset[4],fun_offrot[2]+fun_offset[5]]
    fun_offset_p = p[fun_offset[0],fun_offset[1],fun_offset[2],0,0,0]
    fun_offrpy_rot = rpy2rotvec([fun_offset[3],fun_offset[4],fun_offset[5]])
    fun_offset_rot = p[0,0,0,fun_offrpy_rot[0],fun_offrpy_rot[1],fun_offrpy_rot[2]]
    fun_cal_p = pose_trans(fun_plane,pose_trans(fun_offset_p,fun_p_feature))
    fun_cal_rot = pose_trans(fun_plane,fun_offset_rot)
    result_cal = p[fun_cal_p[0],fun_cal_p[1],fun_cal_p[2],fun_cal_rot[3],fun_cal_rot[4],fun_cal_rot[5]]
    return result_cal
  end
  
  ## same as changing feature in Move command
  ## Set offset into Plane and move position by it
  def plane_offset(fun_pose,p_offset,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    fun_plane = pose_trans(fun_plane,p[p_offset[0],p_offset[1],p_offset[2],0,0,0])
    fun_p_result = pose_trans(pose_trans(fun_plane,p[0,0,0,p_offset[3],p_offset[4],p_offset[5]]),fun_p_feature)
    return fun_p_result
  end
  
  #  convert from rotation matrix to rotation vector
  ####
  def rotmat2rotvec(rotmat):
  
    # array to matrix
    r11 = rotmat[0]
    r21 = rotmat[1]
    r31 = rotmat[2]
    r12 = rotmat[3]
    r22 = rotmat[4]
    r32 = rotmat[5]
    r13 = rotmat[6]
    r23 = rotmat[7]
    r33 = rotmat[8]
  
    # rotation matrix to rotation vector
    theta = acos((r11+r22+r33-1)/2)
    sth = sin(theta)
  
    if ( (theta > d2r(179.99)) or (theta < d2r(-179.99)) ):
      theta = d2r(180)
      if (r21 < 0):
        if (r31 < 0):
          ux = sqrt((r11+1)/2)
          uy = -sqrt((r22+1)/2)
          uz = -sqrt((r33+1)/2)
        else:
          ux = sqrt((r11+1)/2)
          uy = -sqrt((r22+1)/2)
          uz = sqrt((r33+1)/2)
        end
      else:
        if (r31 < 0):
          ux = sqrt((r11+1)/2)
          uy = sqrt((r22+1)/2)
          uz = -sqrt((r33+1)/2)
        else:
          ux = sqrt((r11+1)/2)
          uy = sqrt((r22+1)/2)
          uz = sqrt((r33+1)/2)
        end
      end
    else:
      ux = (r32-r23)/(2*sth)
      uy = (r13-r31)/(2*sth)
      uz = (r21-r12)/(2*sth)
    end
  
    rotvec = [(theta*ux),(theta*uy),(theta*uz)]
  
    return rotvec
  end
  
  # cross product of two vectors u and v
  ####
  def cross_product(u, v):
  
    u1 = u[0]
    u2 = u[1]
    u3 = u[2]
    v1 = v[0]
    v2 = v[1]
    v3 = v[2]
  
    s = [ (u2*v3-u3*v2), (u3*v1-u1*v3), (u1*v2-u2*v1) ]
  
    return s
  end
  ####
  def get_feature_Line(p1, p2):
    p3 = pose_trans(p1,p[0,0,0.01,0,0,0])
    d1 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
    d2 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    dx = cross_product(d1, d2)
    temp = norm(d2)
    uy = [ d2[0]/temp, d2[1]/temp, d2[2]/temp ]
    temp = norm(dx)
    ux = [ dx[0]/temp, dx[1]/temp, dx[2]/temp ]
    uz = cross_product(ux, uy)
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
    rotvec = rotmat2rotvec(rotmat)
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def calculate_p(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=posDir
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  
  def direction(feature, direction, position_distance,fun_speed=50,fun_acc=100):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
  
    thread fun_thread_direction():
      enter_critical
  
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    move_thread_dirr2 = run fun_thread_direction()
    while (True):
      sleep(1.0E-10)
      if (move_flag > 1):
        kill move_thread_dirr2
        break
      end
      sync()
    end
  end
  
  def movej_elbwrist(j_p,fun_height=-0.02,fun_speed=0.5,fun_acc=0.5):
    global g_jp = j_p
    global g_ac = fun_speed
    global g_sp = fun_acc
    global move_flag = 0
    g_cp = get_actual_tcp_pose()
    if(g_cp[2]<fun_height):
      move_flag = 1
      return True
    end
    thread fun_thread_elbwirst():
      enter_critical
      move_flag = 1
      movej(g_jp, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    move_thread_direlb = run fun_thread_elbwirst()
    while(True):
      g_cp = get_actual_tcp_pose()
      sync()
      if (move_flag > 1 or g_cp[2]<fun_height):
        kill move_thread_direlb
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def movel_singu(t_p,fun_speed=0.2,fun_acc=0.4,hard_mode=False):
    global g_pp = t_p
    global g_ac = fun_speed
    global g_sp = fun_acc
    move_flag = 0
    singu_var = singularity(t_p,hard_mode)
    if(singu_var==True):
      move_flag = 1
      return True
    end
    thread fun_thread_movelsingu():
      enter_critical
      move_flag = 1
      movel(g_pp, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    move_thread_dirr = run fun_thread_movelsingu()
    while(True):
      sleep(1.0E-10)
      if (move_flag > 1 or singularity(get_actual_tcp_pose(),hard_mode)):
        kill move_thread_dirr
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def direction_singu(feature, direction, position_distance,fun_speed=50,fun_acc=100,hard_mode=False):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global stepsToRetract = 0
    singu_var = singularity(get_actual_tcp_pose(),hard_mode)
    if(singu_var==True):
      move_flag = 1
      return True
    end
    thread fun_thread_sing():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    thread_han_sing = run fun_thread_sing()
    while (True):
      sleep(1.0E-10)
      if (move_flag > 1 or singularity(get_actual_tcp_pose(),hard_mode)):
        kill thread_han_sing
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def motion_num(m_num = [0,0,0,0,0,0]):
    VL1_r = 1
    VL2_r = 2
    VR1_r = 4
    VR2_r = 8
    HOR_r = 16
    var_i = 0
    r_val = 0
    while(var_i<5):
      if(m_num[var_i] == 1):
        r_val = r_val + VL1_r
      elif(m_num[var_i] == 2):
        r_val = r_val + VL2_r
      elif(m_num[var_i] == 3):
        r_val = r_val + VR1_r
      elif(m_num[var_i] == 4):
        r_val = r_val + VR2_r
      elif(m_num[var_i] == 5):
        r_val = r_val + HOR_r
      end
      var_i = var_i + 1
    end
    return r_val
  end
  
  def touch_cal(Num_L,Num_R,Cell_Sel):
    #VL1:1, VL2:2, VR1:3, VR2:4, HOR:5, HOR_ML:6, HOR_R:7, HOR_MR:8, HOR_M:9 VL1_END:10, VL2_END:11, VR1_END:12, VR2_END:13, HOR_2path:14, HOR_3path:15, HOR_4path:16, HOR_2path_CD:17, HOR_3path_CD:18, HOR_4path_CD:19
    #A : 1, B : 2, C : 3, c : 4, D : 5, d :6, E : 7
    touch_check = [False,False,False,False,False,False,False,False,False,False,False]
    #touch_left, touch_left2
    global Cell_t = integer_to_binary_list(Cell_Sel)
    if(Cell_t[0]==True):
      #touch_left
      touch_check[1] = True
    end
    if(Cell_t[1]==True):
      #touch_left2
      touch_check[2] = True
    end
    if(Cell_t[2]==True):
      #touch_right
      touch_check[3] = True
    end
    if(Cell_t[3]==True):
      #touch_right2
      touch_check[4] = True
    end
  
    if(Cell_t[4]==True):
      #touch_hor is needed for checking
      #left A or B
      touch_check[5] = True
    end
  
    if(Cell_t[4]==True):
      #HOR_R:7
      #right
      touch_check[7] = True
    end
  
    if(Cell_t[4]==True and (Num_L == 3 or Num_L == 4 or Num_L == 5 or Num_L == 6)):
      #HOR_ML:6
      #left c,C,D,d
      touch_check[6] = True
    elif(Cell_t[4]==True and (Num_R == 3 or Num_R == 4 or Num_R == 5 or Num_R == 6)):
      #HOR_MR:8
      #right c,C,D,d
      touch_check[8] = True
    end
    return touch_check
  end
  
  def cpm2mms(cpm_speed):
    return cpm_speed / 6
  end
  
  def time_diff(until_num):
    global get_143 = read_port_register(143)
    get_144 = read_port_register(144)
    global get_time = time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,until_num)
    time_diff = get_143 - get_time
    get_144 = get_144 + time_diff
    # write_port_register(144,get_144)
    return get_144
  end
  
  def time_cal(scenario_l,t_num,speed_l,distance_l,touch_l,until_num=0):
    VL1 = 1
    VL2 = 2
    VR1 = 3
    VR2 = 4
    HOR = 5
    HOR_ML = 6
    HOR_R = 7
    HOR_MR = 8
    HOR_M = 9
    w_time = 0
    t_count = 0
  
    if(until_num == 0):
      f_num = t_num
    else:
      f_num = until_num
    end
  
    while(t_count<f_num):
      c_scenario = scenario_l[t_count]
      if(c_scenario==VL1 or c_scenario==VL2 or c_scenario==VR1 or c_scenario==VR2):
        if(touch_l[c_scenario+9]==p[0,0,0,0,0,0]):
          w_time = w_time + distance_l[c_scenario]/cpm2mms(speed_l[c_scenario])
          w_time = w_time + 1.5
          # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
        else:
          w_time = w_time + point_dist(touch_l[c_scenario],touch_l[c_scenario+9])*1000/cpm2mms(speed_l[c_scenario])
          w_time = w_time + 1.5
          # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
        end
      else:
        w_time = w_time + point_dist(touch_l[HOR],touch_l[HOR_R])*1000/cpm2mms(speed_l[HOR])
        w_time = w_time + 1.5
        # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
      end
      t_count = t_count+1
    end
    return floor(w_time)
  end
  
  # 각 셀의 터치 위치를 바탕으로 내가 이번에 실행할 셀을 순서에 맞게 반환한다.
  # 예시 : value =[1,3] -> VL1, VR1 순서로 실행한다.
  def cell_motion(Touch_Sel,thickness_2f,ext_flag_pend,cell_info_l,cell_info_r):
    ex = 0
    num_2f = 0
    global return_pose = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    val_sum = 0
    VL1 = 1
    VL2 = 2
    VR1 = 3
    VR2 = 4
    HOR = 5
    HOR_ML = 6
    HOR_R = 7
    HOR_MR = 8
    HOR_M = 9
    HOR_2path = 14
    HOR_3path = 15
    HOR_4path = 16
    HOR_2path_CD = 17
    HOR_3path_CD = 18
    HOR_4path_CD = 19
    CD_check = 0
    Cell_l = Touch_Sel
    cell_c = 4
    cell_d = 6
  
    # 분할 X
    HOR_1 = 30
    # 분할 Left
    HOR_2_L = 31
    # 분할 Right
    HOR_2_R = 32
  
    # 분할 X, 2 Path
    HOR_1_2P = 40
    HOR_2_L_2P = 41
    HOR_2_R_2P = 42
  
    # 분할 X, 3 Path
    HOR_1_3P = 50
    HOR_2_R_3P = 52
    HOR_2_L_3P = 51
  
    # 분할 X, 3 Path
    HOR_1_4P = 60
    HOR_2_L_4P = 61
    HOR_2_R_4P = 62
    # EXT 4 이음, EXT 6 분할
    # 이음 O , 분할 X
    HOR_1_CD = 100
    # 이음 O, 분할 O (101 + 104)
    HOR_2_CD_connect = 101
    # 이음 X/O, 분할 O
    HOR_3_CD_left = 102
    # 이음 X, 분할 O (102 + 103 + 104)
    HOR_3_CD_middle = 103
    # 이음 X/O, 분할 O
    HOR_23_CD_right = 104
    # 이음 X, 분할 X (102 + 105)
    HOR_2_CD_midr = 105
  
    HOR_1_CD_2P = 110
    HOR_2_CD_connect_2P = 111
    HOR_3_CD_left_2P = 112
    HOR_3_CD_middle_2P = 113
    HOR_23_CD_right_2P = 114
    HOR_2_CD_midr_2P = 115
  
    HOR_1_CD_3P = 120
    HOR_2_CD_connect_3P = 121
    HOR_3_CD_left_3P = 122
    HOR_3_CD_middle_3P = 123
    HOR_23_CD_right_3P = 124
    HOR_2_CD_midr_3P = 125
  
    HOR_1_CD_4P = 130
    HOR_2_CD_connect_4P = 131
    HOR_3_CD_left_4P = 132
    HOR_3_CD_middle_4P = 133
    HOR_23_CD_right_4P = 134
    HOR_2_CD_midr_4P = 135
  
    RHOR_1_CD = 150
    RHOR_2_CD_connect = 151
    RHOR_3_CD_left = 152
    RHOR_3_CD_middle = 153
    RHOR_23_CD_right = 154
    RHOR_2_CD_midr = 155
  
    RHOR_1_CD_2P = 160
    RHOR_2_CD_connect_2P = 161
    RHOR_3_CD_left_2P = 162
    RHOR_3_CD_middle_2P = 163
    RHOR_23_CD_right_2P = 164
    RHOR_2_CD_midr_2P = 165
  
    RHOR_1_CD_3P = 170
    RHOR_2_CD_connect_3P = 171
    RHOR_3_CD_left_3P = 172
    RHOR_3_CD_middle_3P = 173
    RHOR_23_CD_right_3P = 174
    RHOR_2_CD_midr_3P = 175
  
    RHOR_1_CD_4P = 180
    RHOR_2_CD_connect_4P = 181
    RHOR_3_CD_left_4P = 182
    RHOR_3_CD_middle_4P = 183
    RHOR_23_CD_right_4P = 184
    RHOR_2_CD_midr_4P = 185
  
    l_var = 0
    l_counter=1
    multi_path_n = 10
    if(thickness_2f >=11):
      l_counter = 4
    elif(thickness_2f >=9):
      l_counter = 3
    elif(thickness_2f >=7):
      l_counter = 2
    end
  
    if(Cell_l[VL2]==True):
      return_pose[ex] = VL2
      ex = ex + 1
    end
    if(Cell_l[VR2]==True):
      return_pose[ex] = VR2
      ex = ex + 1
    end
  
    if(Cell_l[HOR_ML]==True or Cell_l[HOR_MR]==True ):
      if(Cell_l[HOR_MR]==True):
        MLMR = 50
      else:
        MLMR = 0
      end
      # ext 4 => 이음, ext 6 = > 분할
      while(l_var<l_counter):
        if(ext_flag_pend[4]==True and (cell_info_l!=cell_c and cell_info_l !=cell_d and cell_info_r!=cell_c and cell_info_r !=cell_d)):
          if(ext_flag_pend[6]==True):
            return_pose[ex] = HOR_2_CD_connect + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_23_CD_right + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          else:
            return_pose[ex] = HOR_1_CD + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          end
        else:
          if(ext_flag_pend[6]==True):
            return_pose[ex] = HOR_3_CD_left + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_3_CD_middle + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_23_CD_right + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          else:
            return_pose[ex] = HOR_3_CD_left + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_2_CD_midr + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          end
        end
        l_var = l_var + 1
      end
    elif(Cell_l[HOR]==True):
      while(l_var<l_counter):
        if(ext_flag_pend[6]==True):
          return_pose[ex] = HOR_2_L + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
          return_pose[ex] = HOR_2_R + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
        else:
          return_pose[ex] = HOR_1 + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
        end
        l_var = l_var + 1
      end
    end
    write_port_register(140,num_2f)
  
    if(Cell_l[VL1]==True):
      return_pose[ex] = VL1
      ex = ex + 1
    end
    if(Cell_l[VR1]==True):
      return_pose[ex] = VR1
      ex = ex + 1
    end
    return return_pose
  end
  
  def cell_num(Num):
    var_i = 0
    while(var_i<14):
      if(Num[var_i] == 0):
        return var_i
      else:
        var_i = var_i+1
      end
    end
    return var_i
  end
  
  def singularity_inner(target_pose):
    global angle_margin=4
    global inner_UR3e=0.18
    global outer_UR3e=0.45
    global cj= get_actual_joint_positions()
    global cp=get_actual_tool_flange_pose()
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1])
    if (distance_tool<inner_UR3e):
      global msg="inner singularity"
      return True
    end
    return False
  end
  #singularity check
  
  def singularity(target_pose,hard_mode=False):
    if(hard_mode):
      global angle_margin=15
      global inner_UR3e=0.215
      global outer_UR3e=0.5
    else:
      global angle_margin=8
      global inner_UR3e=0.18
      global outer_UR3e=0.56
    end
    global cj= get_actual_joint_positions()
    global cp=get_actual_tool_flange_pose()
    if (r2d(cj[4])>-angle_margin  and  r2d(cj[4]) <= angle_margin):
      global msg="wirst singularity"
      return True
    else:
      if (r2d(cj[4])>-angle_margin+180  and  r2d(cj[4])<angle_margin+180):
        global msg="wirst singularity"
        return True
      end
    end
  
    if (r2d(cj[2])>-angle_margin  and  r2d(cj[2]) <= angle_margin):
      global msg="wirst singularity2"
      return True
    end
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1])
    if (distance_tool<inner_UR3e):
      global msg="inner singularity"
      return True
    end
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1]+cp[2]*cp[2])
    if (distance_tool>outer_UR3e):
      global msg="outer singularity"
      return True
    end
    return False
  end
  #
  
  def contact_fun(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    if(isTouchWCR):
      get_contact_p = contact_fun_wcr(feature,direction,position_distance,fun_speed,fun_acc,back_trig,back_dis,sens)
    else:
      get_contact_p = contact_fun_sens(feature,direction,position_distance,fun_speed,fun_acc,back_trig,back_dis,sens)
    end
    return get_contact_p
  end
  
  right_pre_up = [-0.16877919832338506, -0.9831331411944788, -0.8493865172015589, -2.161825958882467, 1.3512022495269775, 1.6723911762237549]
  right_pre_up_p = p[.386895294397, -.308282159155, .411715365657, 1.998643885654, -.290286543852, 1.940165464353]
  right_prep_p = p[.373961727367, -.250422494173, .116476702370, 2.461513812909, -.399817711504, 1.518894068038]
  right_prep = [-0.04209882417787725, -0.8477118651019495, -1.5379555861102503, -2.060195271168844, 1.4439871311187744, 1.8594372272491455]
  left_pre_up = [1.1051501035690308, -1.1542351881610315, -0.8232358137713831, -2.0545104185687464, 1.5833461284637451, 1.8991502523422241]
  left_pre_up_p = p[.380642855235, .363570349938, .382293242723, -1.811667697664, -.627117964573, -1.490809660446]
  left_prep_p = p[.399,.315,.115,-2.0120344559633447,-1.0104257712451312,-1.445571191773495]
  left_prep = [1.071582555770874, -0.8307450453387659, -1.8299058119403284, -1.661370102559225, 1.4603912830352783, 1.720375657081604]
  
  def check_speed():
    global act_speed = get_actual_tcp_speed()
    var_i = 0
    while(var_i <5):
      if(act_speed[var_i] >= 2.5):
        write_port_register(142,113)
        halt
      end
      var_i = var_i + 1
    end
  end
  
  def home_ym(limit_p):
    get_po = pose_trans(get_actual_tcp_pose(),p[0,0,0,0,d2r(-10),0])
    global get_sing6 = singularity(get_po,hard_mode=True)
    if(get_sing6==False):
      current_tcp = get_tcp_offset()
      set_tcp(p[0,0,0,current_tcp[3],current_tcp[4],current_tcp[5]])
      get_po = pose_trans(get_actual_tcp_pose(),p[0,0,0,0,d2r(-10),0])
      ta_j = get_inverse_kin(get_po)
      home_movej2(ta_j,limit_p)
      set_tcp(current_tcp)
    end
  end
  
  def home_movej2(target_j,limit_p,speed_j=0):
    current_j = get_actual_joint_positions()
    global diff_po_x = [0,0,0,0,0,0]
    global diff_po_y = [0,0,0,0,0,0]
    global alimit_p2 = limit_p
    if(alimit_p2[0]>0.40):
      alimit_p2[0] = alimit_p2[0] + 0.003
      global spd_j = 65
    else:
      alimit_p2[0]=0.40
      global spd_j = 80
    end
    if(speed_j>0):
      global spd_j=speed_j
    end
  
    while(not(is_steady())):
      sync()
    end
    alimit_p2[1] = norm(alimit_p2[1]) + 0.003
    alimit_p2[2] = alimit_p2[2] + 0.003
  
    global dist_j = pose_dist(get_forward_kin(target_j),get_actual_tcp_pose())
    global time_j = (dist_j*1000) / spd_j
  
    if(dist_j*1000<100):
      time_j = time_j+1
    end
    global delta_t = time_j*1000/20
    global delta_a = 0
    global t_c = [r2d(current_j[0]),r2d(current_j[1]),r2d(current_j[2]),r2d(current_j[3]),r2d(current_j[4]),r2d(current_j[5])]
    global t_c_org = t_c
    global t_j = [(r2d(target_j[0])-t_c[0]),(r2d(target_j[1])-t_c[1]),(r2d(target_j[2])-t_c[2]),(r2d(target_j[3])-t_c[3]),(r2d(target_j[4])-t_c[4]),(r2d(target_j[5])-t_c[5])]
    arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
    global arrive_p = get_forward_kin(arrive_j)
    global l_j = [1,1,1,1,1,1]
    second_t = True
  
    while(delta_a<delta_t and l_j != [0,0,0,0,0,0] ):
      l_j = [1,1,1,1,1,1]
      var_i = 0
      # if(delta_a%15==0):
      #   global g_cp = get_actual_tcp_pose()
      #   if(alimit_p2[0]>g_cp[0]):
      #     alimit_p2[0]=g_cp[0] + 0.001
      #   end
      #   if(norm(alimit_p2[1])>norm(g_cp[1])):
      #     alimit_p2[1]=norm(g_cp[1]) + 0.001
      #   end
      # end
      if(delta_a==100 and second_t == True):
        current_j = get_actual_joint_positions()
        dist_j = pose_dist(get_forward_kin(target_j),get_actual_tcp_pose())
        time_j = (dist_j*1000) / spd_j
        delta_t = time_j*1000/20
        delta_a = 0
        t_c = [r2d(current_j[0]),r2d(current_j[1]),r2d(current_j[2]),r2d(current_j[3]),r2d(current_j[4]),r2d(current_j[5])]
        t_j = [(r2d(target_j[0])-t_c[0]),(r2d(target_j[1])-t_c[1]),(r2d(target_j[2])-t_c[2]),(r2d(target_j[3])-t_c[3]),(r2d(target_j[4])-t_c[4]),(r2d(target_j[5])-t_c[5])]
        second_t = False
        global g_cp = get_actual_tcp_pose()
        if(alimit_p2[0]>g_cp[0]):
          alimit_p2[0]=g_cp[0] + 0.003
        end
      end
      while(var_i<6):
        b_p = arrive_p
        t_c[var_i] = t_c[var_i] + (t_j[var_i] * 1/delta_t) * l_j[var_i]
        arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
        arrive_p = get_forward_kin(arrive_j)
        diff_po = pose_sub (arrive_p,b_p)
        diff_po_x[var_i] = diff_po[0]
        diff_po_y[var_i] = diff_po[1]
        if(alimit_p2[0]<arrive_p[0] or alimit_p2[1]<norm(arrive_p[1]) or alimit_p2[2]<arrive_p[2] or 0/1000>arrive_p[2] or (second_t == True and delta_a<100 and diff_po[0]>0.0005)):
          t_c[var_i] = t_c[var_i] - (t_j[var_i] * 1/delta_t) * l_j[var_i]
          l_j[var_i] = 0
        elif(delta_t>100 and arrive_p[0]<0.38 and norm(arrive_p[1])<0.3):
          t_c[var_i] = t_c[var_i] + (t_j[var_i] * 1/(delta_t*3)) * l_j[var_i]
        end
        if(t_j[var_i]<0 and t_c[var_i]<r2d(target_j[var_i])):
          t_c[var_i] = t_j[var_i]
        elif(t_j[var_i]>0 and t_c[var_i]>r2d(target_j[var_i])):
          t_c[var_i] = t_j[var_i]
        end
        var_i = var_i+1
      end
      arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
  
  
      if(l_j!=[0,0,0,0,0,0]):
        servoj(arrive_j,0,0,0.02,0.12,250)
      end
      delta_a = delta_a + 1
  
      write_output_float_register(24,delta_a)
      write_output_float_register(25,ceil(delta_t))
      sync()
    end
    stopj(2)
    if(l_j==[0,0,0,0,0,0]):
      return False
    else:
      return True
    end
  end
  
  
  def home_tilt_move():
    global g_cp = get_actual_tcp_pose()
    global g_tp = g_cp
    spd_j = 20
    g_tp[0] = g_tp[0] - 0.02
    if(g_tp[1]>0):
      g_tp[1] = g_tp[1] - 0.02
    else:
      g_tp[1] = g_tp[1] + 0.02
    end
    g_tp[2] = 0.1
    c_p = g_cp
    global dist_j = pose_dist(g_tp,g_cp)
    global time_j = (dist_j*1000) / spd_j
    global delta_t = time_j*1000/100
    global delta_a = 0
    global alpha_home = 0
  
    global get_angle_ry = welding_angle_cal_3f(g_tp[2],last_tilt_deg,last_z_bottom,1)
    T_angle = feature_offset(last_wv_wp1,p[0,0,0,d2r(last_tilt_deg[0]),d2r(last_tilt_deg[1] + get_angle_ry),d2r(last_tilt_deg[2])],last_wv_line)
    target_p = p[g_tp[0],g_tp[1],g_tp[2],T_angle[3],T_angle[4],T_angle[5]]
    movel(target_p,a=0.3,v=0.3)
    # while(delta_a<delta_t and c_p[2]>0.1):
    #   c_p = interpolate_pose(g_cp,g_tp,delta_a)
    #   global get_angle_ry = welding_angle_cal_3f(c_p[2],last_tilt_deg,last_z_bottom,1)
    #   T_angle = feature_offset(last_wv_wp1,p[0,0,0,d2r(last_tilt_deg[0]),d2r(last_tilt_deg[1] + get_angle_ry),d2r(last_tilt_deg[2])],last_wv_line)
    #   target_p = p[c_p[0],c_p[1],c_p[2],T_angle[3],T_angle[4],T_angle[5]]
    #   movel(target_p,a=0.3,v=0.3,t=0,r=0.01)
    #   delta_a = delta_a+1/delta_t
    # end
  end
  
  
  right_pre_up_p = p[.390, -.400, .364, 1.706218729081, -.485442454510, 1.936533727181]
  right_prep_p = p[.389, -.355, .115, 2.246845828470, -.464326210139, 1.439227744219]
  right_prep = [-0.023312870656148732, -0.8396714369403284, -1.6292946974383753, -1.993622128163473, 1.251758337020874, 2.0052530765533447]
  
  left_pre_up_p = p[.390, .351, .311, -1.898095786869, -.909216130442, -1.499352502127]
  left_prep_p = p[.389,.315,.115,-2.0120344559633447,-1.0104257712451312,-1.445571191773495]
  left_prep = [1.071582555770874, -0.8307450453387659, -1.8299058119403284, -1.661370102559225, 1.4603912830352783, 1.720375657081604]
  
  
  def homeing(home_pos = get_inverse_kin(first_p_wp,qnear = home_pos_j),robot_dist=CELL_ROBOT_DIST,robot_width = CELL_WIDTH,robot_height=-50):
    current_jp = get_actual_joint_positions()
    global current_cp = get_actual_tcp_pose()
    global limit_p = current_cp
  
    global home_step = 0
  
    # X - FRONT, BACK
    if(current_cp[0]>0.05):
      #FRONT
      pos_dir_x=-1
    elif(current_cp[0]<-0.05):
      #BACK
      pos_dir_x=1
    else:
      pos_dir_x=0
    end
  
    if(current_cp[1]>0.05):
      #LEFT
      global pos_dir=-1
    elif(current_cp[1]<-0.05):
      #RIGHT
      global pos_dir=1
    else:
      global pos_dir=0
    end
  
    if ( pose_dist ( current_cp, Packing_pos_wp)<0.07):
      home_step = 1
      write_output_float_register(23,home_step)
      movej(home_pos,a=0.3,v=0.3)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
    if ( pose_dist ( current_cp, first_p_wp)<0.06):
      home_step = 2
      write_output_float_register(23,home_step)
  
      movej(home_pos,a=0.45,v=0.45)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
    if ( pose_dist ( current_cp, mounting_wp)<0.02):
      home_step = 3
      write_output_float_register(23,home_step)
      movej(pre_mounting_wp, a=0.45, v=0.45)
      movej(home_pos,a=0.45,v=0.45)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
  
    global dist_lastcp = point_dist(current_cp,last_pose)
    if ( current_cp[2] > 150/1000 and dist_lastcp<0.025 and last_tilt_deg != [0,0,0] and last_wv_wp1 != p[0,0,0,0,0,0] and last_wv_line != p[0,0,0,0,0,0] and last_z_bottom != 0):
      home_step=4
      home_tilt_move()
      if (pos_dir == 1 and current_cp[1]<-0.355):
          home_step=5
          movej(right_prep_p, a=0.5, v=0.5)
          movej(home_pos,a=0.5,v=0.5)
          return True
      elif (pos_dir == -1 and current_cp[1]>0.315):
          home_step=6
          movej(left_prep_p, a=0.5, v=0.5)
          movej(home_pos,a=0.5,v=0.5)
          return True
      end
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
    end
  
    if ( norm(current_cp[0]) > 380/1000):
      home_step = 15
      m_dis = 35
      if ((norm(current_cp[0])-(20/1000)>(400)/1000) and (norm(current_cp[1])-norm(20/1000)>(350)/1000)):
        m_dis = m_dis + 35
      end
      get_sing = singularity(get_actual_tcp_pose(),hard_mode=True)
      if(pos_dir==-1 and get_sing==False):
        write_output_float_register(23,home_step)
        sing_dir = direction_singu(p[0,0,0,0,0,0],[-1,-0.5,0],m_dis,30,30,hard_mode=True)
        current_cp = get_actual_tcp_pose()
        current_jp = get_actual_joint_positions()
        limit_p[0] = current_cp[0]
        limit_p[1] = current_cp[1]
      elif(pos_dir==1 and get_sing==False):
        write_output_float_register(23,home_step)
        global sing_dir = direction_singu(p[0,0,0,0,0,0],[-1,0.5,0],m_dis,30,30,hard_mode=True)
        current_cp = get_actual_tcp_pose()
        current_jp = get_actual_joint_positions()
        limit_p[0] = current_cp[0]
        limit_p[1] = current_cp[1]
      end
    end
  
    if (pos_dir == 1):
      home_step=7
      if(current_cp[2]>0.364):
        movej(right_pre_up, a=0.5, v=0.5)
        current_cp = get_actual_tcp_pose()
      end
      if (current_cp[1]<-0.355):
        home_step=8
        movej(right_prep_p, a=0.5, v=0.5)
        movej(home_pos,a=0.5,v=0.5)
        return True
      end
    elif (pos_dir == -1 and current_cp[2]>0.311):
      home_step=9
      if(current_cp[2]>0.311):
        movej(left_pre_up, a=0.5, v=0.5)
        current_cp = get_actual_tcp_pose()
      end
      if (current_cp[1]>0.315):
        home_step=10
        movej(left_prep_p, a=0.5, v=0.5)
        movej(home_pos,a=0.5,v=0.5)
        return True
      end
    end
  
    home_step=11
    write_output_float_register(23,home_step)
    movej(home_pos, a=0.7, v=0.7)
    home_step=0
  
    last_pose = p[0,0,0,0,0,0]
    last_wv_wp1 = p[0,0,0,0,0,0]
    last_wv_line = p[0,0,0,0,0,0]
    last_tilt_deg = [0,0,0]
  end
  
  def contact_fun_sens(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global force_T = p[0,0,0,0,0,0]
    global force_T_all = force()
    global contact_back_p = p[0,0,0,0,0,0]
    global touch_begin = get_actual_tcp_pose()
    global contact_trig = False
  
    thread fun_thread_contact():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    thread tool_contact_thread():
      while(True):
        global force_torque = get_tcp_force()
        force_B = p[ force_torque[0], force_torque[1], force_torque[2], 0, 0, 0 ]
        torque_B = p[ force_torque[3], force_torque[4], force_torque[5], 0, 0, 0 ]
        tcp = get_actual_tcp_pose()
        rotation_BT = p[ 0, 0, 0, tcp[3], tcp[4], tcp[5] ]
        if(norm(force_T[2])>4):
          global contact_back_p = get_actual_tcp_pose()
          contact_trig = True
        else:
          contact_trig = False
        end
        force_T = pose_trans( pose_inv(rotation_BT), force_B )
        torque_T = pose_trans( pose_inv(rotation_BT), torque_B )
        force_torque_T = p[ force_T[0], force_T[1], force_T[2], torque_T[0], torque_T[1], torque_T[2] ]
        sync()
      end
    end
    while(is_steady()==False):
      sync()
    end
    zero_ftsensor()
    move_thread_han5 = run fun_thread_contact()
    contact_thread_han5 = run tool_contact_thread()
  
    while (True):
      if (norm(force_T[2]) > sens and contact_back_p != p[0,0,0,0,0,0]):
        kill move_thread_han5
        kill contact_thread_han5
        global get_contact_p = get_actual_tcp_pose()
        stopl(3.0)
        if (back_trig==True):
          contact_back_p = feature_offset(contact_back_p,p[g_d[0]*back_dis/1000,g_d[1]*back_dis/1000,g_d[2]*back_dis/1000,0,0,0],feature)
          movel(contact_back_p, a=3, v=0.1)
        end
        break
      end
      if (point_dist(touch_begin,contact_back_p)>0.15 and contact_back_p != p[0,0,0,0,0,0]):
        write_port_register(142,121)
        halt
      end
      sync()
    end
    return contact_back_p
  end
  
  def contact_fun_wcr(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global contact_back_p = p[0,0,0,0,0,0]
    global contact_trig = False
    global touch_begin = get_actual_tcp_pose()
  
    thread fun_thread_contactw():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    write_welder(4,True)
    write_port_register(211,0)
    sleep(0.05)
    get_stick = read_welder(4)
    sleep(0.05)
    move_thread_hanw = run fun_thread_contactw()
    while (True):
      global contact_back_p = get_actual_tcp_pose()
      global get_stick = read_welder(4)
      global get_stick_out = read_welder_control(4)
      if(get_stick_out==False):
        write_welder(4,True)
      end
      if(isHicomm):
        touch_onoff=read_welder(4)
      else:
        touch_onoff = get_standard_digital_in(1)
      end
      if (touch_onoff):
        kill move_thread_hanw
        stopj(8.0)
        if (back_trig==True):
          back_p = feature_offset(get_actual_tcp_pose(),p[g_d[0]*back_dis/1000,g_d[1]*back_dis/1000,g_d[2]*back_dis/1000,0,0,0],feature)
          movel(back_p, a=0.05, v=0.02)
        end
        break
      end
      if (point_dist(touch_begin,contact_back_p)>0.15 and contact_back_p != p[0,0,0,0,0,0]):
        write_port_register(142,121)
        halt
      end
      sync()
    end
    return contact_back_p
  end
  
  def get_lr(get_pose,get_width,get_cell,get_distance=600,left_par2=True,par_2f=False,touch_dis=30,margin_z=30,side_touch=0,callar=0,par_cell=0,cent_line=p[0,0,0,0,0,0],angle_c=False):
    margin_dis_3f = 30
    margin_dis_y = 30
    margin_dis_z = 55
    get_distance = get_distance
  
    if((par_cell==4 or par_cell==6) and callar > 1):
      margin_dis_3f = -50
    else:
      margin_dis_3f = 20
    end
  
    if((par_cell==1 or par_cell==3 or par_cell==4) and par_2f==False):
      touch_dis = 0
    elif((par_cell==2 or par_cell==5 or par_cell==6 or par_cell==7 or par_cell==8) and par_2f==False):
      margin_z = 0
    end
  
  
    if(par_cell==3 or par_cell==5 or par_cell==7 or par_cell==8):
      margin_cal = 35
    else:
      margin_cal = 0
    end
    if((par_cell==5 or par_cell==6) and callar > 1):
      get_cell[1] = 0
      get_cell[2] = 0
    end
    global AAA11 = touch_dis
    global AAA22 =get_cell[1]
    global AAA33 =get_cell[0]
    global AAA44 =margin_z
  
    if(par_2f==False):
      #3F
      if(left_par2):
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,(get_width/2-margin_dis_3f+side_touch-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      else:
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,-(get_width/2-margin_dis_3f-side_touch-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      end
      if(angle_c==False):
        return_v = feature_offset(return_v,p[0,0,0,0,d2r((((return_v[2]-30/1000)*1000) / 600) * 5),0],return_v)
      end
      return return_v
    else:
      #2F
      if(left_par2):## margin_dis_z -> get_width[1] up, down margin_dis_z -> get_width[2]
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,(-get_cell[1]+(get_width/2)-touch_dis+side_touch-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,0,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,(-get_cell[1]+(get_width/2)-touch_dis+side_touch-callar)/1000,0,0,0,0],cent_line)
        end
      else:
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,-(-get_cell[2]+(get_width/2)-touch_dis-side_touch-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,0,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,-(-get_cell[2]+(get_width/2)-touch_dis-side_touch-callar)/1000,0,0,0,0],cent_line)
        end
      end
      if(angle_c==False):
        r_v = pose_trans(return_v,p[0,0,0,0,0,d2r(-90)])
        return_v = feature_offset(return_v,p[0,0,0,d2r((return_v[1]*1000 / 500)*0.25) * 25,0,0],r_v)
      end
      return return_v
    end
  end
  
  def side_apply(apply_p,cent_line,side_touch):
    offset_v = p[0,side_touch/1000,0,0,0,0]
    if(cent_line==p[0,0,0,0,0,0]):
      return_v = pose_add(apply_p,offset_v)
    else:
      return_v = feature_offset(apply_p,offset_v,cent_line)
    end
    return return_v
  end
  
  def touch_angle_2f(left_dir = True,angle_get_up = [0,0,0],angle_get_down = [0,0,0]):
    if(left_dir):
      if(angle_get_up == [0,0,0]):
        touch_angle_rpy_2f_up = [-180,-55,30]
        touch_angle_rpy_2f_down = [-180,-50,30]
      else:
        touch_angle_rpy_2f_up = angle_get_up
        touch_angle_rpy_2f_down = angle_get_down
      end
      touch_angle_rot_2f_up = rpy2rotvec([d2r(touch_angle_rpy_2f_up[0]),d2r(touch_angle_rpy_2f_up[1]),d2r(touch_angle_rpy_2f_up[2])])
      touch_angle_rot_2f_down = rpy2rotvec([d2r(touch_angle_rpy_2f_down[0]),d2r(touch_angle_rpy_2f_down[1]),d2r(touch_angle_rpy_2f_down[2])])
    else:
      if(angle_get_down == [0,0,0]):
        touch_angle_rpy_2f_up = [-180,-55,-30]
        touch_angle_rpy_2f_down = [-180,-50,-30]
      else:
        touch_angle_rpy_2f_up = angle_get_up
        touch_angle_rpy_2f_down = angle_get_down
      end
      touch_angle_rot_2f_up = rpy2rotvec([d2r(touch_angle_rpy_2f_up[0]),d2r(touch_angle_rpy_2f_up[1]),d2r(touch_angle_rpy_2f_up[2])])
      touch_angle_rot_2f_down = rpy2rotvec([d2r(touch_angle_rpy_2f_down[0]),d2r(touch_angle_rpy_2f_down[1]),d2r(touch_angle_rpy_2f_down[2])])
    end
  
    touch_angle_rot = [touch_angle_rot_2f_up[0],touch_angle_rot_2f_up[1],touch_angle_rot_2f_up[2],touch_angle_rot_2f_down[0],touch_angle_rot_2f_down[1],touch_angle_rot_2f_down[2]]
    return touch_angle_rot
  end
  
  #degree ,modify
  def touch_fun_2f(start_pose,start_pose_2,left_dir = True,touch_sens=2,bottom_pose=p[0,0,0,0,0,0]):
    x_dis = 20
    next_distance = 20
  
    get_touch_angle = touch_angle_2f(left_dir)
    start_pose_2 = p[start_pose[0],start_pose[1],start_pose[2],start_pose[3],start_pose[4],start_pose[5]]
  
    if(left_dir):
      l_dir = -1
    else:
      l_dir = +1
    end
    while(not(is_steady())):
      sync()
    end
    write_port_register(211,0)
    get_stick = read_welder(4)
    if(get_stick==False):
      write_welder(4,True)
    end
    sleep(0.1)
    global get_y_1=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-0.5,0,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[0,0,-1],x_dis,180,200)
    global get_y_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-1,0,0],next_distance,180,200)
  
    g_cp = get_actual_tcp_pose()
    g_cp = p[g_cp[0],g_cp[1],g_cp[2],start_pose_2[3],start_pose_2[4],start_pose_2[5]]
    movel(g_cp,a= 0.8,v=0.4)
  
    global get_z_2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0,0.5],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[-1,0,0],x_dis,180,200)
    global get_z_1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0,1],30,180,200)
    write_welder(4,False)
  
    result_p = touch_4p_get_middle(get_z_1,get_z_2,get_y_1,get_y_2,left_dir,bottom_pose,True)
  
    return result_p
  end
  
  def touch_fun2(start_pose,left_dir = True,touch_sens=2,par_CD=0,bottom_pose=p[0,0,0,0,0,0]):
    for_cd = 1
    if(par_CD==1):
      x_dis = 2.2
      next_distance = 5.5
      for_cd = 4
    else:
      x_dis = 20
      next_distance = 20
    end
    if(left_dir):
      l_dir = -1
    else:
      l_dir = +1
    end
    while(not(is_steady())):
      sync()
    end
    write_port_register(211,0)
    get_stick = read_welder(4)
    if(get_stick==False):
      write_welder(4,True)
    end
    sleep(0.1)
    get_y_1=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-0.5*for_cd,0,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[0,1 * l_dir*for_cd,0],x_dis,180,200)
    get_y_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-1,0,0],next_distance,180,200)
  
    get_z_2=contact_fun(p[0,0,0,0,0,0],[0,-1 * l_dir,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0.5 * l_dir*for_cd,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[-1,0,0],x_dis,180,200)
    get_z_1=contact_fun(p[0,0,0,0,0,0],[0,-1 * l_dir,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,1 * l_dir,0],x_dis,180,200)
    write_welder(4,False)
  
    if(left_dir):
      result_p = touch_4p_get_middle(get_y_2,get_y_1,get_z_1,get_z_2,left_dir,bottom_pose)
    else:
      result_p = touch_4p_get_middle(get_z_1,get_z_2,get_y_2,get_y_1,left_dir,bottom_pose)
    end
  
    return result_p
  end
  
  def touch_4point(get_wpx1,get_wpx2,get_wpy1):
    get_wpx2[2] = get_wpx1[2]
    get_wpy1[2] = get_wpx1[2]
    global feature_right2left = get_feature_Line(get_wpx1,get_wpx2)
  
    a_p1 = get_wpx1
    a_p2 = feature_offset(get_wpx1,p[0,0.02,0,0,0,0],feature_right2left)
    a_p3 = pose_add(get_wpx1,p[0,0,0.02,0,0,0])
    global plane_p = get_feature_plane_xz(a_p1,a_p2,a_p3)
  
    global get_r1 = get_feature_pose(get_wpy1,plane_p)
    global cent_p = feature_offset(plane_p,p[get_r1[0],0,0,0,0,0] ,plane_p)
  
    return cent_p
  end
  
  def touch_xyz_get_middle(get_wpx1,get_wpx2,get_wpy1,get_wpz1):
    get_wpx1[2] = get_wpz1[2]
    get_wpx2[2] = get_wpz1[2]
    get_wpy1[2] = get_wpz1[2]
  
    global feature_right2left = get_feature_Line(get_wpx1,get_wpx2)
  
    a_p1 = get_wpx1
    a_p2 = feature_offset(get_wpx1,p[0,0.02,0,0,0,0],feature_right2left)
    a_p3 = pose_add(get_wpx1,p[0,0,0.02,0,0,0])
    global plane_p = get_feature_plane_xz(a_p1,a_p2,a_p3)
  
    get_r1 = get_feature_pose(get_wpy1,plane_p)
    cent_p = feature_offset(plane_p,p[get_r1[0],0,0,0,0,0] ,plane_p)
  
    get_r_o = feature_offset(cent_p,p[-0.02,0,0,0,0,0],plane_p)
    get_l_o = feature_offset(cent_p,p[0,0.02,0,0,0,0],plane_p)
  
    middle_lr = interpolate_pose(get_r_o,get_l_o,0.2)
    cent_p[2] = middle_lr[2]
  
    plane_test = get_feature_plane_yz(middle_lr,get_l_o,cent_p)
    # global yy_dir = get_feature_Line(middle_lr,get_l_o)
    global zz_dir = get_feature_Line(cent_p,middle_lr)
  
    g_x_dir = pose_add(middle_lr,p[0,0,0.02,0,0,0])
    # g_y_dir = feature_offset(middle_lr,p[0,0.02,0,0,0,0],plane_test)
    # g_y_dir = feature_offset(middle_lr,p[0,-0.02,0,0,0,0],yy_dir)
  
    # g_z_dir = feature_offset(middle_lr,p[0,0,0.02,0,0,0],plane_test)
    g_z_dir = feature_offset(middle_lr,p[0,-0.02,0,0,0,0],zz_dir)
  
    g_z_dir = p[g_z_dir[0],g_z_dir[1],g_z_dir[2],get_wpx1[3],get_wpx1[4],get_wpx1[5]]
  
    # global final_feature = get_feature_plane_yz(middle_lr,g_y_dir,g_z_dir)
    global final_feature = get_feature_plane_xz(middle_lr,g_x_dir,g_z_dir)
  
    get_result = p[cent_p[0],cent_p[1],cent_p[2],final_feature[3],final_feature[4],final_feature[5]]
  
    # wp_test = p[cent_p[0],cent_p[1],cent_p[2],get_wpx1[3],get_wpx1[4],get_wpx1[5]]
    # get_result = feature_offset(get_result,p[0,0,0,d2r(-15),d2r(-45),0],get_result)
    # movel(get_result)
    return get_result
  end
  
  def touch_4p_get_middle(get_wpy1,get_wpy2,get_wpz1,get_wpz2,left_dir,bottom_pose=p[0,0,0,0,0,0],f2_par=False):
    feature_right = get_feature_Line(get_wpy1,get_wpy2)
    feature_left = get_feature_Line(get_wpz1,get_wpz2)
  
    f_gap1 = feature_offset(get_wpz1,p[0,1/1000,0,0,0,0],feature_left)
    f_gap2 = feature_offset(get_wpz1,p[0,2/1000,0,0,0,0],feature_left)
    gap_r1 = get_feature_pose(f_gap1, feature_right)
    gap_r2 = get_feature_pose(f_gap2, feature_right)
    test13 = gap_r1[0]/(gap_r1[0] - gap_r2[0])
  
    cent_p = feature_offset(get_wpz1,p[0,(1+test13)/1000,0,0,0,0],feature_left)
    cent_p = p[cent_p[0],cent_p[1],cent_p[2],get_wpy1[3],get_wpy1[4],get_wpy1[5]]
  
    get_r_o = feature_offset(cent_p,p[0,-0.02,0,0,0,0],feature_right)
    get_l_o = feature_offset(cent_p,p[0,-0.02,0,0,0,0],feature_left)
  
    middle_lr = interpolate_pose(get_r_o,get_l_o,0.5)
  
    yy_dir = get_feature_Line(middle_lr,get_l_o)
    zz_dir = get_feature_Line(cent_p,middle_lr)
  
    g_y_dir = feature_offset(middle_lr,p[0,-point_dist(middle_lr,cent_p),0,0,0,0],yy_dir)
    g_z_dir = feature_offset(middle_lr,p[0,-point_dist(middle_lr,cent_p),0,0,0,0],zz_dir)
  
    final_feature = get_feature_plane_yz(middle_lr,g_y_dir,g_z_dir)
    if(False):
      cent_p[2] = bottom_pose[2]
    end
    get_result = p[cent_p[0],cent_p[1],cent_p[2],final_feature[3],final_feature[4],final_feature[5]]
  
    #movel(get_result)
  
    return get_result
  end
  
  def get_feature_pose(fun_pose,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    return fun_p_feature
  end
  
  
  def get_base_pose(fun_p_feature,fun_plane=p[0,0,0,0,0,0]):
    fun_pose = pose_trans ( fun_plane, fun_p_feature)
    return fun_pose
  end
  
  def set_pos_xyz(get_pos_h=p[0,0,0,0,0,0],set_pos_h=[0,0,0]):
    if(set_pos_h[0] != 0):
      get_pos_h[0] = set_pos_h[0]
    end
    if(set_pos_h[1] != 0):
      get_pos_h[1] = set_pos_h[1]
    end
    if(set_pos_h[2] != 0):
      get_pos_h[2] = set_pos_h[2]
    end
    return get_pos_h
  end
  
  def set_rot_rpy_deg(get_pos_h=p[0,0,0,0,0,0],set_rot_h=[0,0,0]):
    cal_p_rpy = rotvec2rpy([get_pos_h[3],get_pos_h[4],get_pos_h[5]])
    if(set_rot_h[0] != 0):
      cal_p_rpy[0] = d2r(set_rot_h[0])
    end
    if(set_rot_h[1] != 0):
      cal_p_rpy[1] = d2r(set_rot_h[1])
    end
    if(set_rot_h[2] != 0):
      cal_p_rpy[2] = d2r(set_rot_h[2])
    end
    cal_p = rpy2rotvec(cal_p_rpy)
    get_pos_h[3] = cal_p[0]
    get_pos_h[4] = cal_p[1]
    get_pos_h[5] = cal_p[2]
    return get_pos_h
  end
  
  
  thread CalThread():
    while (True):
      FB_CURRENT_UR = get_standard_analog_in(1)*100
      #FB_CURRENT_UR = get_standard_analog_in(1)*125
      FB_VOLTAGE_UR = get_standard_analog_in(0)*8
  
      FB_CURRENT_UR_org = FB_CURRENT_UR
      FB_VOLTAGE_UR_org = FB_VOLTAGE_UR
  
      write_output_float_register(2,FB_CURRENT_UR)
      write_output_float_register(3,FB_VOLTAGE_UR)
      write_port_register(131,FB_CURRENT_UR)
      write_port_register(132,FB_VOLTAGE_UR*10)
  
      if(FB_CURRENT_UR>=c_maxcut and FB_CURRENT_UR>50):
        FB_CURRENT_UR = c_maxcut
      elif(FB_CURRENT_UR<=c_mincut and FB_CURRENT_UR>50):
        FB_CURRENT_UR = c_mincut
      end
  
      if(FB_CURRENT_UR>50):
        if(current_on==False):
          current_on=True
        end
        if(sin_dir==-1):
          if(peak_value==100):
            one_cycle_p_count = one_cycle_p_count + 1
            one_cycle_p_accum = one_cycle_p_accum + FB_CURRENT_UR
            one_cycle_p_accum_org = one_cycle_p_accum_org + FB_CURRENT_UR_org
          end
        else:
          if(peak_value==100):
            one_cycle_m_count = one_cycle_m_count + 1
            one_cycle_m_accum = one_cycle_m_accum + FB_CURRENT_UR
            one_cycle_m_accum_org = one_cycle_m_accum_org + FB_CURRENT_UR_org
          end
        end
      end
  
      GCP = get_feature_pose(get_actual_tcp_pose(),wv_Line_Feature2)
      write_output_float_register(14,GCP[0]*1000)
      write_output_float_register(15,GCP[1]*1000)
      write_output_float_register(16,GCP[2]*1000)
  
      GJP = get_actual_joint_positions()
  
      # write_output_float_register(20,r2d(GJP[0])*10)
      # write_output_float_register(21,r2d(GJP[1])*10)
      # write_output_float_register(22,r2d(GJP[2])*10)
      # write_output_float_register(23,r2d(GJP[3])*10)
      # write_output_float_register(24,r2d(GJP[4])*10)
      # write_output_float_register(25,r2d(GJP[5])*10)
  
  
      # if(get_wcr):
      #   write_output_float_register(20,1)
      # else:
      #   write_output_float_register(20,0)
      # end
  
      # write_output_float_register(21,read_port_register(201))
      sleep(0.004)
    end
  end
  
  thread diff_Thread():
    while (True):
      if(background_cal==1):
        background_cal = 0
        if(th_arc_sen[0]==1):
          if(counter_average_num == squash_cycle * counter_average*2 and squash_cycle!=0):
            counter_average_num = 0
            if(th_ext_fun[2]==1):
              #squash
              squash_cycle = 0
              w_voltage = th_ext_fun[0] #org vol
              w_current = th_ext_fun[1] #org cur
              set_current_voltage(w_current,w_voltage)
              th_wv_weldpar[4] = wving_amplitude_bak
              th_wv_weldpar[1] = cir_speed_org_bak
              if(th_par_2f):
                 global wv_system_speed = calculate_2f(th_wv_weldpar[4],th_wv_wp1,th_wv_wp2,th_wv_weldpar[1],th_wv_weldpar[3],th_wving_delay,th_wving_crater)
              else:
                global wv_system_speed = calculate_3f(th_wv_weldpar[4],th_wv_wp1,th_wv_wp2,th_wv_weldpar[1],th_wv_weldpar[3],th_wving_delay)
                x_radius = x_radius / 1000
              end
              global y_radius = y_radius / 1000
              global y_radius_bak = y_radius
            end
          end
          if(counter_average_num == (waste_cycle + squash_cycle)*counter_average*2 and waste_cycle != 0):
            write_output_float_register(19,100)
            counter_average_num = counter_average_num - waste_cycle
            waste_cycle = 0
            squash_cycle = 0
            one_cycle_p_count = 0
            one_cycle_m_count = 0
            one_cycle_p_accum = 0
            one_cycle_m_accum = 0
            one_cycle_p_accum_org = 0
            one_cycle_m_accum_org = 0
            counter_average_num = 0
          end
          if((counter_average_num >= (counter_average*2) + ((waste_cycle+squash_cycle) * counter_average*2))):
            cycle1_plus = one_cycle_p_accum / one_cycle_p_count
            cycle1_minus = one_cycle_m_accum / one_cycle_m_count
            cycle1_middle = (cycle1_plus+cycle1_minus)/2
            cycle1_plus_org = one_cycle_p_accum_org / one_cycle_p_count
            cycle1_minus_org = one_cycle_m_accum_org / one_cycle_m_count
            cycle1_middle_org = (cycle1_plus_org+cycle1_minus_org)/2
            write_output_float_register(9,cycle1_middle)
            write_output_float_register(6,cycle1_plus)
            write_output_float_register(7,cycle1_minus)
            # write_output_float_register(23,cycle1_plus_org)
            # write_output_float_register(24,cycle1_minus_org)
            # write_output_float_register(25,cycle1_middle_org)
            cycle_number = cycle_number + 1
            if(cycle_done == False):
              if(th_arc_sen[5] != 0):
                Standard_Arc_Current = th_arc_sen[5]
              else:
                if(th_par_2f):
                  Standard_Arc_Current = current_to_welding_m+10
                else:
                  Standard_Arc_Current = current_to_welding_m+15
                end
  
              end
              write_output_float_register(8,Standard_Arc_Current)
            end
            if(cycle_number==4):
              cycle_done = True
            end
            one_cycle_p_count = 0
            one_cycle_m_count = 0
            one_cycle_p_accum = 0
            one_cycle_m_accum = 0
            one_cycle_p_accum_org = 0
            one_cycle_m_accum_org = 0
  
            #---------------------------------------X offset --------------------------------------------
            if((norm(cycle1_plus - cycle1_minus) > 0.2) and cycle1_plus > (current_to_welding_m - 40) and cycle1_minus > (current_to_welding_m - 40)):
              arc_sensing_diff = cycle1_plus - cycle1_minus
              if(norm(arc_sensing_diff)>12):
                p_gain_u = th_arc_sen[1] / 100 *2 #0.28
                i_gain_u = th_arc_sen[2] / 1000 *2#0.004
              elif(norm(arc_sensing_diff)>7):
                p_gain_u = th_arc_sen[1] / 100 * 1.5#0.14
                i_gain_u = th_arc_sen[2] / 1000 * 1.5#0.004
              else:
                p_gain_u = th_arc_sen[1] / 100 #0.14
                i_gain_u = th_arc_sen[2] / 1000 #0.004
              end
  
              Ts = 1/system_bus_ms
  
              if(arc_sensing_diff>10):
                arc_sensing_diff = 10
              elif(arc_sensing_diff<-10):
                arc_sensing_diff = -10
              end
  
              Up = arc_sensing_diff * p_gain_u
              Ui = Ui + arc_sensing_diff * i_gain_u * Ts
              Pi_sum = Up + Ui
  
              if(Pi_sum>7):
                Pi_sum = 0
              elif(Pi_sum< -7):
                Pi_sum = 0
              end
  
              arc_x_off = Pi_sum * arc_sens_onoff
              if(th_par_2f==False):
                th_wv_wp2 = feature_offset(th_wv_wp2,p[0,-arc_x_off/1000,0,0,0,0],wv_Line_Feature2)
              end
              write_output_float_register(10,Up)
              write_output_float_register(11,Ui)
              write_output_float_register(4,-arc_x_off)
            end
  
            #write_output_float_register(4,Standard_Arc_Current)
  
            #---------------------------------------Z offset --------------------------------------------
            #record 36-46
            arc_sensing_diff_z = Standard_Arc_Current-cycle1_middle
            if(norm(arc_sensing_diff_z)>0.2):
              if(norm(arc_sensing_diff_z)>10):
                p_gain_u_z = th_arc_sen[3] / 1000 * 3.5#0.05
                i_gain_u_z = th_arc_sen[4] / 1000 * 3 #0.018
              elif(norm(arc_sensing_diff_z)>5):
                p_gain_u_z = th_arc_sen[3] / 1000 * 1.8 #0.025
                i_gain_u_z = th_arc_sen[4] / 1000 * 1.5 #0.008
              else:
                p_gain_u_z = th_arc_sen[3] / 1000 #0.015
                i_gain_u_z = th_arc_sen[4] / 1000 #0.004
              end
  
              Ts = 1/system_bus_ms
  
              if(arc_sensing_diff_z>10):
                arc_sensing_diff_z = 10
              elif(arc_sensing_diff_z<-10):
                arc_sensing_diff_z = -10
              end
  
              Up_z = arc_sensing_diff_z * p_gain_u_z
              Ui_z = Ui_z + arc_sensing_diff_z * i_gain_u_z * Ts
              #
  
              Pi_sum_z = Up_z + Ui_z
  
              if(Pi_sum_z > 5):
                Pi_sum_z = 5
              elif(Pi_sum_z< -5):
                Pi_sum_z = -5
              end
  
              global arc_z_off = Pi_sum_z *arc_sens_onoff
  
              if(th_par_2f==False):
                th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,arc_z_off/1000,0,0,0],wv_Line_Feature2)
              end
              write_output_float_register(12,Up_z)
              write_output_float_register(13,Ui_z)
              write_output_float_register(5,arc_z_off)
              # write_output_float_register(42,100)
            end
            arc_x_off = 0
            arc_z_off = 0
            counter_average_num = 0
          end
          counter_average_num = counter_average_num + 1
          sync()
        end
        if(th_wv_gap[0]==1):
          T1 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          global get_angle_rx = welding_angle_cal_2f(T1[1],th_tilt_deg,vir_v,cal_off_ang_rx)
          global get_angle_ry = welding_angle_cal_3f(T1[2],th_tilt_deg,z_bottom,cal_off_ang_ry)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T1 = p[T1[0],T1[1],T1[2],T_angle[3],T_angle[4],T_angle[5]]
          ratio_t = ratio_t + 1/get_total
          write_output_float_register(19,ratio_t)
  
          T2 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T2 = p[T2[0],T2[1],T2[2],T_angle[3],T_angle[4],T_angle[5]]
  
          T_P = interpolate_pose(T1,T2,0.5)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T_P = p[T_P[0],T_P[1],T_P[2],T_angle[3],T_angle[4],T_angle[5]]
          global cur_dis = move_dis_total-get_line_dist(T1,th_wv_wp2)*1000
          global amplitude_gap = th_wv_weldpar[4] + (th_wv_gap[1]-th_wv_weldpar[4]) * (cur_dis/move_dis_total)
          global speed_gap = th_wv_weldpar[1] + (th_wv_gap[2]-th_wv_weldpar[1]) * (cur_dis/move_dis_total)
          if(th_par_2f):
            global wv_system_speed = calculate_2f(amplitude_gap,th_wv_wp1,th_wv_wp2,speed_gap,th_wv_weldpar[3],th_wving_delay,th_wving_crater)
          else:
            global wv_system_speed = calculate_3f(amplitude_gap,th_wv_wp1,th_wv_wp2,speed_gap,th_wv_weldpar[3],th_wving_delay)
          end
          y_radius = y_radius/1000
        else:
          T1 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          global get_angle_rx = welding_angle_cal_2f(T1[1],th_tilt_deg,vir_v,cal_off_ang_rx)
          global get_angle_ry = welding_angle_cal_3f(T1[2],th_tilt_deg,z_bottom,cal_off_ang_ry)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T1 = p[T1[0],T1[1],T1[2],T_angle[3],T_angle[4],T_angle[5]]
          ratio_t = ratio_t + 1/get_total
          write_output_float_register(19,ratio_t)
  
          T2 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T2 = p[T2[0],T2[1],T2[2],T_angle[3],T_angle[4],T_angle[5]]
  
          T_P = interpolate_pose(T1,T2,0.5)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T_P = p[T_P[0],T_P[1],T_P[2],T_angle[3],T_angle[4],T_angle[5]]
          global cur_dis = move_dis_total-get_line_dist(T1,th_wv_wp2)*1000
        end
  
        sin_dir = sin_dir * -1
        if(th_wv_weldpar[5]==1):
          # 삼각
          Tp1 = T1
          Tp2 = feature_offset(T_P,p[0,th_dir*y_radius*sin_dir,0,0,0,0],wv_Line_Feature2)
          Tp3 = T2
          if(ratio_t + 1/get_total >= 1):
            background_pose = [Tp3,Tp3,Tp3]
          else:
            background_pose = [Tp1,Tp2,Tp3]
          end
        elif(th_wv_weldpar[5]==2):
          # 사선
          #y_radius = y_radius_bak/2
          Tp1 = feature_offset(T1,p[0,th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          # Tp1 = feature_offset(T1,p[0,y_radius,0,0,0,0],wv_Line_Feature2)
          push_angle = th_wving_crater[6]
          push_dis = norm(y_radius)/tan(d2r(push_angle))
          if(th_wv_weldpar[6] == 1):
            Tp1 = feature_offset(T1,p[push_dis,0,0,0,0,0],wv_Line_Feature2)
            #Tp1 = feature_offset(Tp1,p[push_dis,0,0,0,0,0],wv_Line_Feature2)
          else:
            Tp1 = feature_offset(T1,p[-push_dis,0,0,0,0,0],wv_Line_Feature2)
            #Tp1 = feature_offset(Tp1,p[-push_dis,0,0,0,0,0],wv_Line_Feature2)
          end
          Tp2 = T_P
          # if(start_trig):
          #   b_dist = point_dist(Tp1,Tp3)
          # end
          Tp3 = feature_offset(T2,p[0,-th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          # Tp3 = feature_offset(T2,p[0,-y_radius,0,0,0,0],wv_Line_Feature2)
  
          gcp = get_actual_tcp_pose()
          # write_output_float_register(23,-th_dir*y_radius*1000)
          # write_output_float_register(24,push_dis*1000)
  
          if(ratio_t + 1/get_total >= 1):
            background_pose = [Tp1,Tp2,Tp3]
          else:
            background_pose = [Tp1,Tp2,Tp3]
          end
          # if(start_trig):
          #   a_dist = point_dist(Tp1,Tp3)
          #   sum_dist = a_dist+b_dist
          #   sum_dist = sum_dist*1000
          #   global total_dis = wv_total_hz * sum_dist
          # else:
          #   start_trig = True
          # end
          # global wv_system_speed = (total_dis) / ((wv_times)*(1-(th_wving_delay[0]+th_wving_delay[1]+th_wving_delay[2]+th_wving_delay[3])))
        end
      end
      #168:arc on/off,  169:stick +- 1 mm 170 - 2 next
      get_stick_2 = read_port_register(169)
      if(welding_off_t == 1 and weld_onoff == True):
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
      elif(welding_off_t == 2 and weld_onoff == False and program_weld_on == True and next_path_c == False):
        write_welder(0,True)
      end
      if(get_stick_2==1):
        th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,2/1000,0,0,0],wv_Line_Feature2)
        write_port_register(169,0)
      elif(get_stick_2==2):
        th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,-2/1000,0,0,0],wv_Line_Feature2)
        write_port_register(169,0)
      end
      if(read_port_register(167)>=1):
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
        next_path_c = True
        ratio_t = 1.5
        global current_list=999
      end
      background_ready=1
      sync()
    end
  end
  
  def welding_angle_cal_2f_old(c_pos,tilt_deg,vir_v,cal_off_ang_rx):
    if(cal_off_ang_rx==1):
      global wdangle = (((c_pos*1000 / 500*0.65)+0.35*vir_v) * tilt_deg[0])-tilt_deg[0]
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def welding_angle_cal_2f(c_pos,tilt_deg,vir_v,cal_off_ang_rx):
    if(cal_off_ang_rx==1):
      global wdangle = ((c_pos*1000 / 500) * tilt_deg[0])-tilt_deg[0]
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def welding_angle_cal_3f(c_pos,tilt_deg,z_bottom,cal_off_ang_ry):
    if(cal_off_ang_ry==1):
      global wdangle = (((c_pos-z_bottom)*1000) / 500) * 43 #700->600
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def inv_inching(time = 0.3):
    write_welder(2,True)
    sleep(time)
    write_welder(2,False)
  end
  
  def read_welder(status):
    if(isHicomm):
      return read_welder_hicomm(status)
    else:
      return read_welder_analog(status)
    end
  end
  
  def read_welder_hicomm(status):
    #status 4 - stick, 5 - WCR
    status_addr = [1,2,4,8,16,32,64,128]
    global r_data = read_port_register(211)
    global b_data = integer_to_binary_list(r_data)
    if(status_addr[status]<=r_data):
      return b_data[status]
    else:
      return False
    end
  end
  #0 - wcr, 1 - stick
  def read_welder_analog(status):
    #status 4 - stick, 5 - WCR
    # stick 1, WCR - 0번 digital INPUT
    status_addr = [6,6,6,6,1,0,6,6]
    return get_standard_digital_in(status_addr[status])
  end
  
  def read_welder_control(status):
    if(isHicomm):
      return read_welder_control_hicomm(status)
    else:
      return read_welder_control_analog(status)
    end
  end
  
  def read_welder_control_hicomm(status):
    #status 0 - torch, 1 - inch, 2 - inverse inch, 3 - gas check, 4 - stick check, 6 - robot error
    status_addr = [1,2,4,8,16,32,64,128]
    global r_data = read_port_register(202)
    global b_data = integer_to_binary_list(r_data)
    if(status_addr[status]<=r_data):
      return b_data[status]
    else:
      return False
    end
  end
  #DI 0: wcr, 1:stick , 2:error
  #DO - 0:torch,1:inching,2:invser,3:gas check, 4:touch
  #status 0 - torch, 1 - inchX, 2 - inverse inchX, 3 - gas checkX, 4 - stick check, 6 - robot errorX
  # touch 4 ,torch - 0 digital INPUT
  def read_welder_control_analog(status):
    status_addr = [0,1,2,3,4,5]
    return get_standard_digital_out(status_addr[status])
  end
  
  def write_welder(status,w_value):
    if(isHicomm):
      write_welder_hicomm(status,w_value)
    else:
      write_welder_analog(status,w_value)
    end
  end
  
  def write_welder_hicomm(status,w_value):
    #status 0 - torch, 1 - inch, 2 - inverse inch, 3 - gas check, 4 - stick check, 6 - robot error
    status_addr = [1,2,4,8,16,64]
    write_port_register(201,1)
    if(w_value):
      r_data = status_addr[status]
    elif(w_value==False):
      r_data = 0
    end
    write_port_register(202,r_data)
    write_port_register(149,r_data)
    # write_output_float_register(22,r_data)
  end
  
    #status 0 - torch, 1 - inchX, 2 - inverse inchX, 3 - gas checkX, 4 - stick check, 6 - robot errorX
    # touch 4, touch - 0 digital INPUT
  def write_welder_analog(status,w_value):
    status_addr = [0,1,2,3,4,5]
    set_standard_digital_out(status_addr[status],w_value)
    # write_output_float_register(22,status_addr[status])
  end
  
  def ori_move(origin_pose,angle_pose):
    global get_ori_p = p[origin_pose[0],origin_pose[1],origin_pose[2],angle_pose[3],angle_pose[4],angle_pose[5]]
    movel(get_ori_p,a=0.8,v=0.4)
  end
  
  def ori_pose(origin_pose,angle_pose):
    return p[origin_pose[0],origin_pose[1],origin_pose[2],angle_pose[3],angle_pose[4],angle_pose[5]]
  end
  
  def put_pose(origin_pose,put_index,put_value):
    origin_pose[put_index]=put_value
    return origin_pose
  end
  
  def register_read(register_num):
    r_data = read_port_register(register_num)
    if(r_data> 32768):
      return r_data - 65535
    else:
      return r_data
    end
  end
  
  def tilt_2f_fun(get_p,tilt_deg,welding_dir,rotat = False,get_feature=p[0,0,0,0,0,0]):
    if(get_feature==p[0,0,0,0,0,0]):
      get_feature = get_p
    end
    if(welding_dir==-1):
      vir_v = -1
    else:
      vir_v = 1
    end
    cal_off_ang_rx = 1
    get_angle_rx = welding_angle_cal_2f(get_p[1],tilt_deg,vir_v,cal_off_ang_rx)
  
    if(rotat==False):
      get_p = pose_trans(get_p,p[0,0,0,0,0,d2r(-90)])
    end
    get_p = feature_offset(get_p,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1]),d2r(tilt_deg[2])],get_feature)
    return get_p
  end
  
  def tilt_3f_fun(get_p,tilt_deg,z_bottom,get_feature=p[0,0,0,0,0,0]):
    if(get_feature==p[0,0,0,0,0,0]):
      get_feature = get_p
    end
    cal_off_ang_ry = 1
    global get_angle_ry = welding_angle_cal_3f(get_p[2],tilt_deg,z_bottom,cal_off_ang_ry)
    get_p = feature_offset(get_p,p[0,0,0,d2r(tilt_deg[0]),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],get_feature)
    return get_p
  end
  
  def calculate_3f(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay):
    # y_radius of tri wave is wving_amplitude (mm)
    global y_radius = wving_amplitude / 2
    # get total line distance without rotation (mm)
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis2 = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
    #global wving_frequency_2 = wving_frequency
  
    #Circle_Speed=(a2_speed_cpm/6)*(a4_wv_frequency*(b3_wv_delay1+b4_wv_delay2+b5_wv_delay3+b6_wv_delay4)+1)*1.2
    #cpm - cm per minute 1 cpm - 10mm per minute = 1/6mm per second = cpm * 1/6 mm/sec
    # total running time (sec) - cir_speed_org cpm.
    global wv_times_org = move_dis/(cir_speed_org/6)
    global wv_times = wv_times_org
  
    # wv tri total count (times) - speed and arrive right position is more important so floor hz
    # dwell time 0.4 초면 1.4초당 3.3회를 해야 한다.
    # total time 100초, delay 1초, hz5 - 2sec 5times. 100/5*2
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
  
    system_delay = 0.12044 + (wving_frequency-1)*0.038
    wv_times = wv_times_org - (wv_total_hz*2*system_delay)
    # wv_total_hz = floor(wv_times*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
  
    # wv tri_half total count (times)
    global get_total = wv_total_hz*2
    # wv step -> final value should be same with get_total
  
    # x radius of tri wave
    global x_radius = (move_dis/wv_total_hz)
    # single wave distance
    global wave_dis = sqrt((x_radius*x_radius)+(y_radius*y_radius))*4
    # total robot distance
    global total_dis = wv_total_hz * wave_dis
  
    # robot speed distance/time = speed
    wv_system_speed = total_dis / (wv_times)
    if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  
  
  def set_current_voltage(o_cur,o_vol):
    if(isHicomm):
      set_current_voltage_hicomm(o_cur,o_vol)
    else:
      set_current_voltage_analog(o_cur,o_vol)
    end
  end
  
  def set_current_voltage_hicomm(o_cur,o_vol):
      write_port_register(204,o_cur)
      write_port_register(205,o_vol*10)
      write_port_register(133,o_cur)
      write_port_register(134,o_vol*10)
  end
  
  def set_current_voltage_analog(o_cur,o_vol):
      vol_an=((o_vol-14)/2.8)/10
      amp_an=((o_cur-60)/44)/10
      set_standard_analog_out(0,vol_an)
      set_standard_analog_out(1,amp_an)
      write_port_register(133,o_cur)
      write_port_register(134,o_vol*10)
  end
  
  
  def calculate_2f_old(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay,wving_crater):
    global y_radius = wving_amplitude / 2
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
  
    global wv_times_org = move_dis/(cir_speed_org*1/6)
    global wv_times = wv_times_org
  
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
    system_delay = 0.00832
    global wv_times = wv_times_org - (wv_total_hz*2*system_delay)
  
    global get_total = wv_total_hz
    dir=1
    ratio_t_sam = 1/get_total*1
    T1_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    ratio_t_sam = ratio_t_sam + 1/get_total
    T2_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    global push_angle = wving_crater[6]
    global push_dis_sam = norm(y_radius)/tan(d2r(push_angle))
    Tp1_sam = feature_offset(T1_sam,p[0,dir*y_radius,0,0,0,0],wv_Line_Feature2)
    Tp1_sam = feature_offset(T1_sam,p[push_dis_sam,0,0,0,0,0],wv_Line_Feature2)
    Tp2_sam = feature_offset(T2_sam,p[0,-dir*y_radius,0,0,0,0],wv_Line_Feature2)
    Tp3_sam = feature_offset(T2_sam,p[0,dir*y_radius,0,0,0,0],wv_Line_Feature2)
    Tp3_sam = feature_offset(T2_sam,p[push_dis_sam,0,0,0,0,0],wv_Line_Feature2)
  
    global total_dis = wv_total_hz * (point_dist(Tp1_sam,Tp2_sam)+point_dist(Tp3_sam,Tp2_sam))
    wv_system_speed = total_dis / wv_times
      if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  
  
  def calculate_2f(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay,wving_crater):
    global y_radius = wving_amplitude / 2
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
    global wv_times_org = move_dis/(cir_speed_org*1/6)
    global wv_times = wv_times_org
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
    global get_total = wv_total_hz*4
  
    dir=1
    ratio_t_sam = 1/get_total*1
    T1_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    global ratio_t_sam = ratio_t_sam + 2/get_total
    T2_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    ratio_t_sam = ratio_t_sam + 1/get_total
    T3_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    global push_angle = wving_crater[6]
    global push_dis_sam = norm(y_radius)/tan(d2r(push_angle))
    Tp1_sam = feature_offset(T1_sam,p[0,dir*y_radius/1000,0,0,0,0],wv_Line_Feature2)
    Tp1_sam = feature_offset(Tp1_sam,p[push_dis_sam/1000,0,0,0,0,0],wv_Line_Feature2)
    Tp2_sam = feature_offset(T2_sam,p[0,-dir*y_radius/1000,0,0,0,0],wv_Line_Feature2)
    global total_dis = wv_total_hz * (get_line_dist(tg_wv_wp1,Tp1_sam)+get_line_dist(Tp1_sam,Tp2_sam)+get_line_dist(Tp2_sam,T3_sam))*1000
    wv_system_speed = total_dis / wv_times
    system_delay =  (wv_system_speed*2.1)/1000
    wv_times = wv_times_org - (wv_total_hz*2*system_delay)
    wv_system_speed = total_dis / wv_times
    get_total = wv_total_hz*2
  
      if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  def weaving_simple(wv_wp1,wv_wp3,cir_speed_org,wving_frequency,wving_amplitude,welding_on):
    wv_dist = 0
    tilt_deg = [0,0,0]
    wving_delay = [0,0,0,0]
    wving_type = 1
    Arc_sen=[0,0,0,0,0,0]
    wv_gap=[0,0,0,0]
    welding_dir=1
    z_param=[0,0,0,0,0]
    par_2f=False
    wving_crater=[0,0,0,0,0,0,0,0,0,0]
    ext_fun=[0,0,0,0,0,0,0,0,0,0,0]
    wv_seq = [0,-1]
    wv_feature=p[0,0,0,0,0,0]
    wv_weldpar=[0,cir_speed_org,0,wving_frequency,wving_amplitude,wving_type,welding_dir]
    line_weaving_tp(wv_wp1,wv_wp3,wv_weldpar,tilt_deg,wving_delay,welding_on,Arc_sen,wv_gap,z_param,par_2f,wving_crater,ext_fun,wv_seq,wv_feature)
  end
  
  def line_weaving_tp(wv_wp1,wv_wp3,wv_weldpar=[100,10,0,1,5,1,1],tilt_deg=[0,0,0],wving_delay=[0,0,0,0],welding_on=False,Arc_sen=[0,0,0,0,0,0],wv_gap=[0,0,0,0],z_param=[0,0,0,0,0],par_2f=False,wving_crater=[0,0,0,0,0,0,0,0,0,0],ext_fun=[0,0,0,0,0,0,0,0,0,0,0],wv_seq = [0,-1],wv_feature=p[0,0,0,0,0,0]):
    global start_gas_time = 2
    global counter_average = 1
    global counter_average_num = 0
    global waste_cycle = ext_fun[8]
    if(par_2f):
      global squash_cycle = 0
    else:
      global squash_cycle = ext_fun[7]
    end
    global th_ext_fun = ext_fun
    RTDE_init()
  
    # e-Series 2, CB-Seris 8
    global system_bus_ms = 2
  
    global sin_dir = wv_seq[1]
    global start_trig = False
    dir=1
  
    global tri_count=0
  
    global z_bottom = z_param[0]/1000
    if(wv_weldpar[6]==-1):
      global vir_v = -1
    else:
      global vir_v = 1
    end
  
    if(par_2f):
      global cal_off_ang_rx = 1
      global cal_off_ang_ry = 0
    else:
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 1
    end
  
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      tilt_deg = [0,0,0]
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 0
    end
  
    global wv_Line_Feature2 = wv_wp1
    if(wv_weldpar[0] > 650 and par_2f == False):
      wv_weldpar[0] = 650
    end
    if(wv_wp3==p[0,0,0,0,0,0]):
      global wv_wp2 = feature_offset(wv_wp1,p[wv_weldpar[0]/1000,0,0,0,0,0],wv_Line_Feature2)
    else:
      global wv_wp2 = wv_wp3
      wv_weldpar[0] = point_dist(wv_wp1,wv_wp2)*1000
      global wv_dist_bak = point_dist(wv_wp1,wv_wp2)*1000
    end
    if(wv_feature != p[0,0,0,0,0,0]):
      wv_Line_Feature2 = wv_feature
    end
    #setting
    if(par_2f):
      #todo - 1
      global offset_2f_k = -1 * ext_fun[9]
      global offset_2f_z = 1 * ext_fun[10]
      if(wv_seq[0] == 0 or wv_seq[0] == 1):
        line_feature = get_feature_Line(wv_wp1,wv_wp2)
        b_p1 = wv_wp1
        b_p2 = feature_offset(wv_wp1,p[0,0.02*vir_v,0,0,0,0],line_feature)
        # b_p2 = feature_offset(wv_wp1,p[0,0.01,0,0,0,0],line_feature)
        b_p3 = pose_add(wv_wp1,p[0,0,0.02,0,0,0])
  
        back_feature = get_feature_plane_xz(b_p1,b_p2,b_p3)
  
        wv_wp1 = pose_trans(wv_wp1,p[0,0,0,0,0,d2r(-90)])
        wv_wp1 = feature_offset(wv_wp1,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp1 = pose_add(wv_wp1,p[0,0,offset_2f_z/1000,0,0,0])
        global bak_wv_wp1 = wv_wp1
      end
        wv_wp2 = feature_offset(wv_wp2,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp2 = pose_add(wv_wp2,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp2 = p[wv_wp2[0],wv_wp2[1],wv_wp2[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        global bak_wv_wp2 = wv_wp2
    end
    if(ext_fun[2]==1 and par_2f==False):
      w_voltage = ext_fun[3]
      w_current = ext_fun[4]
      set_current_voltage(w_current,w_voltage)
      global cir_speed_org_bak = wv_weldpar[1]
      global wving_amplitude_bak = wv_weldpar[4]
      wv_weldpar[1] = ext_fun[6]
      wv_weldpar[4] = ext_fun[5]
    end
    if(par_2f):
      global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
    else:
      global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay)
      x_radius = x_radius / 1000
    end
    global wv_set_speed = wv_system_speed
    ratio_t=0
    global y_radius = y_radius / 1000
    global y_radius_bak = y_radius
    global ext_stick = 0
    global th_arc_sen=Arc_sen
    global th_wv_gap=wv_gap
    global th_tilt_deg=tilt_deg
    global last_tilt_deg = th_tilt_deg
    global last_wv_wp1 = wv_wp1
    global last_wv_line = wv_Line_Feature2
    global last_z_bottom = z_bottom
    global th_wving_crater=wving_crater
    global th_par_2f = par_2f
    global th_cir_speed_org=wv_weldpar[1]
    global th_wv_wp1 = wv_wp1
    global th_wv_wp2 = wv_wp2
    global th_wv_wp3 = wv_wp3
    global th_wv_weldpar=wv_weldpar
    global th_wving_delay=wving_delay
    global th_z_param=z_param
    global th_wv_seq = wv_seq
    global th_wv_feature=wv_feature
    global th_dir = dir
  
    # if want to use approach position
    if(wv_seq[0] ==0 or wv_seq[0] == 1):
      global get_angle_rx = welding_angle_cal_2f(wv_wp1[1],tilt_deg,vir_v,cal_off_ang_rx)
      global get_angle_ry = welding_angle_cal_3f(wv_wp1[2],tilt_deg,z_bottom,cal_off_ang_ry)
  
      target_p = feature_offset(wv_wp1,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],wv_Line_Feature2)
  
      if(wv_weldpar[2]==1):
        target_p_appr = feature_offset(target_p,p[0,0,-0.02,0,0,0],wv_Line_Feature2)
        movel(target_p_appr,a=0.5,v=0.125)
      end
      movel(target_p,a=0.5,v=0.125)
    end
    CThread = run CalThread()
    DThread = run diff_Thread()
    TThread = run thread_timer()
    global timer_counting=True
    global program_weld_on = True
  
    if(a9_wv_weldingon==True):
      while(welding_off_t==55):
        sync()
      end
      if(wving_crater[2]>0):
        set_current_voltage(wving_crater[0],wving_crater[1])
      end
      if(welding_off_t != 1):
        if(isHicomm):
          write_welder(0,True)
        else:
          set_standard_digital_out(0,True)
        end
        while(read_welder(5)==False):
          if(weld_onoff==False):
              write_welder(0,True)
          end
          sync()
        end
        if(wving_crater[2]>0):
          #Crater Begin option
          write_output_float_register(1,1)
          sleep(wving_crater[2])
          set_current_voltage(ext_fun[1],ext_fun[0])
        end
      end
    end
    start_gas_time = 0
  
    background_cal=1
    background_ready=0
    FT_trig=True
    timer_1_is_counting = True
    global welding_program = False
  
    while((ratio_t < 1)):
      if((norm(tri_count)>=2 or (FT_trig==True))):
        FT_trig = False
        while(background_ready==0):
          sync()
        end
        tri_count = 0
        background_ready = 0
        global move_p = background_pose
        wv_wp2 = th_wv_wp2
        if(par_2f):
          background_cal=1
        else:
          background_cal=1
        end
        global a_val = 3
        if(a_val >= 30):
          write_port_register(142,112)
          sleep(0.5)
          halt
        end
      end
  
      if(wv_weldpar[5] ==1):
          if( (sin_dir==1 and wving_delay[0]==0) or (sin_dir==-1 and wving_delay[2]==0)):
           tri_count = tri_count + 1
          end
          global target_p = move_p[tri_count]
          target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
          tri_count = tri_count + 1
      elif(wv_weldpar[5] ==2):
        if( (tri_count==1 and sin_dir==1 and wving_delay[0]==0) or (tri_count==1 and sin_dir==-1 and wving_delay[2]==0)):
         tri_count = tri_count + 1
        end
        global target_p = move_p[tri_count]
        target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
        tri_count = tri_count + 1
      else:
        popup("Please insert 0 - sin or 1 - triangle")
      end
      if(target_p == p[0,0,0,0,0,0]):
        target_p = get_actual_tcp_pose()
      end
      # write_output_float_register(25,tri_count)
      if((norm(tri_count)== 1) and sin_dir==1 and wving_delay[0]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[0])
        peak_value = 100
      elif((norm(tri_count)== 2) and sin_dir==1 and wving_delay[1]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[1])
        peak_value = 100
      elif((norm(tri_count)== 1) and sin_dir==-1 and wving_delay[2]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[2])
        peak_value = 100
      elif((norm(tri_count)== 2) and sin_dir==-1 and wving_delay[3]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[3])
        peak_value = 100
      else:
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 100
      end
      global last_pose = target_p
    end
    timer_1_is_counting = False
  
    if(a9_wv_weldingon == True and wving_crater[5]!=0):
      #crater end option
      set_current_voltage(wving_crater[3],wving_crater[4])
      sleep(wving_crater[5])
      program_weld_on = False
      set_current_voltage(ext_fun[1],ext_fun[0])
      if(isHicomm):
        write_port_register(202,0)
        write_port_register(149,0)
      else:
        set_standard_digital_out(0,False)
      end
      while(read_welder(5)==True):
        if(weld_onoff==True):
          write_welder(0,False)
        end
        sync()
      end
    end
    timer_counter = 0
    kill CThread
    kill DThread
    kill TThread
    timer_counter = 0
    timer_counting = False
    wcr_counter = 0
    wcr_counting = False
    get_wcr = False
    welding_off_t = 0
  
    if(wv_seq[0] == 0 or wv_seq[0] == 3):
      if(a9_wv_weldingon==True):
        program_weld_on = False
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
        if(wv_weldpar[2]==1):
          target_pos = feature_offset(get_actual_tcp_pose(),p[0,0,-0.01,0,0,0],wv_Line_Feature2)
          movel(target_pos,0.5,0.01)
        end
      end
    end
    background_pose = [dumy_p,dumy_p,dumy_p]
    move_p = background_pose
    return sin_dir
  end
  
  
  def line_weaving_tp_l(wv_wp1,wv_wp3,wv_weldpar=[100,10,0,1,5,1,1],tilt_deg=[0,0,0],wving_delay=[0,0,0,0],welding_on=False,Arc_sen=[0,0,0,0,0,0],wv_gap=[0,0,0,0],z_param=[0,0,0,0,0],par_2f=False,wving_crater=[0,0,0,0,0,0,0,0,0,0],ext_fun=[0,0,0,0,0,0,0,0,0,0,0],wv_seq = [0,-1],wv_feature=p[0,0,0,0,0,0]):
    global start_gas_time = 2
    global counter_average = 1
    global counter_average_num = 0
    global waste_cycle = ext_fun[8]
    global current_list = 0
    global wv_wp4 = wv_wp3
    global A_T1 = wv_wp4[0]
    global A_T2 = wv_wp4[1]
    global A_T3 = wv_wp4[2]
    if(par_2f):
      global squash_cycle = 0
    else:
      global squash_cycle = ext_fun[7]
    end
    global th_ext_fun = ext_fun
    RTDE_init()
  
    if (wv_gap[0]==1):
      gap_check = True
      wv_gap[0]=0
    else:
      gap_check= False
    end
    # e-Series 2, CB-Seris 8
    global system_bus_ms = 2
  
    global sin_dir = wv_seq[1]
    global start_trig = False
    dir=1
  
    global tri_count=0
  
    global z_bottom = z_param[0]/1000
    if(wv_weldpar[6]==-1):
      global vir_v = -1
    else:
      global vir_v = 1
    end
  
    if(par_2f):
      global cal_off_ang_rx = 1
      global cal_off_ang_ry = 0
    else:
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 1
    end
  
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      tilt_deg = [0,0,0]
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 0
    end
  
    global wv_Line_Feature2 = wv_wp1
    if(wv_weldpar[0] > 700 and par_2f == False):
      wv_weldpar[0] = 700
    end
    if(wv_wp3[0]==p[0,0,0,0,0,0]):
      global wv_wp2 = feature_offset(wv_wp1,p[wv_weldpar[0]/1000,0,0,0,0,0],wv_Line_Feature2)
    else:
      global wv_wp2 = wv_wp4[0]
      wv_weldpar[0] = point_dist(wv_wp1,wv_wp2)*1000
      global wv_dist_bak = point_dist(wv_wp1,wv_wp2)*1000
    end
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      wv_Line_Feature2 = wv_feature
    end
    #setting
    if(par_2f):
      #todo - 1
      offset_2f_k = -1 * ext_fun[9]
      offset_2f_z = 1 * ext_fun[10]
      if(wv_seq[0] == 0 or wv_seq[0] == 1):
        line_feature = get_feature_Line(wv_wp1,wv_wp2)
        b_p1 = wv_wp1
        b_p2 = feature_offset(wv_wp1,p[0,0.01*vir_v,0,0,0,0],line_feature)
        b_p3 = pose_add(wv_wp1,p[0,0,0.01,0,0,0])
  
        back_feature = get_feature_plane_xz(b_p1,b_p2,b_p3)
        wv_wp1 = pose_trans(wv_wp1,p[0,0,0,0,0,d2r(-90)])
        wv_wp1 = feature_offset(wv_wp1,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp1 = pose_add(wv_wp1,p[0,0,offset_2f_z/1000,0,0,0])
        # wv_wp1 = pose_add(wv_wp1,p[offset_2f_k/1000,0,0,0,0,0])
      end
        # wv_wp2 = pose_add(wv_wp2,p[offset_2f_k/1000,0,0,0,0,0])
        wv_wp2 = feature_offset(wv_wp2,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp2 = pose_add(wv_wp2,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp2 = p[wv_wp2[0],wv_wp2[1],wv_wp2[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[0],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[0] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[1],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[1] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[2],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[2] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
    end
    if(ext_fun[2]==1 and par_2f==False):
      #squash
      w_voltage = ext_fun[3]
      w_current = ext_fun[4]
      set_current_voltage(w_current,w_voltage)
      global cir_speed_org_bak = wv_weldpar[1]
      global wving_amplitude_bak = wv_weldpar[4]
      wv_weldpar[1] = ext_fun[6]
      wv_weldpar[4] = ext_fun[5]
    end
    if(par_2f):
      global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
    else:
      global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay)
      x_radius = x_radius / 1000
    end
    global wv_set_speed = wv_system_speed
    ratio_t=0
    # mm -> m
    global y_radius = y_radius / 1000
    global y_radius_bak = y_radius
    #init for thread
    global ext_stick = 0
    global th_arc_sen=Arc_sen
    global th_wv_gap=wv_gap
    global th_tilt_deg=tilt_deg
    global last_tilt_deg =th_tilt_deg
    global last_wv_wp1 = wv_wp1
    global last_wv_line = wv_Line_Feature2
    global th_wving_crater=wving_crater
    global last_z_bottom = z_bottom
    global th_par_2f = par_2f
    global th_cir_speed_org=wv_weldpar[1]
    global th_wv_wp1 = wv_wp1
    global th_wv_wp2 = wv_wp2
    global th_wv_wp3 = wv_wp3[0]
    global th_wv_weldpar=wv_weldpar
    global th_wving_delay=wving_delay
    global th_z_param=z_param
    global th_wv_seq = wv_seq
    global th_wv_feature=wv_feature
    global th_dir = dir
  
    # if want to use approach position
    if(wv_seq[0] ==0 or wv_seq[0] == 1):
      global get_angle_rx = welding_angle_cal_2f(wv_wp1[1],tilt_deg,vir_v,cal_off_ang_rx)
      global get_angle_ry = welding_angle_cal_3f(wv_wp1[2],tilt_deg,z_bottom,cal_off_ang_ry)
  
      target_p = feature_offset(wv_wp1,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],wv_Line_Feature2)
  
      if(wv_weldpar[2]==1):
        target_p_appr = feature_offset(target_p,p[0,0,-0.02,0,0,0],wv_Line_Feature2)
        movel(target_p_appr,a=0.5,v=0.125)
      end
      movel(target_p,a=0.5,v=0.125)
    end
  
    CThread = run CalThread()
    DThread = run diff_Thread()
    TThread = run thread_timer()
    global timer_counting=True
    global program_weld_on = True
  
    if(a9_wv_weldingon==True):
      while(welding_off_t==55):
        sync()
      end
      if(wving_crater[2]>0):
        set_current_voltage(wving_crater[0],wving_crater[1])
      end
      if(welding_off_t != 1):
        write_welder(0,True)
        while(get_wcr==False):
          if(weld_onoff==False):
            write_welder(0,True)
          end
          sync()
        end
        if(wving_crater[2]>0):
          #Crater Begin option
          write_output_float_register(1,1)
          sleep(wving_crater[2])
          set_current_voltage(ext_fun[1],ext_fun[0])
        end
      end
    end
    start_gas_time = 0
  
    background_cal=1
    background_ready=0
    FT_trig=True
  
    timer_1_is_counting = True
  
    while((ratio_t < 1) or current_list==0 or current_list==1):
      if(ratio_t>=1 and current_list!=2):
        if (gap_check):
          gap_check = True
          wv_gap[0]=1
          th_wv_gap[0]=1
          gap_check= False
        end
        ratio_t=0
        if(current_list==0):
          wving_amp_bak = wv_weldpar[4]
          wv_weldpar[4] = wv_weldpar[4] * 1
          th_wv_weldpar[4] = wv_weldpar[4]
          circle_speed_bak = wv_weldpar[1]
          wv_weldpar[1]= wv_weldpar[1]*0.7
          th_wv_weldpar[1]= wv_weldpar[1]
        elif(current_list==1):
          wv_weldpar[4] = wving_amp_bak
          th_wv_weldpar[4] = wv_weldpar[4]
          wv_weldpar[1] = circle_speed_bak
          th_wv_weldpar[1]= wv_weldpar[1]
        end
        wv_wp1=wv_wp4[current_list]
        wv_wp2=wv_wp4[current_list+1]
        global th_wv_wp1 = wv_wp4[current_list]
        global th_wv_wp2 = wv_wp4[current_list+1]
        global th_wv_wp3 = wv_wp4[current_list+1]
        wv_system_speed_bak = wv_system_speed
        if(par_2f):
          global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp4[current_list],wv_wp4[current_list+1],wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
          global y_radius = y_radius / 1000
          global y_radius_bak = y_radius
        else:
          global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp4[current_list],wv_wp4[current_list+1],wv_weldpar[1],wv_weldpar[3],wving_delay)
          x_radius = x_radius / 1000
        end
        wv_system_speed = wv_system_speed_bak
        current_list=current_list+1
      end
      if((norm(tri_count)>=2 or (FT_trig==True))):
        FT_trig = False
        while(background_ready==0):
          sync()
        end
        tri_count = 0
        background_ready = 0
        global move_p = background_pose
        wv_wp2 = th_wv_wp2
        if(par_2f):
          background_cal=1
        else:
          background_cal=1
        end
        global a_val = 3
        if(a_val >= 30):
          write_port_register(142,112)
          sleep(0.5)
          halt
        end
      end
  
      if(wv_weldpar[5] ==1):
          if( (sin_dir==1 and wving_delay[0]==0) or (sin_dir==-1 and wving_delay[2]==0)):
           tri_count = tri_count + 1
          end
          global target_p = move_p[tri_count]
          target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
          tri_count = tri_count + 1
      elif(wv_weldpar[5] ==2):
        if( (tri_count==1 and sin_dir==1 and wving_delay[0]==0) or (tri_count==1 and sin_dir==-1 and wving_delay[2]==0)):
         tri_count = tri_count + 1
        end
        global target_p = move_p[tri_count]
        target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
        tri_count = tri_count + 1
      else:
        popup("Please insert 0 - sin or 1 - triangle")
      end
  
      if(target_p == p[0,0,0,0,0,0]):
        target_p = get_actual_tcp_pose()
      end
      if((norm(tri_count)== 1) and sin_dir==1 and wving_delay[0]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[0])
      elif((norm(tri_count)== 2) and sin_dir==1 and wving_delay[1]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[1])
        peak_value = 100
      elif((norm(tri_count)== 1) and sin_dir==-1 and wving_delay[2]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[2])
      elif((norm(tri_count)== 2) and sin_dir==-1 and wving_delay[3]>0):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[3])
        peak_value = 100
      else:
        movel(target_p,a=a_val,v=wv_system_speed/1000)
      end
      global last_pose = target_p
    end
    timer_1_is_counting = False
    welding_program = True
    if(a9_wv_weldingon == True and wving_crater[5]!=0):
      #crater end option
      set_current_voltage(wving_crater[3],wving_crater[4])
      sleep(wving_crater[5])
      program_weld_on = False
      set_current_voltage(ext_fun[1],ext_fun[0])
      if(isHicomm):
        write_port_register(202,0)
        write_port_register(149,0)
      else:
        set_standard_digital_out(0,False)
      end
      while(get_wcr==True):
        if(weld_onoff==True):
          if(isHicomm):
            write_port_register(202,0)
            write_port_register(149,0)
          else:
            set_standard_digital_out(0,False)
          end
        end
        sync()
      end
    end
  
    kill CThread
    kill DThread
    kill TThread
    timer_counting = False
    wcr_counter = 0
    wcr_counting = False
    get_wcr = False
    welding_off_t = 0
  
    if(wv_seq[0] == 0 or wv_seq[0] == 3):
      if(a9_wv_weldingon==True):
        program_weld_on = False
        if(isHicomm):
          write_port_register(202,0)
          write_port_register(149,0)
        else:
          set_standard_digital_out(0,False)
        end
        if(wv_weldpar[2]==1):
          target_pos = feature_offset(get_actual_tcp_pose(),p[0,0,-0.01,0,0,0],wv_Line_Feature2)
          movel(target_pos,0.5,0.01)
        end
      end
    end
    background_pose = [dumy_p,dumy_p,dumy_p]
    move_p = background_pose
    return sin_dir
  end
  $ 147 "Reset"
  $ 148 "If Reset_Trig"
  if (Reset_Trig):
    $ 149 "Reset_Trig≔ False "
    global Reset_Trig=  False  
    $ 150 "Call robotand_cell_initalizat"
    robotand_cell_initalizat()
    $ 151 "Auto_trig≔ False "
    global Auto_trig=  False  
    $ 152 "write_port_register(cell_3f_2f_151,0)"
    write_port_register(cell_3f_2f_151,0)
    $ 153 "write_port_register(cell_info_152,0)"
    write_port_register(cell_info_152,0)
    $ 154 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 155 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 156 "write_port_register(robot_move_163,0)"
    write_port_register(robot_move_163,0)
    $ 157 "write_port_register(robot_pose_164,0)"
    write_port_register(robot_pose_164,0)
    $ 158 "write_port_register(182,0)"
    write_port_register(182,0)
    $ 159 "write_port_register(185,0)"
    write_port_register(185,0)
    $ 160 "write_port_register(201,0)"
    write_port_register(201,0)
    $ 161 "write_port_register(202,0)"
    write_port_register(202,0)
  end
  $ 162 "Welding_Init"
  $ 163 "'welding parameter initialization'"
  # 'welding parameter initialization'
  $ 164 "welding_etc"
  $ 192 "c5_wv_gap_y≔0"
  global c5_wv_gap_y=0
  $ 193 "c6_wv_gap_cpm≔0"
  global c6_wv_gap_cpm=0
  $ 194 "c9_wv_gap_freq≔0"
  global c9_wv_gap_freq=0
  $ 195 "c4_gap_enable≔0"
  global c4_gap_enable=0
  $ 196 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
  global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
  $ 197 "init_reset_modbus_server"
  $ 198 "set_tool_voltage(24)"
  set_tool_voltage(24)
  $ 199 "write_port_register(163,0)"
  write_port_register(163,0)
  $ 200 "write_port_register(164,0)"
  write_port_register(164,0)
  $ 202 "write_port_register(201,1)"
  write_port_register(201,1)
  $ 203 "write_port_register(202,0)"
  write_port_register(202,0)
  $ 1257 "Thread_2"
  thread Thread_2():
    while (True):
      $ 1258 "heartbeat≔heartbeat+1"
      global heartbeat=heartbeat+1
      $ 1259 "If heartbeat>499"
      if (heartbeat>499):
        $ 1260 "heartbeat≔0"
        global heartbeat=0
      end
      $ 1261 "write_port_register(128,heartbeat)"
      write_port_register(128,heartbeat)
      $ 1271 "Wait: 1.0"
      sleep(1.0)
    end
  end
  threadId_Thread_2 = run Thread_2()
  $ 1272 "Thread_1"
  thread Thread_1():
    while (True):
      $ 1273 "a0_Job_Mode≔read_port_register(162)"
      global a0_Job_Mode= read_port_register (162)
      $ 1274 "a1_job_move≔read_port_register(163)"
      global a1_job_move= read_port_register (163)
      $ 1275 "If red_led≟ True "
      if (get_tool_digital_out(0) ==   True  ):
        $ 1276 "Set red_led=Off"
        set_tool_digital_out(0, False)
      end
      $ 1277 "If a0_Job_Mode≟2"
      if (a0_Job_Mode == 2):
        $ 1278 "If read_port_register(arc_onoff_168)≟2"
        if ( read_port_register (arc_onoff_168) == 2):
          $ 1279 "a9_wv_weldingon≔ True "
          global a9_wv_weldingon=  True  
        else:
          $ 1280 "Else" "noBreak"
          $ 1281 "a9_wv_weldingon≔ False "
          global a9_wv_weldingon=  False  
        end
        $ 1282 "If Auto_trig"
        if (Auto_trig):
          $ 1283 "get_next_number≔read_port_register(166)"
          global get_next_number= read_port_register (166)
          $ 1284 "get_move_trig≔read_port_register(167)"
          global get_move_trig= read_port_register (167)
          $ 1285 "If get_move_trig≟1 and running_trig≟ True "
          if (get_move_trig == 1  and  running_trig ==   True  ):
            $ 1286 "If get_next_number<0 or get_next_number>30"
            if (get_next_number<0  or  get_next_number>30):
              $ 1287 "write_port_register(142,141)"
              write_port_register(142,141)
              $ 1288 "Halt"
              halt
            end
            $ 1289 "If get_next_number≠Auto_cur_cell"
            if (get_next_number != Auto_cur_cell):
              $ 1290 "running_trig≔ False "
              global running_trig=  False  
              $ 1291 "write_welder(0, False )"
              write_welder(0,  False  )
              $ 1292 "write_port_register(149,0)"
              write_port_register(149,0)
              $ 1293 "write_port_register(202,0)"
              write_port_register(202,0)
            else:
              $ 1294 "Else" "noBreak"
              $ 1295 "write_port_register(166,0)"
              write_port_register(166,0)
              $ 1296 "write_port_register(167,0)"
              write_port_register(167,0)
            end
          end
        end
        $ 1297 "If t_time>timer_1"
        if (t_time>timer_1):
          $ 1298 "write_port_register(143,timer_1)"
          write_port_register(143,timer_1)
        else:
          $ 1299 "Else" "noBreak"
          $ 1300 "write_port_register(143,timer_1)"
          write_port_register(143,timer_1)
          $ 1301 "write_port_register(144,timer_1)"
          write_port_register(144,timer_1)
        end
        $ 1302 "Monitoring touch and welding"
        $ 1303 "If read_welder_control(0) and read_port_register(130)≠1"
        if (read_welder_control(0)  and   read_port_register (130) != 1):
          $ 1304 "write_port_register(130,1)"
          write_port_register(130,1)
        else:
          $ 1305 "ElseIf read_welder_control(0) and read_port_register(130)≠0"
          if (read_welder_control(0)  and   read_port_register (130) != 0):
            $ 1306 "write_port_register(130,0)"
            write_port_register(130,0)
          end
        end
        $ 1307 "If read_welder(5)"
        if (read_welder(5)):
          $ 1308 "'check wcr in (digital)'"
          # 'check wcr in (digital)'
          $ 1309 "write_output_float_register(20,1)"
          write_output_float_register(20,1)
        else:
          $ 1310 "Else" "noBreak"
          $ 1311 "write_output_float_register(20,0)"
          write_output_float_register(20,0)
        end
        $ 1312 "If read_welder(4)"
        if (read_welder(4)):
          $ 1313 "'check touch (digital)'"
          # 'check touch (digital)'
          $ 1314 "write_output_float_register(21,1)"
          write_output_float_register(21,1)
        else:
          $ 1315 "Else" "noBreak"
          $ 1316 "write_output_float_register(21,0)"
          write_output_float_register(21,0)
        end
        $ 1317 "If read_welder_control(0)"
        if (read_welder_control(0)):
          $ 1318 "'check welding out (digital)'"
          # 'check welding out (digital)'
          $ 1319 "write_output_float_register(17,1)"
          write_output_float_register(17,1)
        else:
          $ 1320 "Else" "noBreak"
          $ 1321 "write_output_float_register(17,0)"
          write_output_float_register(17,0)
        end
        $ 1322 "If read_welder_control(4)"
        if (read_welder_control(4)):
          $ 1323 "'check touch out (digital)'"
          # 'check touch out (digital)'
          $ 1324 "write_output_float_register(18,1)"
          write_output_float_register(18,1)
        else:
          $ 1325 "Else" "noBreak"
          $ 1326 "write_output_float_register(18,0)"
          write_output_float_register(18,0)
        end
      end
      $ 1327 "If get_tool_digital_in(1)≟ True "
      if (get_tool_digital_in(1) ==   True  ):
        $ 1328 "set_tool_digital_out(1, False )"
        set_tool_digital_out(1,  False  )
      else:
        $ 1329 "Else" "noBreak"
        $ 1330 "set_tool_digital_out(1, True )"
        set_tool_digital_out(1,  True  )
      end
      $ 1331 "If red_led≟ True "
      if (get_tool_digital_out(0) ==   True  ):
        $ 1332 "Set red_led=Off"
        set_tool_digital_out(0, False)
        $ 1333 "end_freedrive_mode()"
        end_freedrive_mode()
      end
      $ 1334 "check_speed()"
      check_speed()
      $ 1335 "Wait: 0.05"
      sleep(0.05)
    end
  end
  threadId_Thread_1 = run Thread_1()
  thread EventThread():
    while (True):
      if (event_cal_on):
        $ 1339 "move_i_f≔1"
        global move_i_f=1
        $ 1340 "get_pose_side≔0"
        global get_pose_side=0
        $ 1341 "Loop move_i_f<10"
        while (move_i_f<10):
          $ 1342 "If A_Touch_trig_l[move_i_f]≟ True "
          if (A_Touch_trig_l[move_i_f] ==   True  ):
            $ 1343 "If move_i_f≟A_VL1 or move_i_f≟A_VL2"
            if (move_i_f == A_VL1  or  move_i_f == A_VL2):
              $ 1344 "A_sel_v≔move_i_f"
              global A_sel_v=move_i_f
              $ 1345 "If simulation_mode"
              if (simulation_mode):
                $ 1346 "Call welding_parameter_sim"
                welding_parameter_sim()
              else:
                $ 1347 "Else" "noBreak"
                $ 1348 "Call welding_parameter_init"
                welding_parameter_init()
              end
              $ 1349 "If a8_wv_distance<5"
              if (a8_wv_distance<5):
                $ 1350 "write_port_register(142,143)"
                write_port_register(142,143)
                $ 1351 "Halt"
                halt
              end
              $ 1352 "b2_left_par≔ True "
              global b2_left_par=  True  
              $ 1353 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 1354 "If move_i_f≟A_VL2"
              if (move_i_f == A_VL2):
                $ 1355 "callar_hor≔a6_callar_hor"
                global callar_hor=a6_callar_hor
                $ 1356 "b2_cell≔0"
                global b2_cell=0
                $ 1357 "If b1_cell_info_L≟c or b1_cell_info_L≟d or b1_cell_info_L≟E or b1_cell_info_L≟e"
                if (b1_cell_info_L == c  or  b1_cell_info_L == d  or  b1_cell_info_L == E  or  b1_cell_info_L == e):
                  $ 1358 "b2_cell≔b1_cell_info_L"
                  global b2_cell=b1_cell_info_L
                else:
                  $ 1359 "Else" "noBreak"
                  $ 1360 "b2_cell≔0"
                  global b2_cell=0
                end
              else:
                $ 1361 "Else" "noBreak"
                $ 1362 "callar_hor≔0"
                global callar_hor=0
                $ 1363 "b2_cell≔b1_cell_info_L"
                global b2_cell=b1_cell_info_L
              end
              $ 1364 "get_pos≔get_lr(left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)"
              global get_pos=get_lr(p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)
              $ 1365 "pre_tp≔tilt_3f_fun(get_pos,[0,0,0],0)"
              global pre_tp=tilt_3f_fun(get_pos,[0,0,0],0)
              $ 1366 "A_Prepos_l[move_i_f]=pre_tp"
              A_Prepos_l[move_i_f]=pre_tp
            else:
              $ 1367 "ElseIf move_i_f≟A_VR1 or move_i_f≟A_VR2"
              if (move_i_f == A_VR1  or  move_i_f == A_VR2):
                $ 1368 "A_sel_v≔move_i_f"
                global A_sel_v=move_i_f
                $ 1369 "If simulation_mode"
                if (simulation_mode):
                  $ 1370 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1371 "Else" "noBreak"
                  $ 1372 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1373 "If a8_wv_distance<5"
                if (a8_wv_distance<5):
                  $ 1374 "write_port_register(142,143)"
                  write_port_register(142,143)
                  $ 1375 "Halt"
                  halt
                end
                $ 1376 "b2_left_par≔ False "
                global b2_left_par=  False  
                $ 1377 "b8_wv_2f≔ False "
                global b8_wv_2f=  False  
                $ 1378 "If move_i_f≟A_VR2"
                if (move_i_f == A_VR2):
                  $ 1379 "callar_hor≔a6_callar_hor"
                  global callar_hor=a6_callar_hor
                  $ 1380 "If b1_cell_info_R≟c or b1_cell_info_R≟d or b1_cell_info_R≟E or b1_cell_info_R≟e"
                  if (b1_cell_info_R == c  or  b1_cell_info_R == d  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
                    $ 1381 "b2_cell≔b1_cell_info_R"
                    global b2_cell=b1_cell_info_R
                  else:
                    $ 1382 "Else" "noBreak"
                    $ 1383 "b2_cell≔0"
                    global b2_cell=0
                  end
                else:
                  $ 1384 "Else" "noBreak"
                  $ 1385 "callar_hor≔0"
                  global callar_hor=0
                  $ 1386 "b2_cell≔b1_cell_info_R"
                  global b2_cell=b1_cell_info_R
                end
                $ 1387 "get_pos≔get_lr(right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)"
                global get_pos=get_lr(p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)
                $ 1388 "pre_tp≔tilt_3f_fun(get_pos,[0,0,0],0)"
                global pre_tp=tilt_3f_fun(get_pos,[0,0,0],0)
                $ 1389 "A_Prepos_l[move_i_f]=pre_tp"
                A_Prepos_l[move_i_f]=pre_tp
              else:
                $ 1390 "ElseIf move_i_f≟A_HOR"
                if (move_i_f == A_HOR):
                  $ 1391 "A_sel_v≔A_HOR"
                  global A_sel_v=A_HOR
                  $ 1392 "If simulation_mode"
                  if (simulation_mode):
                    $ 1393 "Call welding_parameter_sim"
                    welding_parameter_sim()
                  else:
                    $ 1394 "Else" "noBreak"
                    $ 1395 "Call welding_parameter_init"
                    welding_parameter_init()
                  end
                  $ 1396 "b8_wv_2f≔ True "
                  global b8_wv_2f=  True  
                  $ 1397 "b2_left_par≔ True "
                  global b2_left_par=  True  
                  $ 1398 "b2_cell≔b1_cell_info_L"
                  global b2_cell=b1_cell_info_L
                  $ 1399 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)"
                  global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)
                  $ 1400 "pre_tp≔get_pos"
                  global pre_tp=get_pos
                  $ 1401 "A_Prepos_l[move_i_f]=pre_tp"
                  A_Prepos_l[move_i_f]=pre_tp
                else:
                  $ 1402 "ElseIf move_i_f≟A_HOR_R"
                  if (move_i_f == A_HOR_R):
                    $ 1403 "A_sel_v≔A_HOR"
                    global A_sel_v=A_HOR
                    $ 1404 "If simulation_mode"
                    if (simulation_mode):
                      $ 1405 "Call welding_parameter_sim"
                      welding_parameter_sim()
                    else:
                      $ 1406 "Else" "noBreak"
                      $ 1407 "Call welding_parameter_init"
                      welding_parameter_init()
                    end
                    $ 1408 "b2_left_par≔ False "
                    global b2_left_par=  False  
                    $ 1409 "b8_wv_2f≔ True "
                    global b8_wv_2f=  True  
                    $ 1410 "b2_cell≔b1_cell_info_R"
                    global b2_cell=b1_cell_info_R
                    $ 1411 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)"
                    global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)
                    $ 1412 "pre_tp≔get_pos"
                    global pre_tp=get_pos
                    $ 1413 "A_Prepos_l[move_i_f]=pre_tp"
                    A_Prepos_l[move_i_f]=pre_tp
                  else:
                    $ 1414 "ElseIf move_i_f≟A_HOR_ML"
                    if (move_i_f == A_HOR_ML):
                      $ 1415 "A_sel_v≔A_HOR_ML"
                      global A_sel_v=A_HOR_ML
                      $ 1416 "If simulation_mode"
                      if (simulation_mode):
                        $ 1417 "Call welding_parameter_sim"
                        welding_parameter_sim()
                      else:
                        $ 1418 "Else" "noBreak"
                        $ 1419 "Call welding_parameter_init"
                        welding_parameter_init()
                      end
                      $ 1420 "b8_wv_2f≔ True "
                      global b8_wv_2f=  True  
                      $ 1421 "b2_left_par≔ True "
                      global b2_left_par=  True  
                      $ 1422 "b2_cell≔b1_cell_info_L"
                      global b2_cell=b1_cell_info_L
                      $ 1423 "Touch_dis≔-1*Touch_dis"
                      global Touch_dis=-1*Touch_dis
                      $ 1424 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)"
                      global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)
                      $ 1425 "Touch_dis≔-1*Touch_dis"
                      global Touch_dis=-1*Touch_dis
                      $ 1426 "pre_tp≔get_pos"
                      global pre_tp=get_pos
                      $ 1427 "A_Prepos_l[move_i_f]=pre_tp"
                      A_Prepos_l[move_i_f]=pre_tp
                    else:
                      $ 1428 "ElseIf move_i_f≟A_HOR_MR"
                      if (move_i_f == A_HOR_MR):
                        $ 1429 "A_sel_v≔A_HOR_MR"
                        global A_sel_v=A_HOR_MR
                        $ 1430 "If simulation_mode"
                        if (simulation_mode):
                          $ 1431 "Call welding_parameter_sim"
                          welding_parameter_sim()
                        else:
                          $ 1432 "Else" "noBreak"
                          $ 1433 "Call welding_parameter_init"
                          welding_parameter_init()
                        end
                        $ 1434 "b2_left_par≔ False "
                        global b2_left_par=  False  
                        $ 1435 "b8_wv_2f≔ True "
                        global b8_wv_2f=  True  
                        $ 1436 "b2_cell≔b1_cell_info_R"
                        global b2_cell=b1_cell_info_R
                        $ 1437 "Touch_dis≔-1*Touch_dis"
                        global Touch_dis=-1*Touch_dis
                        $ 1438 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)"
                        global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)
                        $ 1439 "Touch_dis≔-1*Touch_dis"
                        global Touch_dis=-1*Touch_dis
                        $ 1440 "pre_tp≔get_pos"
                        global pre_tp=get_pos
                        $ 1441 "A_Prepos_l[move_i_f]=pre_tp"
                        A_Prepos_l[move_i_f]=pre_tp
                      end
                    end
                  end
                end
              end
            end
            $ 1442 "If move_i_f≤4"
            if (move_i_f <= 4):
              $ 1443 "A_Prepos_l[move_i_f+9]=p[0,0,0,0,0,0]"
              A_Prepos_l[move_i_f+9]=p[0,0,0,0,0,0]
            end
          end
          $ 1446 "move_i_f≔move_i_f+1"
          global move_i_f=move_i_f+1
        end
        $ 1447 "event_cal_on≔ False "
        global event_cal_on=  False  
      elif (event_side_on):
        $ 1451 "Wait event_cal_on≟ False "
        while (not(event_cal_on ==   False  )):
          sync()
        end
        $ 1452 "move_i_f≔1"
        global move_i_f=1
        $ 1453 "get_pose_side≔get_pose_side_t"
        global get_pose_side=get_pose_side_t
        $ 1454 "Loop move_i_f<10"
        while (move_i_f<10):
          $ 1455 "If A_Touch_trig_l[move_i_f]≟ True "
          if (A_Touch_trig_l[move_i_f] ==   True  ):
            $ 1456 "If move_i_f≟A_VL1 or move_i_f≟A_VL2"
            if (move_i_f == A_VL1  or  move_i_f == A_VL2):
              $ 1457 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
              A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
            else:
              $ 1458 "ElseIf move_i_f≟A_VR1 or move_i_f≟A_VR2"
              if (move_i_f == A_VR1  or  move_i_f == A_VR2):
                $ 1459 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
              else:
                $ 1460 "ElseIf move_i_f≟A_HOR"
                if (move_i_f == A_HOR):
                  $ 1461 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                  A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                else:
                  $ 1462 "ElseIf move_i_f≟A_HOR_R"
                  if (move_i_f == A_HOR_R):
                    $ 1463 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                    A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                  else:
                    $ 1464 "ElseIf move_i_f≟A_HOR_ML"
                    if (move_i_f == A_HOR_ML):
                      $ 1465 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                      A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                    else:
                      $ 1466 "ElseIf move_i_f≟A_HOR_MR"
                      if (move_i_f == A_HOR_MR):
                        $ 1467 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                        A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                      end
                    end
                  end
                end
              end
            end
          end
          $ 1468 "move_i_f≔move_i_f+1"
          global move_i_f=move_i_f+1
        end
        $ 1469 "event_side_on≔ False "
        global event_side_on=  False  
      elif (reset_trig):
        $ 1471 "Call reset_weld_param"
        reset_weld_param()
        $ 1472 "reset_trig≔ False "
        global reset_trig=  False  
      elif (time_cal_trig):
        $ 1474 "t_time≔time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,0)"
        global t_time=time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,0)
        $ 1475 "write_port_register(144,t_time)"
        write_port_register(144,t_time)
        $ 1476 "time_cal_trig≔ False "
        global time_cal_trig=  False  
      elif (pause_trig):
        $ 1478 "s_conn≔socket_open('192.168.1.7',29999)"
        global s_conn=socket_open("192.168.1.7",29999)
        $ 1479 "s_send≔socket_send_string('pause')"
        global s_send=socket_send_string("pause")
        $ 1480 "s_send≔socket_send_byte(10)"
        global s_send=socket_send_byte(10)
        $ 1481 "socket_close()"
        socket_close()
        $ 1482 "pause_trig≔ False "
        global pause_trig=  False  
      end
      sync()
    end
  end
  eventThread = run EventThread()
  while (True):
    $ 204 "Robot Program"
    $ 222 "If simulation_mode"
    if (simulation_mode):
      $ 223 "'work mode 2'"
      # 'work mode 2'
      $ 224 "write_port_register(162,2)"
      write_port_register(162,2)
      $ 225 "touch_temp≔0"
      global touch_temp=0
    end
    $ 226 "If a0_Job_Mode≟1"
    if (a0_Job_Mode == 1):
      $ 227 "job mode 1"
      $ 228 "'JOB_MANUAL'"
      # 'JOB_MANUAL'
      $ 229 "write_port_register(robot_ready_141,1)"
      write_port_register(robot_ready_141,1)
      $ 230 "If freedrive≟ True  and freedrive_trg≟ False "
      if (get_tool_digital_in(1) ==   True    and  freedrive_trg ==   False  ):
        $ 231 "freedrive_trg≔ True "
        global freedrive_trg=  True  
        $ 232 "freedrive_mode()"
        freedrive_mode()
      else:
        $ 233 "ElseIf freedrive≟ False  and freedrive_trg≟ True "
        if (get_tool_digital_in(1) ==   False    and  freedrive_trg ==   True  ):
          $ 234 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 235 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
      end
      $ 239 "If freedrive≟ True  and save_tool≟ True "
      if (get_tool_digital_in(1) ==   True    and  get_tool_digital_in(0) ==   True  ):
        $ 243 "Wait: 0.01"
        sleep(0.01)
      else:
        $ 244 "ElseIf a1_job_move≟1"
        if (a1_job_move == 1):
          $ 245 "'Manual - Move Home/Packing/Warmup'"
          # 'Manual - Move Home/Packing/Warmup'
          $ 246 "If read_port_register(robot_pose_164)≟1"
          if ( read_port_register (robot_pose_164) == 1):
            $ 247 "write_port_register(robot_ready_141,0)"
            write_port_register(robot_ready_141,0)
            $ 248 "homeing()"
            homeing()
            $ 249 "MoveJ"
            $ 250 "Packing_pos" "breakAfter"
            movej([1.5877798795700073, -0.0173419157611292, -2.4983108679400843, -1.4065726439105433, 1.626846194267273, 3.0169763565063477], a=0.9599310885968813, v=0.9599310885968813)
          else:
            $ 251 "ElseIf read_port_register(robot_pose_164)≟2"
            if ( read_port_register (robot_pose_164) == 2):
              $ 252 "write_port_register(robot_ready_141,0)"
              write_port_register(robot_ready_141,0)
              $ 253 "homeing()"
              homeing()
            else:
              $ 254 "ElseIf read_port_register(robot_pose_164)≟3"
              global thread_flag_254=0
              thread Thread_if_254():
                $ 255 "write_port_register(robot_ready_141,0)"
                write_port_register(robot_ready_141,0)
                $ 256 "Warm-up"
                $ 257 "Loop 22 times"
                Loop_9 = 0
                while (Loop_9 < 22):
                  $ 258 "MoveJ"
                  $ 259 "Warming_1" "breakAfter"
                  movej([1.3388409470167426, -1.0894445773085817, -1.21578769245379, -2.340308120379028, 1.4975742894997062, 2.3546781160711117], a=0.5235987755982988, v=0.2617993877991494)
                  $ 260 "Warming_2" "breakAfter"
                  movej([0.3765170846483107, -1.0894466320678031, -1.215768207322279, -2.3402268007341895, 1.4977834941028334, 2.3545507363355367], a=0.5235987755982988, v=0.2617993877991494)
                  $ 261 "Warming_3" "breakAfter"
                  movej([0.70229908534082, -1.0894474234917375, -1.2158576930717002, -2.340314378048955, 1.497725846219038, 2.3545705560997385], a=0.5235987755982988, v=0.2617993877991494)
                  $ 262 "Warming_4" "breakAfter"
                  movej([0.7262700130956564, -1.3120291852612347, -1.2099656497338014, -2.3525900953229293, 1.4887798341942113, 2.3787312683819053], a=0.5235987755982988, v=0.2617993877991494)
                  $ 263 "Wariming_5" "breakAfter"
                  movej([0.6926726182060315, -1.0476106481659855, -1.2179788018883642, -2.3355421428203886, 1.501172277634622, 2.3452576869092923], a=0.5235987755982988, v=0.2617993877991494)
                  $ 264 "Warming_6" "breakAfter"
                  movej([0.706544616734295, -1.047040496424307, -1.4190888321133315, -2.3436933501169452, 1.4896422361111494, 2.359727124413684], a=0.5235987755982988, v=0.2617993877991494)
                  $ 265 "Warming_7" "breakAfter"
                  movej([0.6929880468286825, -1.0476354157293724, -1.2203987593812862, -2.335678707355349, 1.5010671072282735, 2.34550338764565], a=0.5235987755982988, v=0.2617993877991494)
                  $ 266 "Warming_8" "breakAfter"
                  movej([0.6920775233962951, -1.0506328608604214, -1.2152130579572011, -2.5072867131215766, 1.4917910996963177, 2.3459413556024855], a=0.5235987755982988, v=0.2617993877991494)
                  $ 267 "Warming_9" "breakAfter"
                  movej([0.692933302781529, -1.0474869681006531, -1.2206503884398048, -2.327559666709858, 1.5015191668476027, 2.3454614641680087], a=0.5235987755982988, v=0.2617993877991494)
                  $ 268 "Warming_10" "breakAfter"
                  movej([0.7189566793816887, -1.1462083943843844, -1.3286482352122917, -2.3898368690561114, 1.223390234561962, 2.3705741030878644], a=0.5235987755982988, v=0.2617993877991494)
                  $ 269 "Warming_11" "breakAfter"
                  movej([0.6952417412291937, -1.0226626805382075, -1.3187663864026051, -2.3852732107244847, 1.5281305955128988, 2.3484138521676003], a=0.5235987755982988, v=0.2617993877991494)
                  $ 270 "Warming_12" "breakAfter"
                  movej([0.6939658935868351, -1.0222541193887693, -1.3205060700309819, -2.4036431483224994, 1.8876292979334401, 2.3447872177861786], a=0.5235987755982988, v=0.2617993877991494)
                  $ 271 "Warming_13" "breakAfter"
                  movej([0.6855475262233561, -1.0389108716421376, -1.3163550590643318, -2.371185255756596, 1.5282046997566647, 1.6427118007650936], a=0.5235987755982988, v=0.2617993877991494)
                  $ 272 "Warming_14" "breakAfter"
                  movej([0.721349856763205, -1.0075982028648234, -1.3205933019427434, -2.399656340024448, 1.5281938267886401, 2.9170078642332813], a=0.5235987755982988, v=0.2617993877991494)
                  Loop_9 = Loop_9 + 1
                end
                $ 273 "homeing()"
                homeing()
                $ 274 "Wait: 2.0"
                sleep(2.0)
                thread_flag_254 = 1
              end
              if ( read_port_register (robot_pose_164) == 3):
                global thread_handler_254=run Thread_if_254()
                while (thread_flag_254 == 0):
                  if not( read_port_register (robot_pose_164) == 3):
                    kill thread_handler_254
                    thread_flag_254 = 2
                  else:
                    sync()
                  end
                end
              else:
                thread_flag_254 = 2
              end
              if (thread_flag_254 == 2):
                $ 275 "ElseIf read_port_register(robot_pose_164)≟4"
                if ( read_port_register (robot_pose_164) == 4):
                  $ 276 "write_port_register(robot_ready_141,0)"
                  write_port_register(robot_ready_141,0)
                  $ 277 "homeing()"
                  homeing()
                  $ 278 "MoveJ"
                  $ 279 "pre_mounting" "breakAfter"
                  movej([1.2356762886047363, -0.8703244368182581, -0.942230526600973, -2.3905327955829065, 1.3216267824172974, 2.6514604091644287], a=0.7853981633974483, v=0.7853981633974483)
                  $ 280 "Mounting_pos" "breakAfter"
                  movej([0.6231353085164267, -0.6300961531972575, -0.9034285948871803, -1.770059340221131, 1.417516049558281, 1.7792033261567348], a=0.7853981633974483, v=0.7853981633974483)
                else:
                  $ 281 "ElseIf read_port_register(robot_pose_164)≟5"
                  if ( read_port_register (robot_pose_164) == 5):
                    $ 282 "c_p≔get_actual_tcp_pose()"
                    global c_p= get_actual_tcp_pose ()
                    $ 283 "MoveL"
                    $ 284 "m_p≔pose_trans(c_p, p[0,0,0,d2r(tilt_deg_man),0,0])"
                    global m_p= pose_trans (c_p, p[0,0,0,d2r(tilt_deg_man),0,0])
                    $ 285 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 286 "m_p≔pose_trans(c_p, p[0,0,0,d2r(-tilt_deg_man),0,0])"
                    global m_p= pose_trans (c_p, p[0,0,0,d2r(-tilt_deg_man),0,0])
                    $ 287 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 288 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                    $ 289 "m_p≔pose_trans(c_p, p[0,0,0,0,d2r(tilt_deg_man),0])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,d2r(tilt_deg_man),0])
                    $ 290 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 291 "m_p≔pose_trans(c_p, p[0,0,0,0,d2r(-tilt_deg_man),0])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,d2r(-tilt_deg_man),0])
                    $ 292 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 293 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                    $ 294 "m_p≔pose_trans(c_p, p[0,0,0,0,0,d2r(tilt_deg_man)])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,0,d2r(tilt_deg_man)])
                    $ 295 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 296 "m_p≔pose_trans(c_p, p[0,0,0,0,0,d2r(-tilt_deg_man)])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,0,d2r(-tilt_deg_man)])
                    $ 297 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 298 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                  end
                end
              end
            end
          end
          $ 299 "Call Move_done"
          Move_done()
        end
      end
      $ 300 "Call robotand_cell_initalizat"
      robotand_cell_initalizat()
    else:
      $ 301 "ElseIf a0_Job_Mode≟2"
      global thread_flag_301=0
      thread Thread_if_301():
        $ 302 "'JOB_AUTO'"
        # 'JOB_AUTO'
        $ 303 "auto_on≔ True "
        global auto_on=  True  
        $ 304 "Init"
        $ 305 "If freedrive_trg"
        if (freedrive_trg):
          $ 306 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 307 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
        $ 308 "write_port_register(202,0)"
        write_port_register(202,0)
        $ 309 "write_port_register(robot_ready_141,0)"
        write_port_register(robot_ready_141,0)
        $ 310 "homeing()"
        homeing()
        $ 311 "Wait: 0.2"
        sleep(0.2)
        $ 312 "Cell_calculation"
        $ 313 "'setting'"
        # 'setting'
        $ 314 "Auto_trig≔ False "
        global Auto_trig=  False  
        $ 315 "If Auto_trig≟ False "
        if (Auto_trig ==   False  ):
          $ 316 "If simulation_mode"
          if (simulation_mode):
            $ 317 "b1_cell_info_L≔B"
            global b1_cell_info_L=B
            $ 318 "b1_cell_info_R≔B"
            global b1_cell_info_R=B
            $ 319 "b1_cell_select≔motion_num([A_VL1,A_VR1,A_HOR,0,0,0])"
            global b1_cell_select=motion_num([A_VL1,A_VR1,A_HOR,0,0,0])
            $ 320 "b1_cell_select≔motion_num([A_HOR,0,0,0,0,0])"
            global b1_cell_select=motion_num([A_HOR,0,0,0,0,0])
            $ 321 "EXT_flag1≔integer_to_binary_list(read_port_register(2048))"
            global EXT_flag1= integer_to_binary_list ( read_port_register (2048))
            $ 322 "b1_cell_thickne≔6"
            global b1_cell_thickne=6
            $ 323 "A_Touch_trig_l≔touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)"
            global A_Touch_trig_l=touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)
            $ 324 "Auto_W_num≔cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)"
            global Auto_W_num=cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)
            $ 326 "Auto_total_cell≔cell_num(Auto_W_num)"
            global Auto_total_cell=cell_num(Auto_W_num)
            $ 327 "Auto_trig≔ True "
            global Auto_trig=  True  
            $ 328 "A_sel_v≔Auto_W_num[0]"
            global A_sel_v=Auto_W_num[0]
          else:
            $ 329 "Else" "noBreak"
            $ 330 "b1_cell_info_L≔read_port_register(171)"
            global b1_cell_info_L= read_port_register (171)
            $ 331 "b1_cell_info_R≔read_port_register(172)"
            global b1_cell_info_R= read_port_register (172)
            $ 332 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
            global EXT_flag1= integer_to_binary_list ( read_port_register (179))
            $ 333 "b1_cell_select≔read_port_register(178)"
            global b1_cell_select= read_port_register (178)
            $ 334 "b1_cell_thickne≔read_port_register(183)"
            global b1_cell_thickne= read_port_register (183)
            $ 335 "A_Touch_trig_l≔touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)"
            global A_Touch_trig_l=touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)
            $ 336 "Auto_W_num≔cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)"
            global Auto_W_num=cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)
            $ 337 "Auto_total_cell≔cell_num(Auto_W_num)"
            global Auto_total_cell=cell_num(Auto_W_num)
            $ 338 "Auto_trig≔ True "
            global Auto_trig=  True  
            $ 339 "A_sel_v≔Auto_W_num[0]"
            global A_sel_v=Auto_W_num[0]
          end
          $ 340 "write_port_register(139,Auto_total_cell-1)"
          write_port_register(139,Auto_total_cell-1)
        end
        $ 341 "Auto_cur_cell≔0"
        global Auto_cur_cell=0
        $ 342 "Touch,Welding"
        $ 343 "'Calculate total sequence and decide way'"
        # 'Calculate total sequence and decide way'
        $ 344 "Calculate & Move & Touch"
        $ 345 "touch_init"
        $ 346 "Call cell_info"
        cell_info()
        $ 347 "If simulation_mode"
        if (simulation_mode):
          $ 348 "Call welding_parameter_sim"
          welding_parameter_sim()
        else:
          $ 349 "Else" "noBreak"
          $ 350 "Call welding_parameter_init"
          welding_parameter_init()
          $ 351 "touch_temp≔read_port_register(180)"
          global touch_temp= read_port_register (180)
          $ 352 "A_cur_2f≔0"
          global A_cur_2f=0
          $ 353 "wv_direction≔1"
          global wv_direction=1
        end
        $ 354 "If touch_temp≟0"
        if (touch_temp == 0):
          $ 355 "reset Variable"
          $ 356 "A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]"
          A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]
          $ 357 "A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]"
          A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]
          $ 358 "reset_par"
          $ 359 "for_cal_rot≔p[0,0,0,0,0,0]"
          global for_cal_rot=p[0,0,0,0,0,0]
          $ 360 "for_cal_zr≔p[0,0,0,0,0,0]"
          global for_cal_zr=p[0,0,0,0,0,0]
          $ 361 "for_cal_zl≔p[0,0,0,0,0,0]"
          global for_cal_zl=p[0,0,0,0,0,0]
          $ 362 "for_cal_x_wel≔p[0,0,0,0,0,0]"
          global for_cal_x_wel=p[0,0,0,0,0,0]
          $ 363 "for_cal_xy≔p[0,0,0,0,0,0]"
          global for_cal_xy=p[0,0,0,0,0,0]
          $ 364 "for_cal_y_wel≔p[0,0,0,0,0,0]"
          global for_cal_y_wel=p[0,0,0,0,0,0]
          $ 365 "for_x_HOR≔p[0,0,0,0,0,0]"
          global for_x_HOR=p[0,0,0,0,0,0]
          $ 366 "for_x_HOR_R≔p[0,0,0,0,0,0]"
          global for_x_HOR_R=p[0,0,0,0,0,0]
          $ 367 "for_z_VL1≔p[0,0,0,0,0,0]"
          global for_z_VL1=p[0,0,0,0,0,0]
          $ 368 "for_z_VR1≔p[0,0,0,0,0,0]"
          global for_z_VR1=p[0,0,0,0,0,0]
        end
        $ 369 "write_port_register(143,0)"
        write_port_register(143,0)
        $ 370 "write_port_register(144,0)"
        write_port_register(144,0)
        $ 371 "timer_1: Reset"
        timer_1 = 0
        $ 372 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
        global EXT_flag1= integer_to_binary_list ( read_port_register (179))
        $ 374 "If touch_temp≟0"
        if (touch_temp == 0):
          $ 375 "write_port_register(138,0)"
          write_port_register(138,0)
          $ 376 "get_touch_position"
          $ 377 "get pre-positions"
          $ 378 "If read_port_register(work_type_165)≟2"
          if ( read_port_register (work_type_165) == 2):
            $ 379 "freedrive touch"
            $ 380 "move_i≔1"
            global move_i=1
            $ 381 "Loop move_i<9"
            while (move_i<9):
              $ 382 "Wait: 0.1"
              sleep(0.1)
              $ 383 "Wait save_tool=LO"
              while (get_tool_digital_in(0) == True):
                sync()
              end
              $ 384 "If A_Touch_trig_l[move_i]≟ True "
              if (A_Touch_trig_l[move_i] ==   True  ):
                $ 385 "If move_i≟A_HOR"
                if (move_i == A_HOR):
                  $ 386 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                  if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                    $ 387 "write_port_register(touch_cell_155,5)"
                    write_port_register(touch_cell_155,5)
                    $ 388 "write_port_register(touch_num_156,1)"
                    write_port_register(touch_num_156,1)
                    $ 389 "Call touch_sub"
                    touch_sub()
                    $ 390 "g_cp≔get_actual_tcp_pose()"
                    global g_cp= get_actual_tcp_pose ()
                    $ 391 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                    if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                      $ 392 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                      g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                    end
                    $ 393 "A_Prepos_l[move_i]=g_cp"
                    A_Prepos_l[move_i]=g_cp
                  end
                else:
                  $ 394 "ElseIf move_i≟A_HOR_ML"
                  if (move_i == A_HOR_ML):
                    $ 395 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                    if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                      $ 396 "write_port_register(touch_cell_155,5)"
                      write_port_register(touch_cell_155,5)
                      $ 397 "write_port_register(touch_num_156,3)"
                      write_port_register(touch_num_156,3)
                      $ 398 "Call touch_sub"
                      touch_sub()
                      $ 399 "g_cp≔get_actual_tcp_pose()"
                      global g_cp= get_actual_tcp_pose ()
                      $ 400 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                      if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                        $ 401 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                        g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                      end
                      $ 402 "A_Prepos_l[move_i]=g_cp"
                      A_Prepos_l[move_i]=g_cp
                    end
                  else:
                    $ 403 "ElseIf move_i≟A_HOR_R"
                    if (move_i == A_HOR_R):
                      $ 404 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                      if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                        $ 405 "write_port_register(touch_cell_155,5)"
                        write_port_register(touch_cell_155,5)
                        $ 406 "write_port_register(touch_num_156,2)"
                        write_port_register(touch_num_156,2)
                        $ 407 "Call touch_sub"
                        touch_sub()
                        $ 408 "g_cp≔get_actual_tcp_pose()"
                        global g_cp= get_actual_tcp_pose ()
                        $ 409 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                        if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                          $ 410 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                          g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                        end
                        $ 411 "A_Prepos_l[move_i]=g_cp"
                        A_Prepos_l[move_i]=g_cp
                      end
                    else:
                      $ 412 "ElseIf move_i≟A_HOR_MR"
                      if (move_i == A_HOR_MR):
                        $ 413 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                        if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                          $ 414 "write_port_register(touch_cell_155,5)"
                          write_port_register(touch_cell_155,5)
                          $ 415 "write_port_register(touch_num_156,4)"
                          write_port_register(touch_num_156,4)
                          $ 416 "Call touch_sub"
                          touch_sub()
                          $ 417 "g_cp≔get_actual_tcp_pose()"
                          global g_cp= get_actual_tcp_pose ()
                          $ 418 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                          if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                            $ 419 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                            g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                          end
                          $ 420 "A_Prepos_l[move_i]=g_cp"
                          A_Prepos_l[move_i]=g_cp
                        end
                      else:
                        $ 421 "Else" "noBreak"
                        $ 422 "write_port_register(touch_cell_155,move_i)"
                        write_port_register(touch_cell_155,move_i)
                        $ 423 "write_port_register(touch_num_156,1)"
                        write_port_register(touch_num_156,1)
                        $ 424 "Call touch_sub"
                        touch_sub()
                        $ 425 "A_Prepos_l[move_i]=get_actual_tcp_pose()"
                        A_Prepos_l[move_i]= get_actual_tcp_pose ()
                        $ 426 "If move_i≤4"
                        if (move_i <= 4):
                          $ 427 "write_port_register(touch_cell_155,move_i)"
                          write_port_register(touch_cell_155,move_i)
                          $ 428 "write_port_register(touch_num_156,2)"
                          write_port_register(touch_num_156,2)
                          $ 429 "Wait: 0.1"
                          sleep(0.1)
                          $ 430 "Call touch_sub"
                          touch_sub()
                          $ 431 "A_Prepos_l[move_i+9]=get_actual_tcp_pose()"
                          A_Prepos_l[move_i+9]= get_actual_tcp_pose ()
                        end
                      end
                    end
                  end
                end
              else:
                $ 432 "Else" "noBreak"
                $ 433 "A_Prepos_l[move_i]=p[0,0,0,0,0,0]"
                A_Prepos_l[move_i]=p[0,0,0,0,0,0]
                $ 434 "If move_i≤4"
                if (move_i <= 4):
                  $ 435 "A_Prepos_l[move_i+7]=p[0,0,0,0,0,0]"
                  A_Prepos_l[move_i+7]=p[0,0,0,0,0,0]
                else:
                  $ 436 "ElseIf move_i≟A_HOR"
                  if (move_i == A_HOR):
                    $ 437 "A_Prepos_l[A_HOR_ML]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_ML]=p[0,0,0,0,0,0]
                    $ 438 "A_Prepos_l[A_HOR_MR]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_MR]=p[0,0,0,0,0,0]
                    $ 439 "A_Prepos_l[A_HOR_M]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_M]=p[0,0,0,0,0,0]
                    $ 440 "A_Prepos_l[A_HOR_R]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_R]=p[0,0,0,0,0,0]
                  end
                end
              end
              $ 441 "move_i≔move_i+1"
              global move_i=move_i+1
            end
            $ 442 "change deg"
            $ 443 "move_i≔1"
            global move_i=1
            $ 444 "Loop move_i<14"
            while (move_i<14):
              $ 445 "If A_Prepos_l[move_i]≠p[0,0,0,0,0,0]"
              if (A_Prepos_l[move_i] != p[0,0,0,0,0,0]):
                $ 446 "If move_i≟A_VL1 or move_i≟A_VL2 or move_i≟A_VL1_END or move_i≟A_VL2_END"
                if (move_i == A_VL1  or  move_i == A_VL2  or  move_i == A_VL1_END  or  move_i == A_VL2_END):
                  $ 447 "b2_left_par≔ True "
                  global b2_left_par=  True  
                  $ 448 "b8_wv_2f≔ False "
                  global b8_wv_2f=  False  
                  $ 449 "get_pos≔A_Prepos_l[move_i]"
                  global get_pos=A_Prepos_l[move_i]
                  $ 450 "get_org≔left"
                  global get_org=p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605]
                  $ 451 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                  global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                  $ 452 "pre_tp≔tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])"
                  global pre_tp=tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])
                else:
                  $ 453 "ElseIf move_i≟A_VR1 or move_i≟A_VR2 or move_i≟A_VR1_END or move_i≟A_VR2_END"
                  if (move_i == A_VR1  or  move_i == A_VR2  or  move_i == A_VR1_END  or  move_i == A_VR2_END):
                    $ 454 "b2_left_par≔ False "
                    global b2_left_par=  False  
                    $ 455 "b8_wv_2f≔ False "
                    global b8_wv_2f=  False  
                    $ 456 "get_pos≔A_Prepos_l[move_i]"
                    global get_pos=A_Prepos_l[move_i]
                    $ 457 "get_org≔right"
                    global get_org=p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292]
                    $ 458 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                    global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                    $ 459 "pre_tp≔tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])"
                    global pre_tp=tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])
                  else:
                    $ 460 "ElseIf move_i≟A_HOR or move_i≟A_HOR_ML"
                    if (move_i == A_HOR  or  move_i == A_HOR_ML):
                      $ 461 "b8_wv_2f≔ True "
                      global b8_wv_2f=  True  
                      $ 462 "b2_left_par≔ True "
                      global b2_left_par=  True  
                      $ 463 "get_pos≔A_Prepos_l[move_i]"
                      global get_pos=A_Prepos_l[move_i]
                      $ 464 "get_org≔up_left"
                      global get_org=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                      $ 465 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                      global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                      $ 466 "pre_tp≔tilt_2f_fun(get_pos,[0,0], True , True )"
                      global pre_tp=tilt_2f_fun(get_pos,[0,0],  True  ,  True  )
                    else:
                      $ 467 "ElseIf move_i≟A_HOR_R or move_i≟A_HOR_MR"
                      if (move_i == A_HOR_R  or  move_i == A_HOR_MR):
                        $ 468 "b8_wv_2f≔ True "
                        global b8_wv_2f=  True  
                        $ 469 "b2_left_par≔ False "
                        global b2_left_par=  False  
                        $ 470 "get_pos≔A_Prepos_l[move_i]"
                        global get_pos=A_Prepos_l[move_i]
                        $ 471 "get_org≔up_right"
                        global get_org=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                        $ 472 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                        global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                        $ 473 "pre_tp≔tilt_2f_fun(get_pos,[0,0], False , True )"
                        global pre_tp=tilt_2f_fun(get_pos,[0,0],  False  ,  True  )
                      end
                    end
                  end
                end
                $ 474 "A_Prepos_l[move_i]=pre_tp"
                A_Prepos_l[move_i]=pre_tp
              end
              $ 475 "move_i≔move_i+1"
              global move_i=move_i+1
            end
            $ 476 "homeing()"
            homeing()
            $ 477 "Wait read_port_register(170)≟1"
            while (not( read_port_register (170) == 1)):
              sync()
            end
            $ 478 "write_port_register(170,0)"
            write_port_register(170,0)
          else:
            $ 479 "Else" "noBreak"
            $ 480 "value from pendant"
            $ 481 "move_i≔1"
            global move_i=1
            $ 483 "Touch_FrontandSide"
            $ 484 "If EXT_flag1[11]≟ True "
            if (EXT_flag1[11] ==   True  ):
              $ 485 "Touch front and side_Right"
              $ 486 "move_center≔pose_add(first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])"
              global move_center= pose_add (first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])
              $ 487 "get_pose_side_t≔0"
              global get_pose_side_t=0
              $ 489 "move_center[2]=(center_height+a7_cell_bottom)/1000"
              move_center[2]=(center_height+a7_cell_bottom)/1000
              $ 491 "MoveL"
              $ 492 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 493 "touch_center≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 494 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 495 "get_center≔touch_center[0]*1000"
              global get_center=touch_center[0]*1000
              $ 496 "a7_f_distance≔get_center"
              global a7_f_distance=get_center
              $ 497 "move_center≔pose_add(move_center,p[0,sec_touch_dis/1000,0,0,0,0])"
              global move_center= pose_add (move_center,p[0,sec_touch_dis/1000,0,0,0,0])
              $ 498 "move_center[0]=touch_center[0]-20/1000"
              move_center[0]=touch_center[0]-20/1000
              $ 499 "MoveL"
              $ 500 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 501 "touch_center2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 502 "center_line≔get_feature_Line(touch_center,touch_center2)"
              global center_line=get_feature_Line(touch_center,touch_center2)
              $ 503 "event_cal_on≔ True "
              global event_cal_on=  True  
              $ 504 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 506 "homeing()"
              homeing()
              $ 507 "b2_left_par≔ False "
              global b2_left_par=  False  
              $ 508 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 509 "b2_cell≔b1_cell_info_R"
              global b2_cell=b1_cell_info_R
              $ 510 "get_pos≔get_lr(side_p_R,a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line, True )"
              global get_pos=get_lr(p[.471584857321, -.427242166643, .026448165242, 1.806736638758, -1.227818761912, 1.383474453522],a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line,  True  )
              $ 512 "pre_tp≔get_pos"
              global pre_tp=get_pos
              $ 513 "pre_tp≔pose_add(pre_tp, p[side_pos_x/1000,0,0,0,0,0])"
              global pre_tp= pose_add (pre_tp, p[side_pos_x/1000,0,0,0,0,0])
              $ 514 "pre_tp[2]=(center_height+a7_cell_bottom)/1000"
              pre_tp[2]=(center_height+a7_cell_bottom)/1000
              $ 515 "MoveL"
              $ 516 "pre_tp" "breakAfter"
              movel(pose_trans(Base, pre_tp), a=1.2, v=0.25)
              $ 517 "touch_side≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,13,13)"
              global touch_side=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,13,13)
              $ 518 "touch_side≔get_feature_pose(touch_side,center_line)"
              global touch_side=get_feature_pose(touch_side,center_line)
              $ 519 "direction(p[0,0,0,0,0,0],[0,1,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[0,1,0],10,180,200)
              $ 520 "write_welder(4, False )"
              write_welder(4,  False  )
              $ 521 "get_pose_side_t≔touch_side[1]*1000"
              global get_pose_side_t=touch_side[1]*1000
              $ 522 "get_pose_side_t≔get_pose_side_t+(a6_f_width/2)"
              global get_pose_side_t=get_pose_side_t+(a6_f_width/2)
              $ 523 "event_side_on≔ True "
              global event_side_on=  True  
              $ 524 "MoveL"
              $ 525 "Direction: Base"
              global move_thread_flag_525=0
              thread move_thread_525():
                enter_critical
                move_thread_flag_525 = 1
                local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,1,0], 0.03)
                movel(towardsPos, a=0.08, v=0.05)
                move_thread_flag_525 = 2
                exit_critical
              end
              move_thread_flag_525 = 0
              move_thread_han_525 = run move_thread_525()
              while (True):
                sleep(1.0E-10)
                if (move_thread_flag_525 > 1):
                  join move_thread_han_525
                  $ 526 "Until (distance)"
                  break
                end
                sync()
              end
              $ 527 "homeing()"
              homeing()
            else:
              $ 528 "Else" "noBreak"
              $ 529 "Touch front and side_Left"
              $ 530 "move_center≔pose_add(first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])"
              global move_center= pose_add (first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])
              $ 531 "get_pose_side_t≔0"
              global get_pose_side_t=0
              $ 533 "move_center[2]=(center_height+a7_cell_bottom)/1000"
              move_center[2]=(center_height+a7_cell_bottom)/1000
              $ 535 "MoveL"
              $ 536 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 537 "touch_center≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 538 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 539 "get_center≔touch_center[0]*1000"
              global get_center=touch_center[0]*1000
              $ 540 "a7_f_distance≔get_center"
              global a7_f_distance=get_center
              $ 541 "move_center≔pose_add(move_center,p[0,sec_touch_dis/1000,0,0,0,0])"
              global move_center= pose_add (move_center,p[0,sec_touch_dis/1000,0,0,0,0])
              $ 542 "move_center[0]=touch_center[0]-20/1000"
              move_center[0]=touch_center[0]-20/1000
              $ 543 "MoveL"
              $ 544 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 545 "touch_center2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 546 "center_line≔get_feature_Line(touch_center,touch_center2)"
              global center_line=get_feature_Line(touch_center,touch_center2)
              $ 547 "event_cal_on≔ True "
              global event_cal_on=  True  
              $ 548 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 550 "homeing()"
              homeing()
              $ 551 "b2_left_par≔ True "
              global b2_left_par=  True  
              $ 552 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 553 "b2_cell≔b1_cell_info_L"
              global b2_cell=b1_cell_info_L
              $ 554 "get_pos≔get_lr(side_p_L,a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line, True )"
              global get_pos=get_lr(p[.411215372122, .375785944375, -.010176539343, -1.953488355698, -1.125710367676, -1.228829273458],a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line,  True  )
              $ 556 "pre_tp≔get_pos"
              global pre_tp=get_pos
              $ 557 "pre_tp≔pose_add(pre_tp, p[side_pos_x/1000,0,0,0,0,0])"
              global pre_tp= pose_add (pre_tp, p[side_pos_x/1000,0,0,0,0,0])
              $ 558 "pre_tp[2]=(center_height+a7_cell_bottom)/1000"
              pre_tp[2]=(center_height+a7_cell_bottom)/1000
              $ 559 "MoveL"
              $ 560 "pre_tp" "breakAfter"
              movel(pose_trans(Base, pre_tp), a=1.2, v=0.25)
              $ 561 "touch_side≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,13,13)"
              global touch_side=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,13,13)
              $ 562 "touch_side≔get_feature_pose(touch_side,center_line)"
              global touch_side=get_feature_pose(touch_side,center_line)
              $ 563 "direction(p[0,0,0,0,0,0],[0,-1,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[0,-1,0],10,180,200)
              $ 564 "write_welder(4, False )"
              write_welder(4,  False  )
              $ 565 "get_pose_side_t≔touch_side[1]*1000"
              global get_pose_side_t=touch_side[1]*1000
              $ 566 "get_pose_side_t≔get_pose_side_t-(a6_f_width/2)"
              global get_pose_side_t=get_pose_side_t-(a6_f_width/2)
              $ 567 "event_side_on≔ True "
              global event_side_on=  True  
              $ 568 "MoveL"
              $ 569 "Direction: Base"
              global move_thread_flag_569=0
              thread move_thread_569():
                enter_critical
                move_thread_flag_569 = 1
                local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1,0], 0.03)
                movel(towardsPos, a=0.08, v=0.05)
                move_thread_flag_569 = 2
                exit_critical
              end
              move_thread_flag_569 = 0
              move_thread_han_569 = run move_thread_569()
              while (True):
                sleep(1.0E-10)
                if (move_thread_flag_569 > 1):
                  join move_thread_han_569
                  $ 570 "Until (distance)"
                  break
                end
                sync()
              end
              $ 571 "homeing()"
              homeing()
            end
            $ 573 "Wait event_side_on≟ False "
            while (not(event_side_on ==   False  )):
              sync()
            end
          end
          $ 574 "move and touch"
          $ 575 "Touch Move"
          $ 576 "HOR_L"
          $ 577 "If A_Prepos_l[A_HOR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR] != p[0,0,0,0,0,0]):
            $ 578 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 579 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 580 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 581 "A_sel_v≔A_HOR"
            global A_sel_v=A_HOR
            $ 582 "wv_direction≔1"
            global wv_direction=1
            $ 583 "Call MoveandTouchFun_2f"
            MoveandTouchFun_2f()
            $ 585 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 586 "If A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                $ 588 "g_tp≔A_Prepos_l[A_HOR]"
                global g_tp=A_Prepos_l[A_HOR]
                $ 591 "Folder"
                $ 592 "g_cp≔get_actual_tcp_pose()"
                global g_cp= get_actual_tcp_pose ()
                $ 593 "g_cp≔pose_trans(g_cp, p[0,0,0,d2r(12),d2r(5),0])"
                global g_cp= pose_trans (g_cp, p[0,0,0,d2r(12),d2r(5),0])
                $ 594 "MoveL"
                $ 595 "g_cp" "breakAfter"
                movel(pose_trans(Base, g_cp), a=0.08, v=0.08)
                $ 596 "for_x_HOR≔contact_fun(A_Touch_p[A_sel_v],[-1*wv_direction,0,0],10000,15,15,  False)"
                global for_x_HOR=contact_fun(A_Touch_p[A_sel_v],[-1*wv_direction,0,0],10000,15,15,  False)
                $ 597 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
                $ 598 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 599 "Else" "noBreak"
                $ 600 "for_x_HOR≔p[0,0,0,0,0,0]"
                global for_x_HOR=p[0,0,0,0,0,0]
              end
            else:
              $ 601 "ElseIf b1_cell_info_L≟E"
              if (b1_cell_info_L == E):
                $ 602 "direction(p[0,0,0,0,0,0],[0,1,0],40,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],40,120,160)
                $ 603 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
                $ 604 "for_x_HOR≔contact_fun(A_Touch_p[A_sel_v],[0,-1,0],10000,15,15,  False)"
                global for_x_HOR=contact_fun(A_Touch_p[A_sel_v],[0,-1,0],10000,15,15,  False)
                $ 605 "write_welder(4, False )"
                write_welder(4,  False  )
                $ 606 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                $ 607 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              end
            end
            $ 608 "If point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.03"
            if (point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.03):
              $ 609 "homeing()"
              homeing()
            end
          end
          $ 610 "VL1"
          $ 611 "If A_Prepos_l[A_VL1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL1] != p[0,0,0,0,0,0]):
            $ 612 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 613 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 614 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 615 "A_sel_v≔A_VL1"
            global A_sel_v=A_VL1
            $ 616 "A_sel_v_end≔A_VL1_END"
            global A_sel_v_end=A_VL1_END
            $ 617 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 618 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 619 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 620 "Else" "noBreak"
              $ 621 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 622 "Call MoveandTouchFun_3f"
            MoveandTouchFun_3f()
            $ 623 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 624 "If A_Prepos_l[A_HOR]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_HOR] == p[0,0,0,0,0,0]):
                $ 625 "direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)
                $ 627 "AAgcp≔get_actual_tcp_pose()"
                global AAgcp= get_actual_tcp_pose ()
                $ 628 "AAgangle≔up_left"
                global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                $ 629 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                $ 630 "MoveL"
                $ 631 "AAgtp" "breakAfter"
                movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                $ 633 "for_z_VL1≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)"
                global for_z_VL1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)
                $ 634 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                $ 635 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 636 "Else" "noBreak"
                $ 637 "for_z_VL1≔p[0,0,0,0,0,0]"
                global for_z_VL1=p[0,0,0,0,0,0]
              end
            end
          end
          $ 638 "HOR_ML"
          $ 639 "If A_Prepos_l[A_HOR_ML]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_ML] != p[0,0,0,0,0,0]):
            $ 640 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 641 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 642 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 643 "A_sel_v≔A_HOR_ML"
            global A_sel_v=A_HOR_ML
            $ 644 "If b1_cell_info_L≟C or b1_cell_info_L≟D"
            if (b1_cell_info_L == C  or  b1_cell_info_L == D):
              $ 645 "wv_direction≔1"
              global wv_direction=1
              $ 646 "Call MoveFun"
              MoveFun()
              $ 647 "for_cal_xy≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_xy=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 648 "direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)
              $ 649 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
              $ 650 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
              $ 651 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
              $ 652 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
              $ 653 "for_cal_zl≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global for_cal_zl=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 654 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
              $ 655 "If A_Prepos_l[A_VL2]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VL2] == p[0,0,0,0,0,0]):
                $ 656 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 657 "direction(p[0,0,0,0,0,0],[-1,0,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],30,120,160)
              end
              $ 658 "for_cal_rot≔A_Touch_p[A_HOR]"
              global for_cal_rot=A_Touch_p[A_HOR]
              $ 659 "A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zl[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
              A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zl[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
              $ 660 "A_Touch_p[A_sel_v]=pose_trans(A_Touch_p[A_sel_v], p[Touch_dis/1000,0,0,0,0,0])"
              A_Touch_p[A_sel_v]= pose_trans (A_Touch_p[A_sel_v], p[Touch_dis/1000,0,0,0,0,0])
              $ 661 "write_welder(4, False )"
              write_welder(4,  False  )
            else:
              $ 662 "Else" "noBreak"
              $ 663 "wv_direction≔1"
              global wv_direction=1
              $ 664 "for_cal_rot≔A_Touch_p[A_HOR]"
              global for_cal_rot=A_Touch_p[A_HOR]
              $ 665 "Call MoveFun_cd"
              MoveFun_cd()
              $ 666 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 667 "for_cal_y_wel[2]=for_cal_rot[2]"
              for_cal_y_wel[2]=for_cal_rot[2]
              $ 668 "dir_x_cal≔get_feature_Line(for_cal_rot,for_cal_y_wel)"
              global dir_x_cal=get_feature_Line(for_cal_rot,for_cal_y_wel)
              $ 669 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              $ 670 "direction(p[0,0,0,0,0,0],[0,-1,0],70,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],70,120,160)
              $ 671 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 672 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
              $ 673 "direction(p[0,0,0,0,0,0],[0,1,0],50,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],50,120,160)
              $ 674 "direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)
              $ 675 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
              $ 676 "get_ml≔get_feature_pose(for_cal_x_wel,for_cal_rot)"
              global get_ml=get_feature_pose(for_cal_x_wel,for_cal_rot)
              $ 678 "A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)"
              A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)
              $ 679 "direction(p[0,0,0,0,0,0],[0,1,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],5,120,160)
              $ 680 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 681 "write_welder(4, False )"
              write_welder(4,  False  )
            end
          else:
            $ 682 "Else" "noBreak"
            $ 683 "homeing()"
            homeing()
          end
          $ 684 "VL2"
          $ 685 "If A_Prepos_l[A_VL2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL2] != p[0,0,0,0,0,0]):
            $ 686 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 687 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 688 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 689 "A_sel_v≔A_VL2"
            global A_sel_v=A_VL2
            $ 690 "A_sel_v_end≔A_VL2_END"
            global A_sel_v_end=A_VL2_END
            $ 691 "b2_par_cd≔1"
            global b2_par_cd=1
            $ 692 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 693 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 694 "Else" "noBreak"
              $ 695 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 696 "If b1_cell_info_L≟d or b1_cell_info_L≟c"
            if (b1_cell_info_L == d  or  b1_cell_info_L == c):
              $ 697 "Halt"
              halt
            else:
              $ 698 "Else" "noBreak"
              $ 699 "If A_Touch_p[A_VL1]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_VL1] == p[0,0,0,0,0,0]):
                $ 700 "Call MoveandTouchFun_3f"
                MoveandTouchFun_3f()
                $ 701 "If A_Prepos_l[A_HOR_ML]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_ML] == p[0,0,0,0,0,0]):
                  $ 702 "direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)
                  $ 703 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 704 "AAgangle≔up_left"
                  global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                  $ 705 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 706 "MoveL"
                  $ 707 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 709 "If b1_cell_info_L≠E and b1_cell_info_L≠e"
                  if (b1_cell_info_L != E  and  b1_cell_info_L != e):
                    $ 710 "for_cal_zl≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                    global for_cal_zl=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                    $ 711 "direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)"
                    direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)
                  end
                end
                $ 712 "touch_tmp≔A_Touch_p[A_sel_v]"
                global touch_tmp=A_Touch_p[A_sel_v]
                $ 713 "If b1_cell_info_L≠E and b1_cell_info_L≠e"
                if (b1_cell_info_L != E  and  b1_cell_info_L != e):
                  $ 714 "touch_tmp[2]=for_cal_zl[2]"
                  touch_tmp[2]=for_cal_zl[2]
                  $ 715 "A_Touch_p[A_sel_v]=touch_tmp"
                  A_Touch_p[A_sel_v]=touch_tmp
                end
                $ 716 "for_cal_y_wel≔A_Touch_p[A_sel_v]"
                global for_cal_y_wel=A_Touch_p[A_sel_v]
                $ 717 "for_cal_x_wel≔A_Touch_p[A_sel_v]"
                global for_cal_x_wel=A_Touch_p[A_sel_v]
              else:
                $ 718 "Else" "noBreak"
                $ 719 "Call MoveFun"
                MoveFun()
                $ 720 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 721 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
                $ 722 "If A_Prepos_l[A_HOR_ML]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_ML] == p[0,0,0,0,0,0]):
                  $ 723 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
                  $ 724 "var_2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global var_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 725 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
                  $ 726 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
                  $ 727 "direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)"
                  direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)
                  $ 728 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                  global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                  $ 729 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
                  $ 730 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 731 "AAgangle≔up_left"
                  global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                  $ 732 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 733 "MoveL"
                  $ 734 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 736 "If b1_cell_info_L≠E and b1_cell_info_L≠e"
                  if (b1_cell_info_L != E  and  b1_cell_info_L != e):
                    $ 737 "for_cal_zl≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                    global for_cal_zl=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                    $ 738 "direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)"
                    direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)
                  end
                  $ 739 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                end
                $ 740 "for_cal_rot≔A_Touch_p[A_VL1]"
                global for_cal_rot=A_Touch_p[A_VL1]
                $ 741 "If b1_cell_info_L≠E and b1_cell_info_L≠e"
                if (b1_cell_info_L != E  and  b1_cell_info_L != e):
                  $ 742 "A_Touch_p[A_sel_v]=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zl[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  A_Touch_p[A_sel_v]=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zl[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                  $ 743 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zl[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zl[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                else:
                  $ 744 "Else" "noBreak"
                  $ 745 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                end
                $ 746 "If Scallup_check≟ False "
                if (Scallup_check ==   False  ):
                  $ 747 "touch_tmp≔pose_trans(touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])"
                  global touch_tmp= pose_trans (touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])
                  $ 748 "A_Touch_p[A_sel_v]=touch_tmp"
                  A_Touch_p[A_sel_v]=touch_tmp
                else:
                  $ 749 "Else" "noBreak"
                  $ 750 "Scallup_check≔ False "
                  global Scallup_check=  False  
                end
                $ 751 "write_welder(4, False )"
                write_welder(4,  False  )
              end
            end
            $ 752 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 753 "homeing()"
            homeing()
          else:
            $ 754 "Else" "noBreak"
            $ 755 "homeing()"
            homeing()
          end
          $ 756 "HOR_R"
          $ 757 "If A_Prepos_l[A_HOR_R]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_R] != p[0,0,0,0,0,0]):
            $ 758 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 759 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 760 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 761 "A_sel_v≔A_HOR_R"
            global A_sel_v=A_HOR_R
            $ 762 "wv_direction≔-1"
            global wv_direction=-1
            $ 763 "Call MoveandTouchFun_2f"
            MoveandTouchFun_2f()
            $ 765 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 766 "If A_Prepos_l[A_VR1]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VR1] == p[0,0,0,0,0,0]):
                $ 768 "g_tp≔A_Prepos_l[A_HOR_R]"
                global g_tp=A_Prepos_l[A_HOR_R]
                $ 769 "Folder"
                $ 770 "g_cp≔get_actual_tcp_pose()"
                global g_cp= get_actual_tcp_pose ()
                $ 771 "g_cp≔pose_trans(g_cp, p[0,0,0,d2r(-12),d2r(5),0])"
                global g_cp= pose_trans (g_cp, p[0,0,0,d2r(-12),d2r(5),0])
                $ 772 "MoveL"
                $ 773 "g_cp" "breakAfter"
                movel(pose_trans(Base, g_cp), a=0.08, v=0.08)
                $ 776 "for_x_HOR_R≔contact_fun(A_Touch_p[A_HOR_R],[-1*wv_direction,0,0],10000,15,15,  False)"
                global for_x_HOR_R=contact_fun(A_Touch_p[A_HOR_R],[-1*wv_direction,0,0],10000,15,15,  False)
                $ 777 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                $ 778 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 779 "Else" "noBreak"
                $ 780 "for_x_HOR_R≔p[0,0,0,0,0,0]"
                global for_x_HOR_R=p[0,0,0,0,0,0]
              end
            end
            $ 781 "wv_direction≔1"
            global wv_direction=1
            $ 782 "If point_dist(A_Prepos_l[A_HOR_R], A_Prepos_l[A_VR1])>0.03"
            if (point_dist(A_Prepos_l[A_HOR_R], A_Prepos_l[A_VR1])>0.03):
              $ 783 "homeing()"
              homeing()
            end
          end
          $ 784 "VR1"
          $ 785 "If A_Prepos_l[A_VR1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR1] != p[0,0,0,0,0,0]):
            $ 786 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 787 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 788 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 789 "A_sel_v≔A_VR1"
            global A_sel_v=A_VR1
            $ 790 "A_sel_v_end≔A_VR1_END"
            global A_sel_v_end=A_VR1_END
            $ 791 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 792 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 793 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 794 "Else" "noBreak"
              $ 795 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 796 "Call MoveandTouchFun_3f"
            MoveandTouchFun_3f()
            $ 797 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 798 "If A_Prepos_l[A_HOR_R]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_HOR_R] == p[0,0,0,0,0,0]):
                $ 799 "direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)
                $ 800 "AAgcp≔get_actual_tcp_pose()"
                global AAgcp= get_actual_tcp_pose ()
                $ 801 "AAgangle≔up_right"
                global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                $ 802 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                $ 803 "MoveL"
                $ 804 "AAgtp" "breakAfter"
                movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                $ 806 "for_z_VR1≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)"
                global for_z_VR1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)
                $ 807 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                $ 808 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 809 "Else" "noBreak"
                $ 810 "for_z_VR1≔p[0,0,0,0,0,0]"
                global for_z_VR1=p[0,0,0,0,0,0]
              end
            end
          end
          $ 811 "HOR_MR"
          $ 812 "If A_Prepos_l[A_HOR_MR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_MR] != p[0,0,0,0,0,0]):
            $ 813 "INIT"
            $ 814 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 815 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 816 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 817 "A_sel_v≔A_HOR_MR"
            global A_sel_v=A_HOR_MR
            $ 818 "If b1_cell_info_R≟C or b1_cell_info_R≟D"
            if (b1_cell_info_R == C  or  b1_cell_info_R == D):
              $ 819 "wv_direction≔-1"
              global wv_direction=-1
              $ 820 "Call MoveFun_cd"
              MoveFun_cd()
              $ 821 "for_cal_xy≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_xy=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 822 "direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)
              $ 823 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
              $ 824 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
              $ 825 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
              $ 826 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
              $ 827 "for_cal_zr≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global for_cal_zr=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 828 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
              $ 829 "If A_Prepos_l[A_VR2]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VR2] == p[0,0,0,0,0,0]):
                $ 830 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 831 "direction(p[0,0,0,0,0,0],[-1,0,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],8,120,160)
              end
              $ 832 "for_cal_rot≔A_Touch_p[A_HOR_R]"
              global for_cal_rot=A_Touch_p[A_HOR_R]
              $ 833 "A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
              A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
              $ 834 "A_Touch_p[A_sel_v]=pose_trans(A_Touch_p[A_sel_v], p[-Touch_dis/1000,0,0,0,0,0])"
              A_Touch_p[A_sel_v]= pose_trans (A_Touch_p[A_sel_v], p[-Touch_dis/1000,0,0,0,0,0])
              $ 835 "write_welder(4, False )"
              write_welder(4,  False  )
            else:
              $ 836 "Else" "noBreak"
              $ 837 "wv_direction≔-1"
              global wv_direction=-1
              $ 838 "for_cal_rot≔A_Touch_p[A_HOR_R]"
              global for_cal_rot=A_Touch_p[A_HOR_R]
              $ 839 "Call MoveFun_cd"
              MoveFun_cd()
              $ 840 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 841 "vr2_p1≔for_cal_y_wel"
              global vr2_p1=for_cal_y_wel
              $ 842 "for_cal_y_wel[2]=for_cal_rot[2]"
              for_cal_y_wel[2]=for_cal_rot[2]
              $ 843 "dir_x_cal≔get_feature_Line(for_cal_rot,for_cal_y_wel)"
              global dir_x_cal=get_feature_Line(for_cal_rot,for_cal_y_wel)
              $ 844 "vr2_p2≔feature_offset(vr2_p1,p[0,0.02,0,0,0,0],dir_x_cal)"
              global vr2_p2=feature_offset(vr2_p1,p[0,0.02,0,0,0,0],dir_x_cal)
              $ 845 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              $ 846 "direction(p[0,0,0,0,0,0],[0,1,0],70,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],70,120,160)
              $ 847 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 848 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
              $ 849 "direction(p[0,0,0,0,0,0],[0,-1,0],50,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],50,120,160)
              $ 850 "direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)
              $ 851 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
              $ 852 "vr2_p3≔for_cal_x_wel"
              global vr2_p3=for_cal_x_wel
              $ 853 "get_ml≔get_feature_pose(for_cal_x_wel,for_cal_rot)"
              global get_ml=get_feature_pose(for_cal_x_wel,for_cal_rot)
              $ 855 "A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,-get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)"
              A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,-get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)
              $ 856 "vr2_p4≔A_Touch_p[A_HOR_MR]"
              global vr2_p4=A_Touch_p[A_HOR_MR]
              $ 857 "direction(p[0,0,0,0,0,0],[0,-1,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],5,120,160)
              $ 858 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 859 "write_welder(4, False )"
              write_welder(4,  False  )
            end
            $ 860 "wv_direction≔1"
            global wv_direction=1
          end
          $ 861 "VR2"
          $ 862 "If A_Prepos_l[A_VR2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR2] != p[0,0,0,0,0,0]):
            $ 863 "Init"
            $ 864 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 865 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 866 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 867 "A_sel_v≔A_VR2"
            global A_sel_v=A_VR2
            $ 868 "A_sel_v_end≔A_VR2_END"
            global A_sel_v_end=A_VR2_END
            $ 869 "b2_par_cd≔1"
            global b2_par_cd=1
            $ 870 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 871 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 872 "Else" "noBreak"
              $ 873 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 874 "If b1_cell_info_R≟d or b1_cell_info_R≟c"
            if (b1_cell_info_R == d  or  b1_cell_info_R == c):
              $ 875 "If vr2_p1≟p[0,0,0,0,0,0]"
              if (vr2_p1 == p[0,0,0,0,0,0]):
                $ 876 "Call MoveFun_cd"
                MoveFun_cd()
                $ 877 "vr2_p1≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p1=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 878 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 879 "direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)
                $ 880 "vr2_p2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 881 "direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)
                $ 882 "vr2_p3≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                global vr2_p3=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                $ 883 "direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)
                $ 884 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 885 "vr2_p4≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                global vr2_p4=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                $ 886 "direction(p[0,0,0,0,0,0],[0,0,1],40,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],40,120,160)
                $ 887 "A_Touch_p[A_sel_v]=touch_xyz_get_middle(vr2_p1,vr2_p2,vr2_p3,vr2_p4)"
                A_Touch_p[A_sel_v]=touch_xyz_get_middle(vr2_p1,vr2_p2,vr2_p3,vr2_p4)
                $ 888 "var_4≔A_Touch_p[A_sel_v]"
                global var_4=A_Touch_p[A_sel_v]
                $ 889 "var_4≔pose_trans(var_4, p[a6_callar_vert/1000,0,0,0,0,0])"
                global var_4= pose_trans (var_4, p[a6_callar_vert/1000,0,0,0,0,0])
                $ 890 "var_5≔get_actual_tcp_pose()"
                global var_5= get_actual_tcp_pose ()
                $ 891 "var_5[2]=var_4[2]"
                var_5[2]=var_4[2]
                $ 892 "var_5≔pose_trans(var_5, p[0,0,0,0,d2r(10),0])"
                global var_5= pose_trans (var_5, p[0,0,0,0,d2r(10),0])
                $ 893 "MoveL"
                $ 894 "var_5" "breakAfter"
                movel(pose_trans(Base, var_5), a=0.1, v=0.1)
                $ 895 "vr2_p1_up≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p1_up=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 896 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 897 "direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)
                $ 898 "vr2_p2_up≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p2_up=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 899 "direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)
                $ 900 "vr2_p3_up≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                global vr2_p3_up=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                $ 901 "direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)
                $ 902 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              end
              $ 903 "A_Touch_p[A_sel_v+9]=touch_4point(vr2_p1_up,vr2_p2_up,vr2_p3_up)"
              A_Touch_p[A_sel_v+9]=touch_4point(vr2_p1_up,vr2_p2_up,vr2_p3_up)
              $ 904 "A_Touch_p[A_sel_v+9]=ori_pose(A_Touch_p[A_sel_v+9],A_Touch_p[A_sel_v])"
              A_Touch_p[A_sel_v+9]=ori_pose(A_Touch_p[A_sel_v+9],A_Touch_p[A_sel_v])
            else:
              $ 905 "Else" "noBreak"
              $ 906 "If A_Touch_p[A_VR1]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_VR1] == p[0,0,0,0,0,0]):
                $ 907 "Call MoveandTouchFun_3f"
                MoveandTouchFun_3f()
                $ 908 "touch_tmp≔A_Touch_p[A_sel_v]"
                global touch_tmp=A_Touch_p[A_sel_v]
                $ 909 "If A_Prepos_l[A_HOR_MR]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_MR] == p[0,0,0,0,0,0]):
                  $ 910 "direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)
                  $ 911 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 912 "AAgangle≔up_right"
                  global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                  $ 913 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 914 "MoveL"
                  $ 915 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                end
                $ 917 "If b1_cell_info_R≠E and b1_cell_info_R≠e"
                if (b1_cell_info_R != E  and  b1_cell_info_R != e):
                  $ 918 "for_cal_zr≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_cal_zr=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 919 "touch_tmp[2]=for_cal_zr[2]"
                  touch_tmp[2]=for_cal_zr[2]
                end
                $ 920 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 921 "for_cal_y_wel≔A_Touch_p[A_sel_v]"
                global for_cal_y_wel=A_Touch_p[A_sel_v]
                $ 922 "for_cal_x_wel≔A_Touch_p[A_sel_v]"
                global for_cal_x_wel=A_Touch_p[A_sel_v]
              else:
                $ 923 "Else" "noBreak"
                $ 924 "Call MoveFun"
                MoveFun()
                $ 925 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 926 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
                $ 927 "If A_Prepos_l[A_HOR_MR]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_MR] == p[0,0,0,0,0,0]):
                  $ 928 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
                  $ 929 "var_2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global var_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 930 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
                  $ 931 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
                  $ 932 "direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)"
                  direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)
                  $ 933 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
                  global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
                  $ 934 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                  $ 935 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 936 "AAgangle≔up_right"
                  global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                  $ 937 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 938 "MoveL"
                  $ 939 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.1, v=0.1)
                  $ 941 "If b1_cell_info_R≠E and b1_cell_info_R≠e"
                  if (b1_cell_info_R != E  and  b1_cell_info_R != e):
                    $ 942 "for_cal_zr≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                    global for_cal_zr=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                    $ 943 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                    direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                  end
                  $ 944 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                end
                $ 945 "for_cal_rot≔A_Touch_p[A_VR1]"
                global for_cal_rot=A_Touch_p[A_VR1]
                $ 946 "If b1_cell_info_R≠E and b1_cell_info_R≠e"
                if (b1_cell_info_R != E  and  b1_cell_info_R != e):
                  $ 947 "A_Touch_p[A_sel_v]=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  A_Touch_p[A_sel_v]=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                  $ 948 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                else:
                  $ 949 "Else" "noBreak"
                  $ 950 "A_Touch_p[A_sel_v]=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  A_Touch_p[A_sel_v]=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                  $ 951 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                  touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                end
                $ 952 "If Scallup_check≟ False "
                if (Scallup_check ==   False  ):
                  $ 953 "touch_tmp≔pose_trans(touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])"
                  global touch_tmp= pose_trans (touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])
                  $ 954 "A_Touch_p[A_sel_v]=touch_tmp"
                  A_Touch_p[A_sel_v]=touch_tmp
                else:
                  $ 955 "Else" "noBreak"
                  $ 956 "Scallup_check≔ False "
                  global Scallup_check=  False  
                end
                $ 957 "write_welder(4, False )"
                write_welder(4,  False  )
              end
            end
            $ 958 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 959 "homeing()"
            homeing()
          else:
            $ 960 "Else" "noBreak"
            $ 961 "homeing()"
            homeing()
          end
          $ 962 "write_welder(4,False)"
          write_welder(4,False)
          $ 1019 "Touch After Offset"
          $ 1020 "touch_after_offset"
          $ 1021 "HOR"
          $ 1022 "If A_Prepos_l[A_HOR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR] != p[0,0,0,0,0,0]):
            $ 1023 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 1024 "If for_x_HOR≟p[0,0,0,0,0,0]"
              if (for_x_HOR == p[0,0,0,0,0,0]):
                $ 1025 "for_x_HOR≔A_Touch_p[A_VL1]"
                global for_x_HOR=A_Touch_p[A_VL1]
              end
              $ 1026 "If for_x_HOR≠p[0,0,0,0,0,0]"
              if (for_x_HOR != p[0,0,0,0,0,0]):
                $ 1027 "x_diff≔get_feature_pose(for_x_HOR,A_Touch_p[A_HOR])"
                global x_diff=get_feature_pose(for_x_HOR,A_Touch_p[A_HOR])
                $ 1028 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[x_diff[0],0,0,0,0,0])"
                A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[x_diff[0],0,0,0,0,0])
              end
            end
            $ 1029 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[offset_2f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[offset_2f_begin/1000,0,0,0,0,0])
          end
          $ 1030 "VL1"
          $ 1031 "If A_Prepos_l[A_VL1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL1] != p[0,0,0,0,0,0]):
            $ 1032 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 1033 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1034 "If for_z_VL1≟p[0,0,0,0,0,0]"
              if (for_z_VL1 == p[0,0,0,0,0,0]):
                $ 1035 "for_z_VL1≔A_Touch_p[A_HOR]"
                global for_z_VL1=A_Touch_p[A_HOR]
              end
              $ 1036 "Comment"
              # Comment
              $ 1037 "If for_z_VL1≠p[0,0,0,0,0,0]"
              if (for_z_VL1 != p[0,0,0,0,0,0]):
                $ 1038 "z_diff≔get_feature_pose(for_z_VL1,A_Touch_p[A_VL1])"
                global z_diff=get_feature_pose(for_z_VL1,A_Touch_p[A_VL1])
                $ 1039 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[z_diff[0],0,0,0,0,0])
              end
            end
            $ 1041 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1042 "VL2"
          $ 1043 "If A_Prepos_l[A_VL2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL2] != p[0,0,0,0,0,0]):
            $ 1044 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1045 "HOR_R"
          $ 1046 "If A_Prepos_l[A_HOR_R]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_R] != p[0,0,0,0,0,0]):
            $ 1047 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 1048 "If for_x_HOR_R≟p[0,0,0,0,0,0]"
              if (for_x_HOR_R == p[0,0,0,0,0,0]):
                $ 1049 "for_x_HOR_R≔A_Touch_p[A_VR1]"
                global for_x_HOR_R=A_Touch_p[A_VR1]
              end
              $ 1050 "If for_x_HOR≠p[0,0,0,0,0,0]"
              if (for_x_HOR != p[0,0,0,0,0,0]):
                $ 1051 "x_diff≔get_feature_pose(for_x_HOR_R,A_Touch_p[A_HOR_R])"
                global x_diff=get_feature_pose(for_x_HOR_R,A_Touch_p[A_HOR_R])
                $ 1052 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[x_diff[0],0,0,0,0,0])"
                A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[x_diff[0],0,0,0,0,0])
              end
            end
            $ 1053 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[-offset_2f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[-offset_2f_begin/1000,0,0,0,0,0])
          end
          $ 1054 "VR1"
          $ 1055 "If A_Prepos_l[A_VR1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR1] != p[0,0,0,0,0,0]):
            $ 1056 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 1057 "If for_z_VR1≟p[0,0,0,0,0,0]"
              if (for_z_VR1 == p[0,0,0,0,0,0]):
                $ 1058 "for_z_VR1≔A_Touch_p[A_HOR_R]"
                global for_z_VR1=A_Touch_p[A_HOR_R]
              end
              $ 1059 "If for_z_VR1≠p[0,0,0,0,0,0]"
              if (for_z_VR1 != p[0,0,0,0,0,0]):
                $ 1060 "z_diff≔get_feature_pose(for_z_VR1,A_Touch_p[A_VR1])"
                global z_diff=get_feature_pose(for_z_VR1,A_Touch_p[A_VR1])
                $ 1061 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[z_diff[0],0,0,0,0,0])
              end
            end
            $ 1063 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1064 "VR2"
          $ 1065 "If A_Prepos_l[A_VR2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR2] != p[0,0,0,0,0,0]):
            $ 1066 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1067 "HOR_ML"
          $ 1068 "If A_Prepos_l[A_HOR_ML]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_ML] != p[0,0,0,0,0,0]):
            $ 1069 "A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_ML]"
            A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_ML]
            $ 1070 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])"
            global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])
            $ 1071 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_ML], p[x_welding_axis[0],0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_ML], p[x_welding_axis[0],0,0,0,0,0])
            $ 1072 "A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])"
            A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])
            $ 1073 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[10/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[10/1000,0,0,0,0,0])
            $ 1074 "If b1_cell_info_L≟C or b1_cell_info_L≟D"
            if (b1_cell_info_L == C  or  b1_cell_info_L == D):
              $ 1076 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])"
              global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])
              $ 1077 "A_Touch_p[A_HOR_ML]=pose_trans(A_Touch_p[A_HOR_ML],p[x_welding_axis[0],0,0,0,0,0])"
              A_Touch_p[A_HOR_ML]= pose_trans (A_Touch_p[A_HOR_ML],p[x_welding_axis[0],0,0,0,0,0])
              $ 1078 "A_Touch_p[A_HOR_ML]=pose_trans(A_Touch_p[A_HOR_ML],p[0/1000,0,0,0,0,0])"
              A_Touch_p[A_HOR_ML]= pose_trans (A_Touch_p[A_HOR_ML],p[0/1000,0,0,0,0,0])
            end
          end
          $ 1079 "HOR_MR"
          $ 1080 "If A_Prepos_l[A_HOR_MR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_MR] != p[0,0,0,0,0,0]):
            $ 1082 "A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_MR]"
            A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_MR]
            $ 1083 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])"
            global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])
            $ 1084 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[x_welding_axis[0],0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[x_welding_axis[0],0,0,0,0,0])
            $ 1085 "A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])"
            A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])
            $ 1086 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[-10/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[-10/1000,0,0,0,0,0])
            $ 1087 "If b1_cell_info_R≟C or b1_cell_info_R≟D"
            if (b1_cell_info_R == C  or  b1_cell_info_R == D):
              $ 1089 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])"
              global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])
              $ 1090 "A_Touch_p[A_HOR_MR]=pose_trans(A_Touch_p[A_HOR_MR],p[x_welding_axis[0],0,0,0,0,0])"
              A_Touch_p[A_HOR_MR]= pose_trans (A_Touch_p[A_HOR_MR],p[x_welding_axis[0],0,0,0,0,0])
              $ 1091 "A_Touch_p[A_HOR_MR]=pose_trans(A_Touch_p[A_HOR_MR],p[-0/1000,0,0,0,0,0])"
              A_Touch_p[A_HOR_MR]= pose_trans (A_Touch_p[A_HOR_MR],p[-0/1000,0,0,0,0,0])
            end
          end
          $ 1092 "'Touch Remember On/OFF'"
          # 'Touch Remember On/OFF'
          $ 1093 "write_port_register(180,1)"
          write_port_register(180,1)
        else:
          $ 1094 "Else" "noBreak"
          $ 1095 "Ignore Touch and check error"
          $ 1096 "Auto_cur_cell≔0"
          global Auto_cur_cell=0
          $ 1097 "Loop Auto_cur_cell<Auto_total_cell"
          while (Auto_cur_cell<Auto_total_cell):
            $ 1098 "A_sel_v≔Auto_W_num[Auto_cur_cell]"
            global A_sel_v=Auto_W_num[Auto_cur_cell]
            $ 1099 "If A_sel_v<A_HOR_2path"
            if (A_sel_v<A_HOR_2path):
              $ 1100 "If A_Touch_p[A_sel_v]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_sel_v] == p[0,0,0,0,0,0]):
                $ 1101 "write_port_register(142,120)"
                write_port_register(142,120)
                $ 1102 "Halt"
                halt
              end
            end
            $ 1103 "Auto_cur_cell≔Auto_cur_cell+1"
            global Auto_cur_cell=Auto_cur_cell+1
          end
          $ 1104 "Auto_cur_cell≔0"
          global Auto_cur_cell=0
        end
        $ 1105 "welding"
        $ 1106 "weldings"
        $ 1107 "Auto_cur_cell≔read_port_register(138)"
        global Auto_cur_cell= read_port_register (138)
        $ 1108 "time_cal_trig≔ True "
        global time_cal_trig=  True  
        $ 1109 "Loop Auto_cur_cell<Auto_total_cell"
        while (Auto_cur_cell<Auto_total_cell):
          $ 1110 "write_port_register(138,Auto_cur_cell)"
          write_port_register(138,Auto_cur_cell)
          $ 1111 "running_trig≔ True "
          global running_trig=  True  
          $ 1112 "'[2F_AB - 30] , [2F_CD_LEFT - 100] , [2F_CD_RIGHT - 150] , [3F - ELSE]'"
          # '[2F_AB - 30] , [2F_CD_LEFT - 100] , [2F_CD_RIGHT - 150] , [3F - ELSE]'
          $ 1113 "If Auto_W_num[Auto_cur_cell]≥100 and Auto_W_num[Auto_cur_cell]≤149"
          if (Auto_W_num[Auto_cur_cell] >= 100  and  Auto_W_num[Auto_cur_cell] <= 149):
            $ 1114 "'2F CD LEFT'"
            # '2F CD LEFT'
            $ 1115 "A_sel_v≔A_HOR"
            global A_sel_v=A_HOR
            $ 1116 "A_sel_v_end≔A_HOR_ML"
            global A_sel_v_end=A_HOR_ML
            $ 1117 "A_sel_v2≔A_HOR_M"
            global A_sel_v2=A_HOR_M
            $ 1118 "A_sel_v_end2≔A_HOR_R"
            global A_sel_v_end2=A_HOR_R
            $ 1119 "If floor(Auto_W_num[Auto_cur_cell]/10)≟10"
            if (floor(Auto_W_num[Auto_cur_cell]/10) == 10):
              $ 1120 "current_path≔1"
              global current_path=1
              $ 1121 "multi_path≔1"
              global multi_path=1
            else:
              $ 1122 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟11"
              if (floor(Auto_W_num[Auto_cur_cell]/10) == 11):
                $ 1123 "current_path≔2"
                global current_path=2
                $ 1124 "multi_path≔2"
                global multi_path=2
              else:
                $ 1125 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟12"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 12):
                  $ 1126 "current_path≔3"
                  global current_path=3
                  $ 1127 "multi_path≔3"
                  global multi_path=3
                else:
                  $ 1128 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟13"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 13):
                    $ 1129 "current_path≔4"
                    global current_path=4
                    $ 1130 "multi_path≔4"
                    global multi_path=4
                  end
                end
              end
            end
            $ 1131 "current_2f≔current_2f+1"
            global current_2f=current_2f+1
            $ 1132 "CD_MLR≔ True "
            global CD_MLR=  True  
            $ 1133 "write_port_register(135,A_HOR)"
            write_port_register(135,A_HOR)
            $ 1134 "write_port_register(136,current_2f)"
            write_port_register(136,current_2f)
            $ 1135 "If simulation_mode"
            if (simulation_mode):
              $ 1136 "Call welding_parameter_sim"
              welding_parameter_sim()
            else:
              $ 1137 "Else" "noBreak"
              $ 1138 "Call welding_parameter_init"
              welding_parameter_init()
            end
            $ 1139 "wv_direction≔1"
            global wv_direction=1
            $ 1140 "If Auto_W_num[Auto_cur_cell]%10≟4"
            if (Auto_W_num[Auto_cur_cell]%10 == 4):
              $ 1141 "A_sel_v≔A_HOR_R"
              global A_sel_v=A_HOR_R
              $ 1142 "Call MoveFun"
              MoveFun()
              $ 1143 "A_sel_v≔A_HOR"
              global A_sel_v=A_HOR
            else:
              $ 1144 "ElseIf Auto_W_num[Auto_cur_cell]%10≟0 or Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2"
              if (Auto_W_num[Auto_cur_cell]%10 == 0  or  Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2):
                $ 1145 "Call MoveFun"
                MoveFun()
              end
            end
            $ 1146 "Call weav_welding_2f_CD"
            weav_welding_2f_CD()
          else:
            $ 1147 "ElseIf Auto_W_num[Auto_cur_cell]≥150 and Auto_W_num[Auto_cur_cell]≤189"
            if (Auto_W_num[Auto_cur_cell] >= 150  and  Auto_W_num[Auto_cur_cell] <= 189):
              $ 1148 "'2F CD RIGHT'"
              # '2F CD RIGHT'
              $ 1149 "A_sel_v≔A_HOR_R"
              global A_sel_v=A_HOR_R
              $ 1150 "A_sel_v_end≔A_HOR_MR"
              global A_sel_v_end=A_HOR_MR
              $ 1151 "A_sel_v2≔A_HOR_M"
              global A_sel_v2=A_HOR_M
              $ 1152 "A_sel_v_end2≔A_HOR"
              global A_sel_v_end2=A_HOR
              $ 1153 "If floor(Auto_W_num[Auto_cur_cell]/10)≟15"
              if (floor(Auto_W_num[Auto_cur_cell]/10) == 15):
                $ 1154 "current_path≔1"
                global current_path=1
                $ 1155 "multi_path≔1"
                global multi_path=1
              else:
                $ 1156 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟16"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 16):
                  $ 1157 "current_path≔2"
                  global current_path=2
                  $ 1158 "multi_path≔2"
                  global multi_path=2
                else:
                  $ 1159 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟17"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 17):
                    $ 1160 "current_path≔3"
                    global current_path=3
                    $ 1161 "multi_path≔3"
                    global multi_path=3
                  else:
                    $ 1162 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟18"
                    if (floor(Auto_W_num[Auto_cur_cell]/10) == 18):
                      $ 1163 "current_path≔4"
                      global current_path=4
                      $ 1164 "multi_path≔4"
                      global multi_path=4
                    end
                  end
                end
              end
              $ 1165 "current_2f≔current_2f+1"
              global current_2f=current_2f+1
              $ 1166 "CD_MLR≔ False "
              global CD_MLR=  False  
              $ 1167 "write_port_register(135,A_HOR)"
              write_port_register(135,A_HOR)
              $ 1168 "write_port_register(136,current_2f)"
              write_port_register(136,current_2f)
              $ 1169 "If simulation_mode"
              if (simulation_mode):
                $ 1170 "Call welding_parameter_sim"
                welding_parameter_sim()
              else:
                $ 1171 "Else" "noBreak"
                $ 1172 "Call welding_parameter_init"
                welding_parameter_init()
              end
              $ 1173 "wv_direction≔-1"
              global wv_direction=-1
              $ 1174 "If Auto_W_num[Auto_cur_cell]%10≟4"
              if (Auto_W_num[Auto_cur_cell]%10 == 4):
                $ 1175 "A_sel_v≔A_HOR"
                global A_sel_v=A_HOR
                $ 1176 "Call MoveFun"
                MoveFun()
                $ 1177 "A_sel_v≔A_HOR_R"
                global A_sel_v=A_HOR_R
              else:
                $ 1178 "ElseIf Auto_W_num[Auto_cur_cell]%10≟0 or Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2"
                if (Auto_W_num[Auto_cur_cell]%10 == 0  or  Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2):
                  $ 1179 "Call MoveFun"
                  MoveFun()
                end
              end
              $ 1180 "Call weav_welding_2f_CD"
              weav_welding_2f_CD()
            else:
              $ 1181 "ElseIf Auto_W_num[Auto_cur_cell]≥30 and Auto_W_num[Auto_cur_cell]≤65"
              if (Auto_W_num[Auto_cur_cell] >= 30  and  Auto_W_num[Auto_cur_cell] <= 65):
                $ 1182 "'2F'"
                # '2F'
                $ 1183 "A_sel_v≔A_HOR"
                global A_sel_v=A_HOR
                $ 1184 "A_sel_v_end≔A_HOR_R"
                global A_sel_v_end=A_HOR_R
                $ 1185 "If floor(Auto_W_num[Auto_cur_cell]/10)≟3"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 3):
                  $ 1186 "current_path≔1"
                  global current_path=1
                  $ 1187 "multi_path≔1"
                  global multi_path=1
                else:
                  $ 1188 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟4"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 4):
                    $ 1189 "current_path≔2"
                    global current_path=2
                    $ 1190 "multi_path≔2"
                    global multi_path=2
                  else:
                    $ 1191 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟5"
                    if (floor(Auto_W_num[Auto_cur_cell]/10) == 5):
                      $ 1192 "current_path≔3"
                      global current_path=3
                      $ 1193 "multi_path≔3"
                      global multi_path=3
                    else:
                      $ 1194 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟6"
                      if (floor(Auto_W_num[Auto_cur_cell]/10) == 6):
                        $ 1195 "current_path≔4"
                        global current_path=4
                        $ 1196 "multi_path≔4"
                        global multi_path=4
                      end
                    end
                  end
                end
                $ 1197 "current_2f≔current_2f+1"
                global current_2f=current_2f+1
                $ 1198 "write_port_register(135,A_HOR)"
                write_port_register(135,A_HOR)
                $ 1199 "write_port_register(136,current_2f)"
                write_port_register(136,current_2f)
                $ 1200 "If simulation_mode"
                if (simulation_mode):
                  $ 1201 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1202 "Else" "noBreak"
                  $ 1203 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1204 "If Auto_W_num[Auto_cur_cell]%10≟2"
                if (Auto_W_num[Auto_cur_cell]%10 == 2):
                  $ 1205 "A_sel_v≔A_HOR_R"
                  global A_sel_v=A_HOR_R
                  $ 1206 "Call MoveFun"
                  MoveFun()
                  $ 1207 "A_sel_v≔A_HOR"
                  global A_sel_v=A_HOR
                else:
                  $ 1208 "Else" "noBreak"
                  $ 1209 "Call MoveFun"
                  MoveFun()
                end
                $ 1210 "Call weav_welding_2f"
                weav_welding_2f()
              else:
                $ 1211 "Else" "noBreak"
                $ 1212 "A_sel_v≔Auto_W_num[Auto_cur_cell]"
                global A_sel_v=Auto_W_num[Auto_cur_cell]
                $ 1213 "write_port_register(135,A_sel_v)"
                write_port_register(135,A_sel_v)
                $ 1214 "current_path≔1"
                global current_path=1
                $ 1215 "current_2f≔0"
                global current_2f=0
                $ 1216 "write_port_register(136,current_2f)"
                write_port_register(136,current_2f)
                $ 1217 "If simulation_mode"
                if (simulation_mode):
                  $ 1218 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1219 "Else" "noBreak"
                  $ 1220 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1221 "A_sel_v_end≔A_sel_v+9"
                global A_sel_v_end=A_sel_v+9
                $ 1222 "Call weav_welding_3f"
                weav_welding_3f()
              end
            end
          end
          $ 1223 "Call reset_weld_param"
          reset_weld_param()
          $ 1226 "If get_move_trig≟1"
          if (get_move_trig == 1):
            $ 1227 "If get_next_number≠Auto_cur_cell"
            if (get_next_number != Auto_cur_cell):
              $ 1228 "Auto_cur_cell≔get_next_number"
              global Auto_cur_cell=get_next_number
            else:
              $ 1229 "Else" "noBreak"
              $ 1230 "Auto_cur_cell≔Auto_cur_cell+1"
              global Auto_cur_cell=Auto_cur_cell+1
            end
            $ 1231 "write_port_register(166,0)"
            write_port_register(166,0)
            $ 1232 "write_port_register(167,0)"
            write_port_register(167,0)
            $ 1233 "get_move_trig≔0"
            global get_move_trig=0
          else:
            $ 1234 "Else" "noBreak"
            $ 1235 "Auto_cur_cell≔Auto_cur_cell+1"
            global Auto_cur_cell=Auto_cur_cell+1
          end
        end
        $ 1236 "homeing()"
        homeing()
        $ 1237 "write_port_register(162,1)"
        write_port_register(162,1)
        $ 1238 "write_port_register(180,0)"
        write_port_register(180,0)
        thread_flag_301 = 1
      end
      if (a0_Job_Mode == 2):
        global thread_handler_301=run Thread_if_301()
        while (thread_flag_301 == 0):
          if not(a0_Job_Mode == 2):
            kill thread_handler_301
            thread_flag_301 = 2
          else:
            sync()
          end
        end
      else:
        thread_flag_301 = 2
      end
    end
    $ 1239 "Wait: 0.01"
    sleep(0.01)
    $ 1240 "after init auto"
    $ 1241 "If auto_on"
    if (auto_on):
      $ 1242 "write_port_register(202,0)"
      write_port_register(202,0)
      $ 1243 "timer_1: Stop"
      timer_1_is_counting = False
      $ 1244 "write_welder(0, False )"
      write_welder(0,  False  )
      $ 1245 "write_welder(4, False )"
      write_welder(4,  False  )
      $ 1246 "Call reset_weld_param"
      reset_weld_param()
      $ 1247 "multi_path≔1"
      global multi_path=1
      $ 1248 "auto_on≔ False "
      global auto_on=  False  
      $ 1249 "current_2f≔0"
      global current_2f=0
      $ 1250 "get_center≔get_center_bak"
      global get_center=get_center_bak
      $ 1251 "vr2_p1≔p[0,0,0,0,0,0]"
      global vr2_p1=p[0,0,0,0,0,0]
      $ 1252 "welding_program≔ False "
      global welding_program=  False  
      $ 1253 "start_num≔135"
      global start_num=135
      $ 1254 "Loop start_num<141"
      while (start_num<141):
        $ 1255 "write_port_register(start_num,0)"
        write_port_register(start_num,0)
        $ 1256 "start_num≔start_num+1"
        global start_num=start_num+1
      end
    end
  end
end
