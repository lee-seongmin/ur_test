def samho_main_Fillet_2024_02_13():
  step_count_5ae82350_5487_4ba1_a1cc_34982a72aa39 = 0.0
  thread Step_Counter_Thread_2c366939_5a87_4f2f_9225_c5964de88690():
    while (True):
      step_count_5ae82350_5487_4ba1_a1cc_34982a72aa39 = step_count_5ae82350_5487_4ba1_a1cc_34982a72aa39 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_2c366939_5a87_4f2f_9225_c5964de88690()
  modbus_add_signal("127.0.0.1", 255, 171, 2, "MODBUS_1", False)
  modbus_set_signal_update_frequency("MODBUS_1", 1)
  modbus_add_signal("127.0.0.1", 255, 153, 2, "MODBUS_2", False)
  modbus_set_signal_update_frequency("MODBUS_2", 10)
  modbus_add_signal("127.0.0.1", 255, 154, 2, "MODBUS_3", False)
  modbus_set_signal_update_frequency("MODBUS_3", 10)
  modbus_add_signal("127.0.0.1", 255, 240, 2, "MODBUS_4", False)
  modbus_set_signal_update_frequency("MODBUS_4", 10)
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  set_tool_voltage(24)
  set_tcp(p[-0.20862,-0.00524,0.38449,1.2551,0.019,-2.8747])
  set_payload(2.4, [-0.085, 0.00191, 0.125])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 1)
  set_analog_outputdomain(1, 1)
  set_input_actions_to_default()
  set_tool_digital_input_action(1, "freedrive")
  set_runstate_standard_digital_outputs([0])
  set_runstate_standard_digital_output_to_value(0, 1)
  set_runstate_standard_digital_output_to_value(7, 3)
  global A_Touch_trig_l=[False, True, False, True, True, True, False, True, False, False, False]
  global Auto_cur_cell=3
  global last_wv_line=p[0.52015, 0.38218, -0.0375, -1.74526, -0.73525, -1.7528]
  global Auto_trig=True
  global A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0.52015, 0.38218, -0.0375, -1.74526, -0.73525, -1.7528], p[0, 0, 0, 0, 0, 0], p[0.50413, -0.42159, 0.00426, 1.77234, -0.72849, 1.76591], p[0.52, -0.2132, 0.01111, 1.77234, -0.72849, 1.76591], p[0.51743, 0.37705, -0.04254, -1.78159, 1.77436, -0.70262], p[0, 0, 0, 0, 0, 0], p[0.52006, -0.30606, -0.04378, -1.76775, 1.766, -0.72811], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
  global last_wv_wp1=p[0.52015, 0.38218, -0.0375, -1.74526, -0.73525, -1.7528]
  global last_pose=p[0.52041, 0.38156, 0.01096, -2.11461, -0.89189, -1.42384]
  global A_Distance_list=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global Auto_total_cell=5
  global A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0.4924, 0.36901, -0.00027, -2.2158, -0.90076, -1.37843], p[0, 0, 0, 0, 0, 0], p[0.4524, -0.39099, 0.02973, 1.87806, -1.1242, 1.55521], p[0.4524, -0.16099, 0.02973, 1.87806, -1.1242, 1.55521], p[0.49166, 0.359, 0.00223, -2.36087, -1.03274, -1.30238], p[0, 0, 0, 0, 0, 0], p[0.45295, -0.28098, -0.02711, 2.2659, -1.09056, 1.27338], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
  global Reset_Trig=False
  global Auto_W_num=[4, 31, 32, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global A_Speed_list=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global last_z_bottom=-0.0502
  global last_tilt_deg=[0, -27, 0]
  global Base=p[0.0,0.0,0.0,0.0,0.0,0.0]
  global save_timer=0
  global timer_1=0
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global save_timer_is_counting=False
  global timer_1_is_counting=False
  thread Timer_Thread():
    while (True):
      if (save_timer_is_counting):
        save_timer = save_timer + get_steptime()
      end
      if (timer_1_is_counting):
        timer_1 = timer_1 + get_steptime()
      end
      sync()
    end
  end
  run Timer_Thread()
  def cell_info():
    $ 1514 "cell_info" "noBreak"
    $ 1515 "'cell_setting'"
    # 'cell_setting'
    $ 1516 "a7_f_distance≔get_center"
    global a7_f_distance=get_center
    $ 1517 "'dis + 125'"
    # 'dis + 125'
    $ 1518 "If simulation_mode"
    if (simulation_mode):
      $ 1519 "a6_f_height_l≔190"
      global a6_f_height_l=190
      $ 1520 "a6_f_height_r≔190"
      global a6_f_height_r=190
      $ 1521 "a6_f_width≔690"
      global a6_f_width=690
      $ 1522 "a6_callar_hor≔100"
      global a6_callar_hor=100
      $ 1523 "a6_callar_vert≔100"
      global a6_callar_vert=100
      $ 1524 "center_height≔50"
      global center_height=50
      $ 1525 "EXT_flag1≔integer_to_binary_list(2048)"
      global EXT_flag1= integer_to_binary_list (2048)
      $ 1526 "get_margin_z≔50"
      global get_margin_z=50
    else:
      $ 1527 "Else" "noBreak"
      $ 1528 "a6_f_height_l≔read_port_register(173)"
      global a6_f_height_l= read_port_register (173)
      $ 1529 "a6_f_height_r≔read_port_register(174)"
      global a6_f_height_r= read_port_register (174)
      $ 1530 "a6_f_width≔read_port_register(175)"
      global a6_f_width= read_port_register (175)
      $ 1531 "a6_callar_hor≔read_port_register(181)"
      global a6_callar_hor= read_port_register (181)
      $ 1532 "a6_callar_vert≔read_port_register(182)"
      global a6_callar_vert= read_port_register (182)
      $ 1533 "center_height≔read_port_register(237)"
      global center_height=read_port_register(237)
      $ 1534 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
      global EXT_flag1= integer_to_binary_list ( read_port_register (179))
      $ 1536 "get_margin_z≔read_port_register(238)"
      global get_margin_z=read_port_register(238)
      $ 1538 "If center_height>32765"
      if (center_height>32765):
        $ 1539 "center_height≔center_height-65535"
        global center_height=center_height-65535
      end
      $ 1540 "If get_margin_z>32765"
      if (get_margin_z>32765):
        $ 1541 "get_margin_z≔get_margin_z-65535"
        global get_margin_z=get_margin_z-65535
      end
    end
    $ 1542 "Initialization"
    $ 1543 "CELL_ROBOT_DIST≔a7_f_distance"
    global CELL_ROBOT_DIST=a7_f_distance
    $ 1544 "CELL_WIDTH≔a6_f_width"
    global CELL_WIDTH=a6_f_width
  end
  def robotand_cell_initalizat():
    $ 1545 "robotand_cell_initalizat" "noBreak"
    $ 1546 "If Auto_trig≟ True "
    if (Auto_trig ==   True  ):
      $ 1547 "Auto_trig≔ False "
      global Auto_trig=  False  
      $ 1548 "init"
      $ 1549 "write_port_register(cell_3f_2f_151,0)"
      write_port_register(cell_3f_2f_151,0)
      $ 1550 "write_port_register(cell_info_152,0)"
      write_port_register(cell_info_152,0)
      $ 1551 "write_port_register(weld_req_153,0)"
      write_port_register(weld_req_153,0)
      $ 1552 "write_port_register(touch_cell_155,0)"
      write_port_register(touch_cell_155,0)
      $ 1553 "write_port_register(touch_num_156,0)"
      write_port_register(touch_num_156,0)
      $ 1554 "write_port_register(touch_done_157,0)"
      write_port_register(touch_done_157,0)
      $ 1555 "write_port_register(weld_done_137,0)"
      write_port_register(weld_done_137,0)
      $ 1556 "write_port_register(135,0)"
      write_port_register(135,0)
      $ 1557 "write_port_register(136,0)"
      write_port_register(136,0)
      $ 1558 "write_port_register(165,0)"
      write_port_register(165,0)
      $ 1559 "write_port_register(166,0)"
      write_port_register(166,0)
      $ 1560 "write_port_register(167,0)"
      write_port_register(167,0)
      $ 1561 "write_port_register(169,0)"
      write_port_register(169,0)
      $ 1562 "write_port_register(170,0)"
      write_port_register(170,0)
      $ 1563 "write_port_register(221,0)"
      write_port_register(221,0)
      $ 1564 "write_port_register(222,0)"
      write_port_register(222,0)
      $ 1565 "write_port_register(223,0)"
      write_port_register(223,0)
      $ 1566 "write_port_register(224,0)"
      write_port_register(224,0)
      $ 1567 "write_port_register(225,0)"
      write_port_register(225,0)
      $ 1568 "write_port_register(226,0)"
      write_port_register(226,0)
      $ 1569 "write_port_register(227,0)"
      write_port_register(227,0)
      $ 1570 "write_port_register(228,0)"
      write_port_register(228,0)
      $ 1571 "write_port_register(240,0)"
      write_port_register(240,0)
      $ 1572 "write_port_register(176,0)"
      write_port_register(176,0)
      $ 1573 "write_port_register(177,0)"
      write_port_register(177,0)
      $ 1574 "write_port_register(154,0)"
      write_port_register(154,0)
    end
    $ 1575 "sync()"
    sync()
  end
  def welding_parameter_init():
    $ 1576 "welding_parameter_init" "noBreak"
    $ 1577 "init"
    $ 1578 "If A_sel_v≟A_VL1 or A_sel_v≟A_VL2 or A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL1  or  A_sel_v == A_VL2  or  A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1579 "position_3f2f≔position_3F"
      global position_3f2f=position_3F
      $ 1580 "write_port_register(cell_3f_2f_151,A_sel_v)"
      write_port_register(cell_3f_2f_151,A_sel_v)
      $ 1581 "b8_wv_2f≔ False "
      global b8_wv_2f=  False  
      $ 1582 "d_lean_degree≔0"
      global d_lean_degree=0
    else:
      $ 1583 "Else" "noBreak"
      $ 1584 "position_3f2f≔position_2F"
      global position_3f2f=position_2F
      $ 1585 "b8_wv_2f≔ True "
      global b8_wv_2f=  True  
      $ 1586 "d_lean_degree≔30"
      global d_lean_degree=30
      $ 1587 "write_port_register(cell_3f_2f_151,A_HOR)"
      write_port_register(cell_3f_2f_151,A_HOR)
    end
    $ 1588 "If current_path≥2"
    if (current_path >= 2):
      $ 1589 "write_port_register(cell_info_152,current_path)"
      write_port_register(cell_info_152,current_path)
    else:
      $ 1590 "Else" "noBreak"
      $ 1591 "write_port_register(cell_info_152,1)"
      write_port_register(cell_info_152,1)
    end
    $ 1592 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 1593 "Wait: 0.3"
    sleep(0.3)
    $ 1594 "write_port_register(weld_req_153,1)"
    write_port_register(weld_req_153,1)
    $ 1595 "Wait read_port_register(return_done_240)≟1"
    while (not( read_port_register (return_done_240) == 1)):
      sync()
    end
    $ 1596 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 1597 "touch_m_check≔0"
    global touch_m_check=0
    $ 1598 "start_end_from_pendant"
    $ 1599 "d_start_current≔read_port_register(244)/10"
    global d_start_current= read_port_register (244)/10
    $ 1600 "d_start_voltage≔read_port_register(245)/10"
    global d_start_voltage= read_port_register (245)/10
    $ 1601 "d_start_time≔read_port_register(241)/10"
    global d_start_time= read_port_register (241)/10
    $ 1602 "d_end_current≔read_port_register(249)/10"
    global d_end_current= read_port_register (249)/10
    $ 1603 "d_end_voltage≔read_port_register(250)/10"
    global d_end_voltage= read_port_register (250)/10
    $ 1604 "d_end_time≔read_port_register(246)/10"
    global d_end_time= read_port_register (246)/10
    $ 1605 "d_end_current_2≔read_port_register(254)/10"
    global d_end_current_2= read_port_register (254)/10
    $ 1606 "d_end_voltage_2≔read_port_register(255)/10"
    global d_end_voltage_2= read_port_register (255)/10
    $ 1607 "d_end_time_2≔read_port_register(251)/10"
    global d_end_time_2= read_port_register (251)/10
    $ 1608 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]"
    global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]
    $ 1609 "a0_volt_ref≔read_port_register(231)/10"
    global a0_volt_ref= read_port_register (231)/10
    $ 1610 "a1_amp_ref≔read_port_register(232)/10"
    global a1_amp_ref= read_port_register (232)/10
    $ 1611 "a2_speed_cpm≔read_port_register(233)/10"
    global a2_speed_cpm= read_port_register (233)/10
    $ 1612 "a3_wv_amplitude≔read_port_register(234)/10"
    global a3_wv_amplitude= read_port_register (234)/10
    $ 1613 "a4_wv_frequency≔read_port_register(225)/10"
    global a4_wv_frequency= read_port_register (225)/10
    $ 1614 "b1_appro_param≔0"
    global b1_appro_param=0
    $ 1615 "b4_wv_delay2≔read_port_register(226)/10"
    global b4_wv_delay2= read_port_register (226)/10
    $ 1616 "b6_wv_delay4≔read_port_register(227)/10"
    global b6_wv_delay4= read_port_register (227)/10
    $ 1619 "b3_wv_delay1≔0"
    global b3_wv_delay1=0
    $ 1620 "b5_wv_delay3≔0"
    global b5_wv_delay3=0
    $ 1621 "b3_dealy_all≔[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]"
    global b3_dealy_all=[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]
    $ 1622 "get_width_182≔read_port_register(182)"
    global get_width_182= read_port_register (182)
    $ 1623 "b9_touch_sens≔20"
    global b9_touch_sens=20
    $ 1624 "task_angle≔register_read(228)/10"
    global task_angle=register_read(228)/10
    $ 1625 "Circle_Speed≔a2_speed_cpm"
    global Circle_Speed=a2_speed_cpm
    $ 1626 "CELL_BOTTOM≔a7_cell_bottom"
    global CELL_BOTTOM=a7_cell_bottom
    $ 1627 "a6_scallup_left≔read_port_register(176)"
    global a6_scallup_left= read_port_register (176)
    $ 1628 "a6_scallup_righ≔read_port_register(177)"
    global a6_scallup_righ= read_port_register (177)
    $ 1629 "a5_f_hole≔[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]"
    global a5_f_hole=[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]
    $ 1663 "폴더"
    $ 1664 "offset_2f_x≔7"
    global offset_2f_x=7
    $ 1665 "offset_3f_z≔-5"
    global offset_3f_z=-5
    $ 1666 "If A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1667 "'3F'"
      # '3F'
      $ 1668 "b2_left_par≔ False "
      global b2_left_par=  False  
      $ 1669 "b8_wv_type≔1"
      global b8_wv_type=1
      $ 1670 "If A_sel_v≟A_VR2 and (b1_cell_info_R≟c or b1_cell_info_R≟d)"
      if (A_sel_v == A_VR2  and  (b1_cell_info_R == c  or  b1_cell_info_R == d)):
        $ 1671 "b7_tilt_degree≔[0,0,0]"
        global b7_tilt_degree=[0,0,0]
      else:
        $ 1672 "Else" "noBreak"
        $ 1673 "b7_tilt_degree≔[task_angle,-27,0]"
        global b7_tilt_degree=[task_angle,-27,0]
      end
      $ 1674 "c3_arc_enable≔1"
      global c3_arc_enable=1
    else:
      $ 1675 "ElseIf A_sel_v≟A_VL1 or A_sel_v≟A_VL2"
      if (A_sel_v == A_VL1  or  A_sel_v == A_VL2):
        $ 1676 "'3F'"
        # '3F'
        $ 1677 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1678 "b8_wv_type≔1"
        global b8_wv_type=1
        $ 1679 "If A_sel_v≟A_VL2 and (b1_cell_info_L≟c or b1_cell_info_L≟d)"
        if (A_sel_v == A_VL2  and  (b1_cell_info_L == c  or  b1_cell_info_L == d)):
          $ 1680 "b7_tilt_degree≔[0,0,0]"
          global b7_tilt_degree=[0,0,0]
        else:
          $ 1681 "Else" "noBreak"
          $ 1682 "b7_tilt_degree≔[task_angle,-27,0]"
          global b7_tilt_degree=[task_angle,-27,0]
        end
        $ 1683 "c3_arc_enable≔1"
        global c3_arc_enable=1
      else:
        $ 1684 "Else" "noBreak"
        $ 1685 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1686 "b8_wv_type≔2"
        global b8_wv_type=2
        $ 1687 "If A_sel_v≟A_HOR"
        if (A_sel_v == A_HOR):
          $ 1688 "b7_tilt_degree≔[30,-1*task_angle,0]"
          global b7_tilt_degree=[30,-1*task_angle,0]
        else:
          $ 1689 "Else" "noBreak"
          $ 1691 "b7_tilt_degree≔[30,-1*task_angle,0]"
          global b7_tilt_degree=[30,-1*task_angle,0]
        end
        $ 1693 "c3_arc_enable≔0"
        global c3_arc_enable=0
      end
    end
    $ 1694 "If A_sel_v≟A_VL2 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL2  or  A_sel_v == A_VR2):
      $ 1695 "If b1_cell_info_L≟E or b1_cell_info_L≟e or b1_cell_info_R≟E or b1_cell_info_R≟e"
      if (b1_cell_info_L == E  or  b1_cell_info_L == e  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
        $ 1696 "a8_wv_distance≔read_port_register(182)-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance= read_port_register (182)-a5_f_hole[1]-offset_3f_begin
      else:
        $ 1697 "Else" "noBreak"
        $ 1698 "a8_wv_distance≔read_port_register(182)-offset_3f_begin"
        global a8_wv_distance= read_port_register (182)-offset_3f_begin
      end
    else:
      $ 1703 "Else" "noBreak"
      $ 1704 "If b2_left_par"
      if (b2_left_par):
        $ 1705 "Comment"
        # Comment
        $ 1706 "a8_wv_distance≔a6_f_height_l-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance=a6_f_height_l-a5_f_hole[1]-offset_3f_begin
        $ 1707 "Comment"
        # Comment
      else:
        $ 1708 "Else" "noBreak"
        $ 1709 "a8_wv_distance≔a6_f_height_r-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance=a6_f_height_r-a5_f_hole[1]-offset_3f_begin
      end
    end
    $ 1710 "Ext fun & Squash"
    $ 1711 "If (A_sel_v≟A_VL1 or A_sel_v≟A_VL2) and (b1_cell_info_L≟B or b1_cell_info_L≟D)"
    if ((A_sel_v == A_VL1  or  A_sel_v == A_VL2)  and  (b1_cell_info_L == B  or  b1_cell_info_L == D)):
      $ 1712 "Scallup_check≔ True "
      global Scallup_check=  True  
    else:
      $ 1713 "ElseIf (A_sel_v≟A_VR1 or A_sel_v≟A_VR2) and (b1_cell_info_R≟B or b1_cell_info_R≟D)"
      if ((A_sel_v == A_VR1  or  A_sel_v == A_VR2)  and  (b1_cell_info_R == B  or  b1_cell_info_R == D)):
        $ 1714 "Scallup_check≔ True "
        global Scallup_check=  True  
      else:
        $ 1715 "Else" "noBreak"
        $ 1716 "Scallup_check≔ False "
        global Scallup_check=  False  
      end
    end
    $ 1717 "'squash'"
    # 'squash'
    $ 1718 "If (EXT_flag1[7]≟ True ) and (A_sel_v≠A_HOR) and (A_sel_v≠A_VL2) and (A_sel_v≠A_VR2) and (Scallup_check≟ False ) and (A_sel_v≟A_VL1 and b1_cell_info_L≠E and b1_cell_info_L≠e) and (A_sel_v≟A_VR1 and b1_cell_info_R≠E and b1_cell_info_R≠e)"
    if ((EXT_flag1[7] ==   True  )  and  (A_sel_v != A_HOR)  and  (A_sel_v != A_VL2)  and  (A_sel_v != A_VR2)  and  (Scallup_check ==   False  )  and  (A_sel_v == A_VL1  and  b1_cell_info_L != E  and  b1_cell_info_L != e)  and  (A_sel_v == A_VR1  and  b1_cell_info_R != E  and  b1_cell_info_R != e)):
      $ 1719 "squash"
      $ 1720 "squash_enable≔1"
      global squash_enable=1
      $ 1721 "squash_voltage≔24.5"
      global squash_voltage=24.5
      $ 1722 "squash_current≔190"
      global squash_current=190
      $ 1723 "squash_amp≔7"
      global squash_amp=7
      $ 1724 "squash_speed≔10"
      global squash_speed=10
      $ 1725 "squash_cycle≔8"
      global squash_cycle=8
    else:
      $ 1726 "Else" "noBreak"
      $ 1727 "squash"
      $ 1728 "squash_enable≔0"
      global squash_enable=0
      $ 1729 "squash_voltage≔0"
      global squash_voltage=0
      $ 1730 "squash_current≔0"
      global squash_current=0
      $ 1731 "squash_amp≔0"
      global squash_amp=0
      $ 1732 "squash_speed≔0"
      global squash_speed=0
      $ 1733 "squash_cycle≔0"
      global squash_cycle=0
    end
    $ 1734 "'sladge'"
    # 'sladge'
    $ 1735 "If EXT_flag1[8]≟ True  and EXT_flag1[9]≟ False "
    if (EXT_flag1[8] ==   True    and  EXT_flag1[9] ==   False  ):
      $ 1736 "sludge≔1"
      global sludge=1
    else:
      $ 1737 "ElseIf EXT_flag1[8]≟ False  and EXT_flag1[9]≟ True "
      if (EXT_flag1[8] ==   False    and  EXT_flag1[9] ==   True  ):
        $ 1738 "sludge≔2"
        global sludge=2
      else:
        $ 1739 "Else" "noBreak"
        $ 1740 "sludge≔0"
        global sludge=0
      end
    end
    $ 1741 "waste_cycle≔2"
    global waste_cycle=2
    $ 1742 "c0_offset_x≔read_port_register(229)/10"
    global c0_offset_x= read_port_register (229)/10
    $ 1743 "c0_offset_z≔read_port_register(230)/10"
    global c0_offset_z= read_port_register (230)/10
    $ 1744 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
    global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
    $ 1745 "WV_gap"
    $ 1746 "c5_wv_gap_y≔read_port_register(236)/10"
    global c5_wv_gap_y= read_port_register (236)/10
    $ 1747 "c6_wv_gap_cpm≔read_port_register(235)/10"
    global c6_wv_gap_cpm= read_port_register (235)/10
    $ 1748 "c9_wv_gap_freq≔a4_wv_frequency"
    global c9_wv_gap_freq=a4_wv_frequency
    $ 1749 "If c6_wv_gap_cpm≟a2_speed_cpm and a3_wv_amplitude≟c5_wv_gap_y"
    if (c6_wv_gap_cpm == a2_speed_cpm  and  a3_wv_amplitude == c5_wv_gap_y):
      $ 1750 "c4_gap_enable≔0"
      global c4_gap_enable=0
    else:
      $ 1751 "Else" "noBreak"
      $ 1752 "c4_gap_enable≔1"
      global c4_gap_enable=1
    end
    $ 1753 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
    global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
    $ 1754 "arc_sen"
    $ 1755 "c3_X_p_gain≔read_port_register(186)/10"
    global c3_X_p_gain= read_port_register (186)/10
    $ 1756 "c3_X_i_gain≔read_port_register(187)/10"
    global c3_X_i_gain= read_port_register (187)/10
    $ 1757 "c3_Z_p_gain≔read_port_register(184)/10"
    global c3_Z_p_gain= read_port_register (184)/10
    $ 1758 "c3_Z_i_gain≔read_port_register(185)/10"
    global c3_Z_i_gain= read_port_register (185)/10
    $ 1759 "c3_wv_arc_fix≔0"
    global c3_wv_arc_fix=0
    $ 1760 "c3_wv_arc≔[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]"
    global c3_wv_arc=[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]
    $ 1761 "volt and current"
    $ 1762 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
    set_current_voltage(a1_amp_ref,a0_volt_ref)
    $ 1763 "write_port_register(154,1)"
    write_port_register(154,1)
    $ 1764 "Wait read_port_register(return_done_240)≟0"
    while (not( read_port_register (return_done_240) == 0)):
      sync()
    end
    $ 1765 "write_port_register(154,0)"
    write_port_register(154,0)
  end
  def welding_parameter_sim():
    $ 1766 "welding_parameter_sim" "noBreak"
    $ 1767 "init"
    $ 1768 "If A_sel_v≟A_VL1 or A_sel_v≟A_VL2 or A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL1  or  A_sel_v == A_VL2  or  A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1769 "position_3f2f≔position_3F"
      global position_3f2f=position_3F
      $ 1770 "write_port_register(cell_3f_2f_151,A_sel_v)"
      write_port_register(cell_3f_2f_151,A_sel_v)
      $ 1771 "b8_wv_2f≔ False "
      global b8_wv_2f=  False  
      $ 1772 "d_lean_degree≔0"
      global d_lean_degree=0
    else:
      $ 1773 "Else" "noBreak"
      $ 1774 "position_3f2f≔position_2F"
      global position_3f2f=position_2F
      $ 1775 "b8_wv_2f≔ True "
      global b8_wv_2f=  True  
      $ 1776 "d_lean_degree≔30"
      global d_lean_degree=30
      $ 1777 "write_port_register(cell_3f_2f_151,A_HOR)"
      write_port_register(cell_3f_2f_151,A_HOR)
    end
    $ 1778 "If current_path≥2"
    if (current_path >= 2):
      $ 1779 "write_port_register(cell_info_152,current_path)"
      write_port_register(cell_info_152,current_path)
    else:
      $ 1780 "Else" "noBreak"
      $ 1781 "write_port_register(cell_info_152,1)"
      write_port_register(cell_info_152,1)
    end
    $ 1782 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 1783 "Wait: 0.3"
    sleep(0.3)
    $ 1784 "write_port_register(weld_req_153,1)"
    write_port_register(weld_req_153,1)
    $ 1786 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 1787 "touch_m_check≔0"
    global touch_m_check=0
    $ 1788 "start_end_from_pendant"
    $ 1789 "d_start_current≔read_port_register(244)/10"
    global d_start_current= read_port_register (244)/10
    $ 1790 "d_start_voltage≔read_port_register(245)/10"
    global d_start_voltage= read_port_register (245)/10
    $ 1791 "d_start_time≔read_port_register(241)/10"
    global d_start_time= read_port_register (241)/10
    $ 1792 "d_end_current≔read_port_register(249)/10"
    global d_end_current= read_port_register (249)/10
    $ 1793 "d_end_voltage≔read_port_register(250)/10"
    global d_end_voltage= read_port_register (250)/10
    $ 1794 "d_end_time≔read_port_register(246)/10"
    global d_end_time= read_port_register (246)/10
    $ 1795 "d_end_current_2≔read_port_register(254)/10"
    global d_end_current_2= read_port_register (254)/10
    $ 1796 "d_end_voltage_2≔read_port_register(255)/10"
    global d_end_voltage_2= read_port_register (255)/10
    $ 1797 "d_end_time_2≔read_port_register(251)/10"
    global d_end_time_2= read_port_register (251)/10
    $ 1798 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]"
    global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]
    $ 1799 "a0_volt_ref≔read_port_register(231)/10"
    global a0_volt_ref= read_port_register (231)/10
    $ 1800 "a1_amp_ref≔read_port_register(232)/10"
    global a1_amp_ref= read_port_register (232)/10
    $ 1801 "b1_appro_param≔0"
    global b1_appro_param=0
    $ 1802 "Folder"
    $ 1803 "a2_speed_cpm≔17"
    global a2_speed_cpm=17
    $ 1804 "a3_wv_amplitude≔5"
    global a3_wv_amplitude=5
    $ 1805 "a4_wv_frequency≔1.4"
    global a4_wv_frequency=1.4
    $ 1806 "b4_wv_delay2≔0.3"
    global b4_wv_delay2=0.3
    $ 1807 "b6_wv_delay4≔0.3"
    global b6_wv_delay4=0.3
    $ 1808 "b9_touch_sens≔10"
    global b9_touch_sens=10
    $ 1809 "task_angle≔0"
    global task_angle=0
    $ 1810 "a6_scallup_left≔0"
    global a6_scallup_left=0
    $ 1811 "a6_scallup_righ≔0"
    global a6_scallup_righ=0
    $ 1812 "b3_wv_delay1≔0"
    global b3_wv_delay1=0
    $ 1813 "b5_wv_delay3≔0"
    global b5_wv_delay3=0
    $ 1814 "b3_dealy_all≔[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]"
    global b3_dealy_all=[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]
    $ 1815 "get_width_182≔a6_callar_vert"
    global get_width_182=a6_callar_vert
    $ 1816 "task_angle≔register_read(228)/10"
    global task_angle=register_read(228)/10
    $ 1817 "Circle_Speed≔a2_speed_cpm"
    global Circle_Speed=a2_speed_cpm
    $ 1818 "CELL_BOTTOM≔a7_cell_bottom"
    global CELL_BOTTOM=a7_cell_bottom
    $ 1819 "a5_f_hole≔[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]"
    global a5_f_hole=[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]
    $ 1820 "폴더"
    $ 1821 "offset_2f_x≔7"
    global offset_2f_x=7
    $ 1822 "offset_3f_z≔-5"
    global offset_3f_z=-5
    $ 1823 "If A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1824 "'3F'"
      # '3F'
      $ 1825 "b2_left_par≔ False "
      global b2_left_par=  False  
      $ 1826 "b8_wv_type≔1"
      global b8_wv_type=1
      $ 1827 "b7_tilt_degree≔[task_angle,-27,0]"
      global b7_tilt_degree=[task_angle,-27,0]
      $ 1828 "c3_arc_enable≔1"
      global c3_arc_enable=1
    else:
      $ 1829 "ElseIf A_sel_v≟A_VL1 or A_sel_v≟A_VL2"
      if (A_sel_v == A_VL1  or  A_sel_v == A_VL2):
        $ 1830 "'3F'"
        # '3F'
        $ 1831 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1832 "b8_wv_type≔1"
        global b8_wv_type=1
        $ 1833 "b7_tilt_degree≔[task_angle,-27,0]"
        global b7_tilt_degree=[task_angle,-27,0]
        $ 1834 "c3_arc_enable≔1"
        global c3_arc_enable=1
      else:
        $ 1835 "Else" "noBreak"
        $ 1836 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1837 "b8_wv_type≔2"
        global b8_wv_type=2
        $ 1838 "b7_tilt_degree≔[30,-1*task_angle,0]"
        global b7_tilt_degree=[30,-1*task_angle,0]
        $ 1840 "c3_arc_enable≔0"
        global c3_arc_enable=0
      end
    end
    $ 1841 "If A_sel_v≟A_VL2 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL2  or  A_sel_v == A_VR2):
      $ 1842 "a8_wv_distance≔read_port_register(182)"
      global a8_wv_distance= read_port_register (182)
    else:
      $ 1847 "Else" "noBreak"
      $ 1848 "If b2_left_par"
      if (b2_left_par):
        $ 1849 "Comment"
        # Comment
        $ 1850 "a8_wv_distance≔a6_f_height_l-a5_f_hole[1]"
        global a8_wv_distance=a6_f_height_l-a5_f_hole[1]
        $ 1851 "Comment"
        # Comment
      else:
        $ 1852 "Else" "noBreak"
        $ 1853 "a8_wv_distance≔a6_f_height_r-a5_f_hole[1]"
        global a8_wv_distance=a6_f_height_r-a5_f_hole[1]
      end
    end
    $ 1854 "Ext fun & Squash"
    $ 1855 "If (A_sel_v≟A_VL1 or A_sel_v≟A_VL2) and (b1_cell_info_L≟B or b1_cell_info_L≟D)"
    if ((A_sel_v == A_VL1  or  A_sel_v == A_VL2)  and  (b1_cell_info_L == B  or  b1_cell_info_L == D)):
      $ 1856 "Scallup_check≔ True "
      global Scallup_check=  True  
    else:
      $ 1857 "ElseIf (A_sel_v≟A_VR1 or A_sel_v≟A_VR2) and (b1_cell_info_R≟B or b1_cell_info_R≟D)"
      if ((A_sel_v == A_VR1  or  A_sel_v == A_VR2)  and  (b1_cell_info_R == B  or  b1_cell_info_R == D)):
        $ 1858 "Scallup_check≔ True "
        global Scallup_check=  True  
      else:
        $ 1859 "Else" "noBreak"
        $ 1860 "Scallup_check≔ False "
        global Scallup_check=  False  
      end
    end
    $ 1861 "If (EXT_flag1[7]≟ True ) and (A_sel_v≠A_HOR) and (A_sel_v≠A_VL2) and (A_sel_v≠A_VR2) and (Scallup_check≟ False )"
    if ((EXT_flag1[7] ==   True  )  and  (A_sel_v != A_HOR)  and  (A_sel_v != A_VL2)  and  (A_sel_v != A_VR2)  and  (Scallup_check ==   False  )):
      $ 1862 "squash"
      $ 1863 "squash_enable≔1"
      global squash_enable=1
      $ 1864 "squash_voltage≔24.5"
      global squash_voltage=24.5
      $ 1865 "squash_current≔190"
      global squash_current=190
      $ 1866 "squash_amp≔7"
      global squash_amp=7
      $ 1867 "squash_speed≔10"
      global squash_speed=10
      $ 1868 "squash_cycle≔8"
      global squash_cycle=8
    else:
      $ 1869 "Else" "noBreak"
      $ 1870 "squash"
      $ 1871 "squash_enable≔0"
      global squash_enable=0
      $ 1872 "squash_voltage≔0"
      global squash_voltage=0
      $ 1873 "squash_current≔0"
      global squash_current=0
      $ 1874 "squash_amp≔0"
      global squash_amp=0
      $ 1875 "squash_speed≔0"
      global squash_speed=0
      $ 1876 "squash_cycle≔0"
      global squash_cycle=0
    end
    $ 1877 "waste_cycle≔2"
    global waste_cycle=2
    $ 1878 "c0_offset_x≔read_port_register(229)/10"
    global c0_offset_x= read_port_register (229)/10
    $ 1879 "c0_offset_z≔read_port_register(230)/10"
    global c0_offset_z= read_port_register (230)/10
    $ 1880 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
    global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
    $ 1881 "WV_gap"
    $ 1882 "c5_wv_gap_y≔a3_wv_amplitude"
    global c5_wv_gap_y=a3_wv_amplitude
    $ 1883 "c6_wv_gap_cpm≔a2_speed_cpm"
    global c6_wv_gap_cpm=a2_speed_cpm
    $ 1884 "c9_wv_gap_freq≔a4_wv_frequency"
    global c9_wv_gap_freq=a4_wv_frequency
    $ 1885 "If c6_wv_gap_cpm≟a2_speed_cpm and a3_wv_amplitude≟c5_wv_gap_y"
    if (c6_wv_gap_cpm == a2_speed_cpm  and  a3_wv_amplitude == c5_wv_gap_y):
      $ 1886 "c4_gap_enable≔0"
      global c4_gap_enable=0
    else:
      $ 1887 "Else" "noBreak"
      $ 1888 "c4_gap_enable≔1"
      global c4_gap_enable=1
    end
    $ 1889 "c4_gap_enable≔0"
    global c4_gap_enable=0
    $ 1890 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
    global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
    $ 1891 "arc_sen"
    $ 1892 "c3_X_p_gain≔read_port_register(186)/10"
    global c3_X_p_gain= read_port_register (186)/10
    $ 1893 "c3_X_i_gain≔read_port_register(187)/10"
    global c3_X_i_gain= read_port_register (187)/10
    $ 1894 "c3_Z_p_gain≔read_port_register(184)/10"
    global c3_Z_p_gain= read_port_register (184)/10
    $ 1895 "c3_Z_i_gain≔read_port_register(185)/10"
    global c3_Z_i_gain= read_port_register (185)/10
    $ 1896 "c3_wv_arc_fix≔0"
    global c3_wv_arc_fix=0
    $ 1897 "c3_wv_arc≔[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]"
    global c3_wv_arc=[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]
    $ 1898 "volt and current"
    $ 1899 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
    set_current_voltage(a1_amp_ref,a0_volt_ref)
    $ 1900 "write_port_register(154,1)"
    write_port_register(154,1)
    $ 1902 "write_port_register(154,0)"
    write_port_register(154,0)
  end
  def Move_done():
    $ 1903 "Move_done" "noBreak"
    $ 1904 "write_port_register(robot_move_163,0)"
    write_port_register(robot_move_163,0)
    $ 1905 "write_port_register(robot_pose_164,0)"
    write_port_register(robot_pose_164,0)
    $ 1906 "write_port_register(robot_ready_141,1)"
    write_port_register(robot_ready_141,1)
  end
  def MoveFun():
    $ 1907 "MoveFun" "noBreak"
    $ 1908 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1909 "MoveL"
    $ 1910 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
  end
  def MoveFun_cd():
    $ 1911 "MoveFun_cd" "noBreak"
    $ 1912 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1913 "If A_sel_v≟A_VR2 and (b1_cell_info_R≟c or b1_cell_info_R≟d)"
    if (A_sel_v == A_VR2  and  (b1_cell_info_R == c  or  b1_cell_info_R == d)):
      $ 1914 "tilt_deg≔27"
      global tilt_deg=27
      $ 1915 "tilt_deg_ry≔19"
      global tilt_deg_ry=19
      $ 1916 "tilt_deg_rz≔0"
      global tilt_deg_rz=0
    else:
      $ 1917 "Else" "noBreak"
      $ 1918 "tilt_deg≔10"
      global tilt_deg=10
      $ 1919 "tilt_deg_ry≔5"
      global tilt_deg_ry=5
      $ 1920 "tilt_deg_rz≔0"
      global tilt_deg_rz=0
    end
    $ 1921 "If b2_left_par"
    if (b2_left_par):
      $ 1922 "b_touch_pos≔pose_add(b_touch_pos, p[0,18/1000,0,0,0,0])"
      global b_touch_pos= pose_add (b_touch_pos, p[0,18/1000,0,0,0,0])
      $ 1923 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0,0,d2r(-tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0,0,d2r(-tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 1924 "Else" "noBreak"
      $ 1925 "b_touch_pos≔pose_add(b_touch_pos, p[0,-18/1000,0,0,0,0])"
      global b_touch_pos= pose_add (b_touch_pos, p[0,-18/1000,0,0,0,0])
      $ 1926 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
    end
    $ 1927 "MoveL"
    $ 1928 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
  end
  def MoveandTouchFun_2f():
    $ 1929 "MoveandTouchFun_2f" "noBreak"
    $ 1930 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1931 "tilt_deg≔3"
    global tilt_deg=3
    $ 1932 "tilt_deg_ry≔3"
    global tilt_deg_ry=3
    $ 1933 "tilt_deg_rz≔0"
    global tilt_deg_rz=0
    $ 1934 "If  False "
    if (  False  ):
      $ 1935 "Wait: 0.01"
      sleep(0.01)
    else:
      $ 1936 "ElseIf A_sel_v≟A_HOR and b1_cell_info_L≟E"
      if (A_sel_v == A_HOR  and  b1_cell_info_L == E):
        $ 1937 "tilt_deg≔6"
        global tilt_deg=6
        $ 1938 "tilt_deg_ry≔-5"
        global tilt_deg_ry=-5
        $ 1939 "tilt_deg_rz≔0"
        global tilt_deg_rz=0
        $ 1940 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
        global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
      else:
        $ 1941 "ElseIf A_sel_v≟A_HOR_R and b1_cell_info_R≟E"
        if (A_sel_v == A_HOR_R  and  b1_cell_info_R == E):
          $ 1942 "tilt_deg≔6"
          global tilt_deg=6
          $ 1943 "tilt_deg_ry≔-5"
          global tilt_deg_ry=-5
          $ 1944 "tilt_deg_rz≔0"
          global tilt_deg_rz=0
          $ 1945 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
          global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
        else:
          $ 1946 "ElseIf b2_left_par"
          if (b2_left_par):
            $ 1947 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
            global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
          else:
            $ 1948 "Else" "noBreak"
            $ 1949 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
            global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
          end
        end
      end
    end
    $ 1950 "MoveL"
    $ 1951 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
    $ 1952 "Touch_2f"
    $ 1953 "If  False "
    if (  False  ):
      $ 1954 "Wait: 0.01"
      sleep(0.01)
    else:
      $ 1955 "ElseIf A_sel_v≟A_HOR and b1_cell_info_L≟E"
      if (A_sel_v == A_HOR  and  b1_cell_info_L == E):
        $ 1956 "tilt_deg≔3"
        global tilt_deg=3
        $ 1957 "tilt_deg_ry≔3"
        global tilt_deg_ry=3
        $ 1958 "tilt_deg_rz≔0"
        global tilt_deg_rz=0
        $ 1959 "b_touch_pos2≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
        global b_touch_pos2= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
        $ 1960 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)"
        global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)
      else:
        $ 1961 "ElseIf A_sel_v≟A_HOR_R and b1_cell_info_R≟E"
        if (A_sel_v == A_HOR_R  and  b1_cell_info_R == E):
          $ 1962 "tilt_deg≔3"
          global tilt_deg=3
          $ 1963 "tilt_deg_ry≔3"
          global tilt_deg_ry=3
          $ 1964 "tilt_deg_rz≔0"
          global tilt_deg_rz=0
          $ 1965 "b_touch_pos2≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
          global b_touch_pos2= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
          $ 1966 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)"
          global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)
        else:
          $ 1967 "Else" "noBreak"
          $ 1968 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos,b2_left_par,b9_touch_sens)"
          global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos,b2_left_par,b9_touch_sens)
        end
      end
    end
    $ 1970 "If b2_left_par"
    if (b2_left_par):
      $ 1971 "touch_result≔pose_trans(touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])
    else:
      $ 1972 "Else" "noBreak"
      $ 1973 "touch_result≔pose_trans(touch_result,p[(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[(Touch_dis)/1000,0,0,0,0,0])
    end
    $ 1974 "A_Touch_p[A_sel_v]=touch_result"
    A_Touch_p[A_sel_v]=touch_result
    $ 1975 "If EXT_flag1[3]≟ True "
    if (EXT_flag1[3] ==   True  ):
      $ 1976 "MoveL"
      $ 1977 "manual_tp≔tilt_2f_fun(touch_result,basic_tilt_2f,wv_direction)"
      global manual_tp=tilt_2f_fun(touch_result,basic_tilt_2f,wv_direction)
      $ 1978 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
      global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
      $ 1979 "manual_tp" "breakAfter"
      movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
      $ 1980 "Wait: 1.5"
      sleep(1.5)
    end
  end
  def MoveandTouchFun_3f():
    $ 1981 "MoveandTouchFun_3f" "noBreak"
    $ 1982 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1983 "tilt_deg_ry≔0"
    global tilt_deg_ry=0
    $ 1984 "tilt_deg_rz≔0"
    global tilt_deg_rz=0
    $ 1985 "If b2_left_par"
    if (b2_left_par):
      $ 1986 "tilt_deg≔6"
      global tilt_deg=6
      $ 1987 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 1988 "Else" "noBreak"
      $ 1989 "tilt_deg≔0.5"
      global tilt_deg=0.5
      $ 1990 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(-tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(-tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])
    end
    $ 2001 "move_pre"
    $ 2002 "If (b2_left_par≟ True  and point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032) or (b2_left_par≟ False  and point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)"
    if ((b2_left_par ==   True    and  point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032)  or  (b2_left_par ==   False    and  point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)):
      $ 2003 "if move from home"
      $ 2004 "j_cp≔get_actual_joint_positions()"
      global j_cp= get_actual_joint_positions ()
      $ 2005 "If b2_left_par"
      if (b2_left_par):
        $ 2006 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 2007 "inner_p≔p[-15/1000,-35/1000,0,0,0,0]"
          global inner_p=p[-15/1000,-35/1000,0,0,0,0]
        else:
          $ 2008 "Else" "noBreak"
          $ 2009 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 2010 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=left_j)"
        global j_tp= get_inverse_kin (pose_add(b_touch_pos,inner_p),qnear=left_j)
      else:
        $ 2011 "Else" "noBreak"
        $ 2012 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 2013 "inner_p≔p[-15/1000,35/1000,0,0,0,0]"
          global inner_p=p[-15/1000,35/1000,0,0,0,0]
        else:
          $ 2014 "Else" "noBreak"
          $ 2015 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 2016 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=right_j)"
        global j_tp= get_inverse_kin ( pose_add (b_touch_pos,inner_p),qnear=right_j)
      end
      $ 2017 "j_cp[0]=j_tp[0]"
      j_cp[0]=j_tp[0]
      $ 2018 "j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2"
      j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2
      $ 2019 "j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5"
      j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5
      $ 2020 "j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5"
      j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5
      $ 2021 "j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3"
      j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3
      $ 2022 "j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1"
      j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1
      $ 2023 "MoveJ"
      $ 2024 "j_cp" "breakAfter"
      movej(j_cp, a=1.3962634015954636, v=1.0471975511965976)
      $ 2025 "j_tp≔[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]"
      global j_tp=[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]
    end
    $ 2028 "MoveL"
    $ 2029 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
    $ 2032 "touch_3f_down"
    $ 2034 "touch_result≔touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens,b2_par_cd)"
    global touch_result=touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens,b2_par_cd)
    $ 2035 "If Scallup_check≟ False "
    if (Scallup_check ==   False  ):
      $ 2036 "touch_result≔pose_trans(touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])
    else:
      $ 2037 "Else" "noBreak"
      $ 2038 "Scallup_check≔ False "
      global Scallup_check=  False  
    end
    $ 2041 "A_Touch_p[A_sel_v]=touch_result"
    A_Touch_p[A_sel_v]=touch_result
    $ 2042 "If EXT_flag1[3]≟ True "
    if (EXT_flag1[3] ==   True  ):
      $ 2043 "MoveL"
      $ 2044 "manual_tp≔tilt_3f_fun(A_Touch_p[A_sel_v],basic_tilt_3f,0)"
      global manual_tp=tilt_3f_fun(A_Touch_p[A_sel_v],basic_tilt_3f,0)
      $ 2045 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
      global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
      $ 2046 "manual_tp" "breakAfter"
      movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
      $ 2047 "Wait: 1.5"
      sleep(1.5)
    end
    $ 2048 "touch_3f_up"
    $ 2049 "If A_Prepos_l[A_sel_v_end]≟p[0,0,0,0,0,0]"
    if (A_Prepos_l[A_sel_v_end] == p[0,0,0,0,0,0]):
      $ 2050 "A_Touch_p[A_sel_v_end]=p[0,0,0,0,0,0]"
      A_Touch_p[A_sel_v_end]=p[0,0,0,0,0,0]
    else:
      $ 2051 "Else" "noBreak"
      $ 2052 "b_touch_pos≔A_Prepos_l[A_sel_v_end]"
      global b_touch_pos=A_Prepos_l[A_sel_v_end]
      $ 2053 "MoveL"
      $ 2054 "b_touch_pos" "breakAfter"
      movel(pose_trans(Base, b_touch_pos), a=0.7, v=0.5)
      $ 2055 "touch_result≔touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens)"
      global touch_result=touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens)
      $ 2056 "A_Touch_p[A_sel_v_end]=touch_result"
      A_Touch_p[A_sel_v_end]=touch_result
      $ 2057 "If EXT_flag1[3]≟ True "
      if (EXT_flag1[3] ==   True  ):
        $ 2058 "MoveL"
        $ 2059 "manual_tp≔A_Touch_p[A_sel_v_end]"
        global manual_tp=A_Touch_p[A_sel_v_end]
        $ 2060 "manual_tp≔tilt_3f_fun(A_Touch_p[A_sel_v_end],basic_tilt_3f,0)"
        global manual_tp=tilt_3f_fun(A_Touch_p[A_sel_v_end],basic_tilt_3f,0)
        $ 2061 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
        global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
        $ 2062 "manual_tp" "breakAfter"
        movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
        $ 2063 "Wait: 1.5"
        sleep(1.5)
      end
    end
  end
  def weav_welding_3f():
    $ 2067 "weav_welding_3f" "noBreak"
    $ 2068 "If running_trig≟ True "
    global thread_flag_2068=0
    thread Thread_if_2068():
      $ 2069 "inv_inching(inv_inch_time)"
      inv_inching(inv_inch_time)
      $ 2070 "b_touch_pos≔A_Prepos_l[A_sel_v]"
      global b_touch_pos=A_Prepos_l[A_sel_v]
      $ 2071 "move_pre"
      $ 2072 "If (b2_left_par≟ True  and point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032) or (b2_left_par≟ False  and point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)"
      if ((b2_left_par ==   True    and  point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032)  or  (b2_left_par ==   False    and  point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)):
        $ 2073 "if move from home"
        $ 2074 "j_cp≔get_actual_joint_positions()"
        global j_cp= get_actual_joint_positions ()
        $ 2075 "If b2_left_par"
        if (b2_left_par):
          $ 2076 "If norm(b_touch_pos[1]*1000)>300"
          if (norm(b_touch_pos[1]*1000)>300):
            $ 2077 "inner_p≔p[-15/1000,-35/1000,0,0,0,0]"
            global inner_p=p[-15/1000,-35/1000,0,0,0,0]
          else:
            $ 2078 "Else" "noBreak"
            $ 2079 "inner_p≔p[0,0,0,0,0,0]"
            global inner_p=p[0,0,0,0,0,0]
          end
          $ 2080 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=left_j)"
          global j_tp= get_inverse_kin (pose_add(b_touch_pos,inner_p),qnear=left_j)
        else:
          $ 2081 "Else" "noBreak"
          $ 2082 "If norm(b_touch_pos[1]*1000)>300"
          if (norm(b_touch_pos[1]*1000)>300):
            $ 2083 "inner_p≔p[-15/1000,35/1000,0,0,0,0]"
            global inner_p=p[-15/1000,35/1000,0,0,0,0]
          else:
            $ 2084 "Else" "noBreak"
            $ 2085 "inner_p≔p[0,0,0,0,0,0]"
            global inner_p=p[0,0,0,0,0,0]
          end
          $ 2086 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=right_j)"
          global j_tp= get_inverse_kin ( pose_add (b_touch_pos,inner_p),qnear=right_j)
        end
        $ 2087 "j_cp[0]=j_tp[0]"
        j_cp[0]=j_tp[0]
        $ 2088 "j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2"
        j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2
        $ 2089 "j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5"
        j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5
        $ 2090 "j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5"
        j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5
        $ 2091 "j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3"
        j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3
        $ 2092 "j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1"
        j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1
        $ 2093 "MoveJ"
        $ 2094 "j_cp" "breakAfter"
        movej(j_cp, a=1.3962634015954636, v=1.0471975511965976)
        $ 2095 "j_tp≔[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]"
        global j_tp=[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]
      end
      $ 2098 "If (b2_left_par≟ True ) and (b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c) and (A_sel_v≠A_VL2)"
      if ((b2_left_par ==   True  )  and  (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c)  and  (A_sel_v != A_VL2)):
        $ 2099 "begin_3f_p≔pose_trans(A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])"
        global begin_3f_p= pose_trans (A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])
      else:
        $ 2100 "ElseIf (b2_left_par≟ False ) and (b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c) and (A_sel_v≠A_VR2)"
        if ((b2_left_par ==   False  )  and  (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c)  and  (A_sel_v != A_VR2)):
          $ 2101 "begin_3f_p≔pose_trans(A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])"
          global begin_3f_p= pose_trans (A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])
        else:
          $ 2102 "Else" "noBreak"
          $ 2103 "begin_3f_p≔A_Touch_p[A_sel_v]"
          global begin_3f_p=A_Touch_p[A_sel_v]
        end
      end
      $ 2104 "If b2_left_par≟ False "
      if (b2_left_par ==   False  ):
        $ 2105 "If (b1_cell_info_R≟c or b1_cell_info_R≟d) and A_sel_v≟A_VR2"
        if ((b1_cell_info_R == c  or  b1_cell_info_R == d)  and  A_sel_v == A_VR2):
          $ 2107 "b7_tilt_degree≔[-72,-20,15]"
          global b7_tilt_degree=[-72,-20,15]
          $ 2108 "begin_3f_p=pose_add(begin_3f_p,p[-6/1000,-1.5/1000,0,0,0,0])"
          begin_3f_p= pose_add (begin_3f_p,p[-6/1000,-1.5/1000,0,0,0,0])
          $ 2109 "a2_speed_cpm≔a2_speed_cpm*1"
          global a2_speed_cpm=a2_speed_cpm*1
          $ 2110 "a3_wv_amplitude≔a3_wv_amplitude*1"
          global a3_wv_amplitude=a3_wv_amplitude*1
          $ 2111 "a4_wv_frequency≔a4_wv_frequency*1"
          global a4_wv_frequency=a4_wv_frequency*1
          $ 2112 "b3_dealy_all≔[0,b4_wv_delay2*1,0,b6_wv_delay4*1]"
          global b3_dealy_all=[0,b4_wv_delay2*1,0,b6_wv_delay4*1]
          $ 2113 "a0_volt_ref≔a0_volt_ref*1"
          global a0_volt_ref=a0_volt_ref*1
          $ 2114 "a1_amp_ref≔a1_amp_ref*1"
          global a1_amp_ref=a1_amp_ref*1
          $ 2115 "volt and current"
          $ 2116 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
          global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
          $ 2117 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
          set_current_voltage(a1_amp_ref,a0_volt_ref)
        end
      end
      $ 2126 "welding_result = line_weaving_tp(begin_3f_p,A_Touch_p[A_sel_v_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
      welding_result = line_weaving_tp(begin_3f_p,A_Touch_p[A_sel_v_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
      thread_flag_2068 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2068=run Thread_if_2068()
      while (thread_flag_2068 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2068
          thread_flag_2068 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2068 = 2
    end
    $ 2127 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2128 "homeing()"
    homeing()
    $ 2129 "If sludge≟1"
    if (sludge == 1):
      $ 2130 "pause_trig≔ True "
      global pause_trig=  True  
    end
  end
  def weav_welding_2f():
    $ 2131 "weav_welding_2f" "noBreak"
    $ 2132 "If running_trig≟ True "
    global thread_flag_2132=0
    thread Thread_if_2132():
      $ 2133 "Calculation"
      $ 2134 "If Auto_W_num[Auto_cur_cell]≟31 or Auto_W_num[Auto_cur_cell]≟32 or Auto_W_num[Auto_cur_cell]≟30"
      if (Auto_W_num[Auto_cur_cell] == 31  or  Auto_W_num[Auto_cur_cell] == 32  or  Auto_W_num[Auto_cur_cell] == 30):
        $ 2135 "cal_single"
        $ 2136 "pos_m_path≔A_Touch_p[A_HOR]"
        global pos_m_path=A_Touch_p[A_HOR]
        $ 2137 "pos_m_path_end≔A_Touch_p[A_HOR_R]"
        global pos_m_path_end=A_Touch_p[A_HOR_R]
        $ 2138 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
      else:
        $ 2139 "Else" "noBreak"
        $ 2140 "side_offset≔10*current_path"
        global side_offset=10*current_path
        $ 2141 "side_offset≔0"
        global side_offset=0
        $ 2142 "If current_path≟2 or current_path≟4"
        if (current_path == 2  or  current_path == 4):
          $ 2143 "center_offset≔15"
          global center_offset=15
        else:
          $ 2144 "Else" "noBreak"
          $ 2145 "center_offset≔0"
          global center_offset=0
        end
        $ 2146 "cal_multi"
        $ 2147 "pos_m_path≔A_Touch_p[A_HOR]"
        global pos_m_path=A_Touch_p[A_HOR]
        $ 2148 "pos_m_path≔pose_trans(pos_m_path, p[side_offset/1000,0,0,0,0,0])"
        global pos_m_path= pose_trans (pos_m_path, p[side_offset/1000,0,0,0,0,0])
        $ 2149 "pos_m_path_end≔A_Touch_p[A_HOR_R]"
        global pos_m_path_end=A_Touch_p[A_HOR_R]
        $ 2150 "pos_m_path_end≔pose_trans(pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])"
        global pos_m_path_end= pose_trans (pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])
        $ 2151 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2152 "A_middle_weld≔pose_trans(A_middle_weld, p[-center_offset/1000,0,0,0,0,0])"
        global A_middle_weld= pose_trans (A_middle_weld, p[-center_offset/1000,0,0,0,0,0])
      end
      $ 2153 "gap_half"
      $ 2154 "gap_amp_bak≔c5_wv_gap_y"
      global gap_amp_bak=c5_wv_gap_y
      $ 2155 "gap_speed_bak≔c6_wv_gap_cpm"
      global gap_speed_bak=c6_wv_gap_cpm
      $ 2156 "gap_freq_bak≔c9_wv_gap_freq"
      global gap_freq_bak=c9_wv_gap_freq
      $ 2157 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
      global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
      $ 2158 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
      global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
      $ 2159 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
      global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
      $ 2160 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
      global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
      $ 2161 "Weaving"
      $ 2162 "If EXT_flag1[6]"
      if (EXT_flag1[6]):
        $ 2163 "If Auto_W_num[Auto_cur_cell]%10≟1"
        if (Auto_W_num[Auto_cur_cell]%10 == 1):
          $ 2164 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2165 "wv_direction≔1"
          global wv_direction=1
          $ 2166 "welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          $ 2167 "Wait: 0.5"
          sleep(0.5)
        end
        $ 2168 "If Auto_W_num[Auto_cur_cell]%10≟2"
        if (Auto_W_num[Auto_cur_cell]%10 == 2):
          $ 2169 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2170 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
          global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
          $ 2171 "gap_half_right"
          $ 2172 "a3_wv_amplitude≔gap_amp_bak"
          global a3_wv_amplitude=gap_amp_bak
          $ 2173 "a2_speed_cpm≔gap_speed_bak"
          global a2_speed_cpm=gap_speed_bak
          $ 2174 "a4_wv_frequency≔gap_freq_bak"
          global a4_wv_frequency=gap_freq_bak
          $ 2175 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
          global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
          $ 2176 "wv_direction≔-1"
          global wv_direction=-1
          $ 2177 "A_middle_weld≔feature_offset(A_middle_weld,p[-20/1000,0,0,0,0,0],A_Touch_p[A_sel_v])"
          global A_middle_weld=feature_offset(A_middle_weld,p[-20/1000,0,0,0,0,0],A_Touch_p[A_sel_v])
          $ 2178 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
        end
      else:
        $ 2180 "Else" "noBreak"
        $ 2181 "If Auto_W_num[Auto_cur_cell]%10≟0"
        if (Auto_W_num[Auto_cur_cell]%10 == 0):
          $ 2182 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2183 "wv_direction≔1"
          global wv_direction=1
          $ 2184 "welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
        else:
          $ 2185 "Else" "noBreak"
          $ 2186 "write_port_register(142,142)"
          write_port_register(142,142)
          $ 2187 "Halt"
          halt
        end
      end
      thread_flag_2132 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2132=run Thread_if_2132()
      while (thread_flag_2132 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2132
          thread_flag_2132 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2132 = 2
    end
    $ 2188 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2189 "MoveL"
    $ 2190 "Direction: Tool Z-"
    global move_thread_flag_2190=0
    thread move_thread_2190():
      enter_critical
      move_thread_flag_2190 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.03)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_2190 = 2
      exit_critical
    end
    move_thread_flag_2190 = 0
    move_thread_han_2190 = run move_thread_2190()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_2190 > 1):
        join move_thread_han_2190
        $ 2191 "Until (distance)"
        break
      end
      sync()
    end
    $ 2192 "homeing()"
    homeing()
    $ 2193 "If sludge≟1 or (sludge≟2 and current_path>1)"
    if (sludge == 1  or  (sludge == 2  and  current_path>1)):
      $ 2194 "If  not (Auto_W_num[Auto_cur_cell]%10≟1)"
      if (  not  (Auto_W_num[Auto_cur_cell]%10 == 1)):
        $ 2195 "pause_trig≔ True "
        global pause_trig=  True  
      end
    end
  end
  def weav_welding_2f_CD():
    $ 2196 "weav_welding_2f_CD" "noBreak"
    $ 2197 "If running_trig≟ True "
    global thread_flag_2197=0
    thread Thread_if_2197():
      $ 2198 "CD_calculation"
      $ 2199 "If (Auto_W_num[Auto_cur_cell]≥100 and Auto_W_num[Auto_cur_cell]<106)  or (Auto_W_num[Auto_cur_cell]≥150 and Auto_W_num[Auto_cur_cell]<156)"
      if ((Auto_W_num[Auto_cur_cell] >= 100  and  Auto_W_num[Auto_cur_cell]<106)   or  (Auto_W_num[Auto_cur_cell] >= 150  and  Auto_W_num[Auto_cur_cell]<156)):
        $ 2200 "cal single"
        $ 2201 "cal_1"
        $ 2202 "pos_m_path_cd≔A_Touch_p[A_sel_v]"
        global pos_m_path_cd=A_Touch_p[A_sel_v]
        $ 2203 "pos_m_p_end_cd≔A_Touch_p[A_sel_v_end]"
        global pos_m_p_end_cd=A_Touch_p[A_sel_v_end]
        $ 2204 "cal_2"
        $ 2205 "pos_m_path≔A_Touch_p[A_sel_v2]"
        global pos_m_path=A_Touch_p[A_sel_v2]
        $ 2206 "pos_m_path_end≔A_Touch_p[A_sel_v_end2]"
        global pos_m_path_end=A_Touch_p[A_sel_v_end2]
        $ 2207 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
      else:
        $ 2208 "Else" "noBreak"
        $ 2209 "cal multi"
        $ 2210 "side_offset≔0"
        global side_offset=0
        $ 2211 "If current_path≟2 or current_path≟4"
        if (current_path == 2  or  current_path == 4):
          $ 2212 "center_offset≔15"
          global center_offset=15
        else:
          $ 2213 "Else" "noBreak"
          $ 2214 "center_offset≔0"
          global center_offset=0
        end
        $ 2215 "cal_1_multi"
        $ 2216 "pos_m_path_cd≔A_Touch_p[A_sel_v]"
        global pos_m_path_cd=A_Touch_p[A_sel_v]
        $ 2217 "pos_m_path_cd≔pose_trans(pos_m_path_cd, p[side_offset/1000,0,0,0,0,0])"
        global pos_m_path_cd= pose_trans (pos_m_path_cd, p[side_offset/1000,0,0,0,0,0])
        $ 2218 "pos_m_p_end_cd≔A_Touch_p[A_sel_v_end]"
        global pos_m_p_end_cd=A_Touch_p[A_sel_v_end]
        $ 2219 "pos_m_p_end_cd≔pose_trans(pos_m_p_end_cd, p[-side_offset/1000,0,0,0,0,0])"
        global pos_m_p_end_cd= pose_trans (pos_m_p_end_cd, p[-side_offset/1000,0,0,0,0,0])
        $ 2220 "cal_2_multi"
        $ 2221 "pos_m_path≔A_Touch_p[A_sel_v2]"
        global pos_m_path=A_Touch_p[A_sel_v2]
        $ 2222 "pos_m_path≔pose_trans(pos_m_path, p[side_offset/1000,0,0,0,0,0])"
        global pos_m_path= pose_trans (pos_m_path, p[side_offset/1000,0,0,0,0,0])
        $ 2223 "pos_m_path_end≔A_Touch_p[A_sel_v_end2]"
        global pos_m_path_end=A_Touch_p[A_sel_v_end2]
        $ 2224 "pos_m_path_end≔pose_trans(pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])"
        global pos_m_path_end= pose_trans (pos_m_path_end, p[-side_offset/1000,0,0,0,0,0])
        $ 2225 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2226 "A_middle_weld≔pose_trans(A_middle_weld, p[center_offset*wv_direction/1000,0,0,0,0,0])"
        global A_middle_weld= pose_trans (A_middle_weld, p[center_offset*wv_direction/1000,0,0,0,0,0])
      end
      $ 2227 "gap_half"
      $ 2228 "gap_amp_bak≔c5_wv_gap_y"
      global gap_amp_bak=c5_wv_gap_y
      $ 2229 "gap_speed_bak≔c6_wv_gap_cpm"
      global gap_speed_bak=c6_wv_gap_cpm
      $ 2230 "gap_freq_bak≔c9_wv_gap_freq"
      global gap_freq_bak=c9_wv_gap_freq
      $ 2231 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
      global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
      $ 2232 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
      global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
      $ 2233 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
      global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
      $ 2234 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
      global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
      $ 2235 "If EXT_flag1[4]≟ True  and (b1_cell_info_L≠c and b1_cell_info_L≠d and b1_cell_info_R≠c and b1_cell_info_R≠d)"
      if (EXT_flag1[4] ==   True    and  (b1_cell_info_L != c  and  b1_cell_info_L != d  and  b1_cell_info_R != c  and  b1_cell_info_R != d)):
        $ 2236 "If EXT_flag1[6]"
        if (EXT_flag1[6]):
          $ 2237 "If Auto_W_num[Auto_cur_cell]%10≟1"
          if (Auto_W_num[Auto_cur_cell]%10 == 1):
            $ 2238 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2239 "welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,A_middle_weld],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,A_middle_weld],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
          $ 2240 "If Auto_W_num[Auto_cur_cell]%10≟4"
          if (Auto_W_num[Auto_cur_cell]%10 == 4):
            $ 2241 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2242 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
            global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
            $ 2243 "gap_half"
            $ 2244 "a3_wv_amplitude≔gap_amp_bak"
            global a3_wv_amplitude=gap_amp_bak
            $ 2245 "a2_speed_cpm≔gap_speed_bak"
            global a2_speed_cpm=gap_speed_bak
            $ 2246 "a4_wv_frequency≔gap_freq_bak"
            global a4_wv_frequency=gap_freq_bak
            $ 2247 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2248 "wv_direction≔-1*wv_direction"
            global wv_direction=-1*wv_direction
            $ 2249 "A_middle_weld≔feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])"
            global A_middle_weld=feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])
            $ 2250 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
        else:
          $ 2251 "Else" "noBreak"
          $ 2252 "If Auto_W_num[Auto_cur_cell]%10≟0"
          if (Auto_W_num[Auto_cur_cell]%10 == 0):
            $ 2253 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2254 "welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,pos_m_path_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,pos_m_path_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          else:
            $ 2255 "Else" "noBreak"
            $ 2256 "write_port_register(142,142)"
            write_port_register(142,142)
            $ 2257 "Halt"
            halt
          end
        end
      else:
        $ 2258 "Else" "noBreak"
        $ 2259 "If EXT_flag1[6]"
        if (EXT_flag1[6]):
          $ 2260 "If Auto_W_num[Auto_cur_cell]%10≟2"
          if (Auto_W_num[Auto_cur_cell]%10 == 2):
            $ 2261 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2262 "gap_half"
            $ 2263 "gap_amp_bak≔c5_wv_gap_y"
            global gap_amp_bak=c5_wv_gap_y
            $ 2264 "gap_speed_bak≔c6_wv_gap_cpm"
            global gap_speed_bak=c6_wv_gap_cpm
            $ 2265 "gap_freq_bak≔c9_wv_gap_freq"
            global gap_freq_bak=c9_wv_gap_freq
            $ 2266 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
            global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
            $ 2267 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
            global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
            $ 2268 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
            global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
            $ 2269 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2270 "welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2271 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2272 "If Auto_W_num[Auto_cur_cell]%10≟3"
          if (Auto_W_num[Auto_cur_cell]%10 == 3):
            $ 2273 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2274 "welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2275 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2276 "If Auto_W_num[Auto_cur_cell]%10≟4"
          if (Auto_W_num[Auto_cur_cell]%10 == 4):
            $ 2277 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2278 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
            global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
            $ 2279 "gap_half"
            $ 2280 "a3_wv_amplitude≔gap_amp_bak"
            global a3_wv_amplitude=gap_amp_bak
            $ 2281 "a2_speed_cpm≔gap_speed_bak"
            global a2_speed_cpm=gap_speed_bak
            $ 2282 "a4_wv_frequency≔gap_freq_bak"
            global a4_wv_frequency=gap_freq_bak
            $ 2283 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2284 "wv_direction≔-1*wv_direction"
            global wv_direction=-1*wv_direction
            $ 2285 "A_middle_weld≔feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])"
            global A_middle_weld=feature_offset(A_middle_weld,p[20*wv_direction/1000,0,0,0,0,0],A_Touch_p[A_sel_v2])
            $ 2286 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
        else:
          $ 2287 "Else" "noBreak"
          $ 2288 "If Auto_W_num[Auto_cur_cell]%10≟2"
          if (Auto_W_num[Auto_cur_cell]%10 == 2):
            $ 2289 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2290 "c7_wv_gap≔[0,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[0,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2291 "welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2292 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2293 "If Auto_W_num[Auto_cur_cell]%10≟5"
          if (Auto_W_num[Auto_cur_cell]%10 == 5):
            $ 2294 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2295 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2296 "welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2297 "Wait: 0.5"
            sleep(0.5)
          end
        end
      end
      thread_flag_2197 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2197=run Thread_if_2197()
      while (thread_flag_2197 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2197
          thread_flag_2197 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2197 = 2
    end
    $ 2298 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2302 "wv_direction≔1"
    global wv_direction=1
    $ 2303 "If Auto_W_num[Auto_cur_cell]≥150"
    if (Auto_W_num[Auto_cur_cell] >= 150):
      $ 2304 "MoveL"
      $ 2305 "Direction: Base"
      global move_thread_flag_2305=0
      thread move_thread_2305():
        enter_critical
        move_thread_flag_2305 = 1
        local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,1,0.0], 0.03)
        movel(towardsPos, a=0.2, v=0.05)
        move_thread_flag_2305 = 2
        exit_critical
      end
      move_thread_flag_2305 = 0
      move_thread_han_2305 = run move_thread_2305()
      while (True):
        sleep(1.0E-10)
        if (move_thread_flag_2305 > 1):
          join move_thread_han_2305
          $ 2306 "Until (distance)"
          break
        end
        sync()
      end
    else:
      $ 2307 "ElseIf Auto_W_num[Auto_cur_cell]≥100"
      if (Auto_W_num[Auto_cur_cell] >= 100):
        $ 2308 "MoveL"
        $ 2309 "Direction: Base"
        global move_thread_flag_2309=0
        thread move_thread_2309():
          enter_critical
          move_thread_flag_2309 = 1
          local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1,0.0], 0.03)
          movel(towardsPos, a=0.2, v=0.05)
          move_thread_flag_2309 = 2
          exit_critical
        end
        move_thread_flag_2309 = 0
        move_thread_han_2309 = run move_thread_2309()
        while (True):
          sleep(1.0E-10)
          if (move_thread_flag_2309 > 1):
            join move_thread_han_2309
            $ 2310 "Until (distance)"
            break
          end
          sync()
        end
      end
    end
    $ 2311 "MoveL"
    $ 2312 "Direction: Tool Z-"
    global move_thread_flag_2312=0
    thread move_thread_2312():
      enter_critical
      move_thread_flag_2312 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.03)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_2312 = 2
      exit_critical
    end
    move_thread_flag_2312 = 0
    move_thread_han_2312 = run move_thread_2312()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_2312 > 1):
        join move_thread_han_2312
        $ 2313 "Until (distance)"
        break
      end
      sync()
    end
    $ 2314 "homeing()"
    homeing()
    $ 2315 "If sludge≟1 or (sludge≟2 and current_path>1)"
    if (sludge == 1  or  (sludge == 2  and  current_path>1)):
      $ 2316 "If  not (Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2 or Auto_W_num[Auto_cur_cell]%10≟3)"
      if (  not  (Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2  or  Auto_W_num[Auto_cur_cell]%10 == 3)):
        $ 2317 "pause_trig≔ True "
        global pause_trig=  True  
      end
    end
  end
  def reset_weld_param():
    $ 2318 "reset_weld_param" "noBreak"
    $ 2319 "start_num≔225"
    global start_num=225
    $ 2320 "Loop start_num<237"
    while (start_num<237):
      $ 2321 "write_port_register(start_num,0)"
      write_port_register(start_num,0)
      $ 2322 "start_num≔start_num+1"
      global start_num=start_num+1
    end
    $ 2323 "start_num≔240"
    global start_num=240
    $ 2324 "Loop start_num<256"
    while (start_num<256):
      $ 2325 "write_port_register(start_num,0)"
      write_port_register(start_num,0)
      $ 2326 "start_num≔start_num+1"
      global start_num=start_num+1
    end
  end
  def touch_sub():
    $ 2327 "touch_sub" "noBreak"
    $ 2328 "freedrive"
    $ 2329 "save_timer: Start"
    save_timer_is_counting = True
    $ 2330 "Loop save_tool≟ False  and save_timer≤0.5"
    while (get_tool_digital_in(0) ==   False    and  save_timer <= 0.5):
      $ 2331 "If save_tool≟ False "
      if (get_tool_digital_in(0) ==   False  ):
        $ 2332 "save_timer≔0"
        global save_timer=0
      end
      $ 2333 "If freedrive≟ True  and freedrive_trg≟ False "
      if (get_tool_digital_in(1) ==   True    and  freedrive_trg ==   False  ):
        $ 2334 "'Manual - Freedrive'"
        # 'Manual - Freedrive'
        $ 2335 "freedrive_mode()"
        freedrive_mode()
        $ 2336 "freedrive_trg≔ True "
        global freedrive_trg=  True  
      else:
        $ 2337 "ElseIf freedrive≟ False  and freedrive_trg≟ True "
        if (get_tool_digital_in(1) ==   False    and  freedrive_trg ==   True  ):
          $ 2338 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 2339 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
      end
      $ 2340 "If lamp_trig≟ False "
      if (lamp_trig ==   False  ):
        $ 2341 "lamp_trig≔ True "
        global lamp_trig=  True  
      end
      $ 2342 "sync()"
      sync()
    end
    $ 2343 "save_timer: Stop"
    save_timer_is_counting = False
    $ 2344 "save_timer: Reset"
    save_timer = 0
    $ 2345 "write_port_register(touch_done_157,1)"
    write_port_register(touch_done_157,1)
    $ 2346 "Wait read_port_register(touch_done_157)≟0"
    while (not( read_port_register (touch_done_157) == 0)):
      sync()
    end
    $ 2347 "Wait save_tool=LO"
    while (get_tool_digital_in(0) == True):
      sync()
    end
  end
  $ 2 "BeforeStart"
  $ 3 "'RobotVersion'"
  # 'RobotVersion'
  $ 4 "write_port_register(160,54)"
  write_port_register(160,54)
  $ 5 "Teaching for Touch"
  $ 6 "g_current_p≔get_actual_tcp_pose()"
  global g_current_p= get_actual_tcp_pose ()
  $ 7 "MoveJ"
  $ 8 "g_current_p" "breakAfter"
  movej(g_current_p, a=1.3962634015954636, v=1.0471975511965976, r=0.05)
  $ 9 "If  False "
  if (  False  ):
    $ 10 "MoveJ"
    $ 11 "'Home'"
    # 'Home'
    $ 12 "first_p" "breakAfter"
    movej([0.6572912931442261, -1.1853707472430628, -1.1612256209002894, -2.29183799425234, 1.5053011178970337, 2.249363422393799], a=1.3962634015954636, v=1.0471975511965976)
    $ 13 "'3F Left Right'"
    # '3F Left Right'
    $ 14 "left" "breakAfter"
    movej([1.0434843552115187, -1.5100991608390455, -1.7306758129700324, -1.1948061631169296, 1.4628666284450171, 1.848321797880608], a=1.3962634015954636, v=1.0471975511965976)
    $ 15 "right" "breakAfter"
    movej([-0.10351455753530914, -1.3302576856500608, -2.115934992292752, -0.862193753976749, 1.3219395896157813, 2.4264792168573246], a=1.3962634015954636, v=1.0471975511965976)
    $ 16 "'2F Left Right'"
    # '2F Left Right'
    $ 17 "up_left" "breakAfter"
    movej([1.1752926889699076, -1.8019900427886952, -1.320977727654376, -1.5255442863405975, 1.3476341406937622, 2.041365262351603], a=1.3962634015954636, v=1.0471975511965976)
    $ 18 "up_right" "breakAfter"
    movej([-0.490858516659304, -1.5854285429454542, -1.6450882962874376, -1.2830655228732084, 1.6157391701919699, 1.9100727821897805], a=1.3962634015954636, v=1.0471975511965976)
    $ 19 "Packing_pos" "breakAfter"
    movej([1.5877798795700073, -0.0173419157611292, -2.4983108679400843, -1.4065726439105433, 1.626846194267273, 3.0169763565063477], a=1.3962634015954636, v=1.0471975511965976)
    $ 20 "pre_position" "breakAfter"
    movej([1.2637099027633667, -0.695505444203512, -2.0481718222247522, -1.9413569609271448, 2.573765277862549, 1.3775802850723267], a=1.3962634015954636, v=1.0471975511965976)
    $ 21 "middle_pos" "breakAfter"
    movej([-1.8762093791333925, -1.0408674059020342, -1.3551139327963426, -1.843592441478755, 1.9056326083560464, 0.7075109167810423], a=1.3962634015954636, v=1.0471975511965976)
    $ 22 "Mounting_pos" "breakAfter"
    movej([0.6231353085164267, -0.6300961531972575, -0.9034285948871803, -1.770059340221131, 1.417516049558281, 1.7792033261567348], a=1.3962634015954636, v=1.0471975511965976)
    $ 23 "pre_mounting" "breakAfter"
    movej([1.2356762886047363, -0.8703244368182581, -0.942230526600973, -2.3905327955829065, 1.3216267824172974, 2.6514604091644287], a=1.3962634015954636, v=1.0471975511965976)
    $ 24 "'firstly touch center and side, side_L is side touch pose'"
    # 'firstly touch center and side, side_L is side touch pose'
    $ 25 "side_p_L" "breakAfter"
    movej([0.7063748268745771, -1.3604975314992132, -1.990433834727808, -1.0668367667667118, 1.6921872781537495, 1.2509236145111355], a=1.3962634015954636, v=1.0471975511965976)
    $ 26 "side_p_R" "breakAfter"
    movej([0.05431400611996651, -1.4896310011493128, -1.8839471975909632, -1.079590145741598, 1.21127450466156, 2.729013204574585], a=1.3962634015954636, v=1.0471975511965976)
    $ 27 "left_prep_p" "breakAfter"
    movej([0.7465318441390991, -0.9293935934649866, -1.54653245607485, -2.120742146168844, 1.6612900495529175, 1.4639835357666016], a=1.3962634015954636, v=1.0471975511965976)
    $ 28 "right_prep_p" "breakAfter"
    movej([0.07502574473619461, -0.9044721762286585, -1.5771153608905237, -1.9135711828814905, 1.726387619972229, 2.67875337600708], a=1.3962634015954636, v=1.0471975511965976)
    $ 29 "top_right" "breakAfter"
    movej([-0.02242371234582219, -0.9682979219978707, -1.1486403794481532, -1.814672356578109, 1.0564512116488283, 1.9516847799391646], a=1.3962634015954636, v=1.0471975511965976)
    $ 30 "down_right" "breakAfter"
    movej([-0.10387097169690396, -0.8634965401570085, -1.6224404602167288, -1.9527388322769834, 1.2604034373302166, 1.9362943911099855], a=1.3962634015954636, v=1.0471975511965976)
    $ 31 "way_600_3F_VL1" "breakAfter"
    movej([1.4495428629911409, -0.8691188832486789, -1.6280015865128723, -1.109862842185814, 0.958613460846621, 1.8600136596738885], a=1.3962634015954636, v=1.0471975511965976)
    $ 32 "way_3F_42" "breakAfter"
    movej([0.36805654405146704, -0.7862968504575107, -2.173257016154224, -1.4479178800416523, 0.8821879504915225, 2.8855763836420314], a=1.3962634015954636, v=1.0471975511965976)
    $ 33 "Waypoint_3" "breakAfter"
    movej([1.1380372507706311, -0.9407851141189099, -1.233329099346161, -2.2390373632318763, 1.2601061328687342, 1.8320151492624872], a=1.3962634015954636, v=1.0471975511965976)
  end
  $ 34 "waypoint"
  $ 35 "first_p_wp≔first_p"
  global first_p_wp=p[.431245807847, -.007259877891, .087796870964, 2.814824648791, -.024151220978, 1.380109909682]
  $ 36 "home_pos_j≔get_inverse_kin(first_p,qnear=[0.788235068321228, -1.101443115864889, -1.2219904104815882, -2.3243168036090296, 1.506469488143921, 2.3651483058929443])"
  global home_pos_j= get_inverse_kin (p[.431245807847, -.007259877891, .087796870964, 2.814824648791, -.024151220978, 1.380109909682],qnear=[0.788235068321228, -1.101443115864889, -1.2219904104815882, -2.3243168036090296, 1.506469488143921, 2.3651483058929443])
  $ 37 "left_j≔get_inverse_kin(left,qnear=[1.0260889556530308, -1.5106289215345097, -1.741216762689402, -1.178962336228949, 1.4987324920877318, 1.8103628938054515])"
  global left_j= get_inverse_kin (p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605],qnear=[1.0260889556530308, -1.5106289215345097, -1.741216762689402, -1.178962336228949, 1.4987324920877318, 1.8103628938054515])
  $ 38 "right_j≔get_inverse_kin(right,qnear=[-0.04005625546610858, -1.5553040811514833, -1.9086689348599588, -0.877043115030812, 1.298887151057777, 2.511237649551841])"
  global right_j= get_inverse_kin (p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292],qnear=[-0.04005625546610858, -1.5553040811514833, -1.9086689348599588, -0.877043115030812, 1.298887151057777, 2.511237649551841])
  $ 39 "left_prep_p_v≔left_prep_p"
  global left_prep_p_v=p[.305384281395, .209992212444, .052849493181, -2.261254200610, -.979668861910, -1.115042887278]
  $ 40 "right_prep_p_v≔right_prep_p"
  global right_prep_p_v=p[.351918991358, -.200990531927, .062804013870, 2.289356494782, -1.513598216236, 1.281039242610]
  $ 41 "Packing_pos_wp≔Packing_pos"
  global Packing_pos_wp=p[.278714911898, .357008020042, .025408199530, -2.146966801259, .195978635494, -.919933898512]
  $ 42 "pre_position_wp≔pre_position"
  global pre_position_wp=p[-.206981089246, .377817475970, .184983176991, -1.570600793609, -.863923490888, -.089005332274]
  $ 43 "pre_mounting_wp≔pre_mounting"
  global pre_mounting_wp=p[.460443249232, .114922015113, .277198878359, -2.240057458299, .067416497001, -1.614091004704]
  $ 44 "mounting_wp≔Mounting_pos"
  global mounting_wp=p[.365658114054, -.003207132620, .718667154922, -1.220752075696, -.066673751622, -2.363385143972]
  $ 45 "Setting"
  $ 46 "inv_inch_time≔0.4"
  global inv_inch_time=0.4
  $ 47 "a7_cell_bottom≔-50.2"
  global a7_cell_bottom=-50.2
  $ 48 "get_center≔470"
  global get_center=470
  $ 49 "work_touch_dis≔50"
  global work_touch_dis=50
  $ 50 "cd_extra_dis≔6"
  global cd_extra_dis=6
  $ 51 "side_pos_x≔-10"
  global side_pos_x=-10
  $ 52 "sec_touch_dis≔35"
  global sec_touch_dis=35
  $ 53 "Touch_dis≔30"
  global Touch_dis=30
  $ 54 "offset_2f_begin≔5"
  global offset_2f_begin=5
  $ 55 "offset_3f_begin≔5"
  global offset_3f_begin=5
  $ 56 "multi_offset_z≔3"
  global multi_offset_z=3
  $ 57 "simulation_mode≔ False "
  global simulation_mode=  False  
  $ 58 "tilt_deg_man≔7"
  global tilt_deg_man=7
  $ 59 "Initialization"
  $ 60 "reset_revolution_counter()"
  reset_revolution_counter()
  $ 61 "get_center_bak≔get_center"
  global get_center_bak=get_center
  $ 62 "welding_program≔ False "
  global welding_program=  False  
  $ 63 "vr2_p1≔p[0,0,0,0,0,0]"
  global vr2_p1=p[0,0,0,0,0,0]
  $ 64 "running_trig≔ False "
  global running_trig=  False  
  $ 65 "pb_comm_count≔0"
  global pb_comm_count=0
  $ 66 "pendant_hb≔read_port_register(161)"
  global pendant_hb= read_port_register (161)
  $ 67 "pause_trig≔ False "
  global pause_trig=  False  
  $ 68 "multi_path≔1"
  global multi_path=1
  $ 69 "reset_trig≔ False "
  global reset_trig=  False  
  $ 70 "heartbeat≔0"
  global heartbeat=0
  $ 71 "back_2f≔ False "
  global back_2f=  False  
  $ 72 "t_time≔0"
  global t_time=0
  $ 73 "cd_offset≔35"
  global cd_offset=35
  $ 74 "write_port_register(144,0)"
  write_port_register(144,0)
  $ 75 "time_cal_trig≔ False "
  global time_cal_trig=  False  
  $ 76 "current_2f≔0"
  global current_2f=0
  $ 77 "A_cur_2f≔0"
  global A_cur_2f=0
  $ 78 "CD_MLR≔ True "
  global CD_MLR=  True  
  $ 79 "auto_on≔ False "
  global auto_on=  False  
  $ 80 "event_cal_on≔ False "
  global event_cal_on=  False  
  $ 81 "event_side_on≔ False "
  global event_side_on=  False  
  $ 82 "Auto_trig≔ False "
  global Auto_trig=  False  
  $ 83 "lamp_trig≔ False "
  global lamp_trig=  False  
  $ 84 "calcu_trig≔ False "
  global calcu_trig=  False  
  $ 85 "current_path≔1"
  global current_path=1
  $ 86 "freedrive_trg≔ False "
  global freedrive_trg=  False  
  $ 87 "Inch_trg≔ False "
  global Inch_trg=  False  
  $ 88 "wv_direction≔1"
  global wv_direction=1
  $ 89 "Move_trig≔ False "
  global Move_trig=  False  
  $ 90 "CELL_ROBOT_DIST≔500"
  global CELL_ROBOT_DIST=500
  $ 91 "CELL_WIDTH≔700"
  global CELL_WIDTH=700
  $ 92 "CELL_BOTTOM≔a7_cell_bottom"
  global CELL_BOTTOM=a7_cell_bottom
  $ 93 "scallop_info≔ False "
  global scallop_info=  False  
  $ 94 "Carl_info≔ False "
  global Carl_info=  False  
  $ 95 "touch_done_2f≔ False "
  global touch_done_2f=  False  
  $ 96 "get_pose_side≔0"
  global get_pose_side=0
  $ 97 "get_pose_side_t≔0"
  global get_pose_side_t=0
  $ 98 "ba_trig≔ False "
  global ba_trig=  False  
  $ 99 "touch_m_check≔0"
  global touch_m_check=0
  $ 100 "basic_tilt_2f≔[30,5,0]"
  global basic_tilt_2f=[30,5,0]
  $ 102 "basic_tilt_3f≔[0,-27,0]"
  global basic_tilt_3f=[0,-27,0]
  $ 104 "modbus_name"
  $ 105 "weld_done_137≔137"
  global weld_done_137=137
  $ 106 "robot_ready_141≔141"
  global robot_ready_141=141
  $ 107 "cell_3f_2f_151≔151"
  global cell_3f_2f_151=151
  $ 108 "cell_info_152≔152"
  global cell_info_152=152
  $ 109 "weld_req_153≔153"
  global weld_req_153=153
  $ 110 "touch_cell_155≔155"
  global touch_cell_155=155
  $ 111 "touch_num_156≔156"
  global touch_num_156=156
  $ 112 "touch_done_157≔157"
  global touch_done_157=157
  $ 113 "robot_move_163≔163"
  global robot_move_163=163
  $ 114 "robot_pose_164≔164"
  global robot_pose_164=164
  $ 115 "work_type_165≔165"
  global work_type_165=165
  $ 116 "arc_onoff_168≔168"
  global arc_onoff_168=168
  $ 117 "beforeafter_170≔170"
  global beforeafter_170=170
  $ 118 "return_done_240≔240"
  global return_done_240=240
  $ 119 "a0_Job_Mode≔0"
  global a0_Job_Mode=0
  $ 120 "position_3F≔1"
  global position_3F=1
  $ 121 "position_2F≔2"
  global position_2F=2
  $ 122 "cell_par"
  $ 123 "A≔1"
  global A=1
  $ 124 "B≔2"
  global B=2
  $ 125 "C≔3"
  global C=3
  $ 126 "c≔4"
  global c=4
  $ 127 "D≔5"
  global D=5
  $ 128 "d≔6"
  global d=6
  $ 129 "E≔7"
  global E=7
  $ 130 "e≔8"
  global e=8
  $ 131 "A_VL1≔1"
  global A_VL1=1
  $ 132 "A_VL2≔2"
  global A_VL2=2
  $ 133 "A_VR1≔3"
  global A_VR1=3
  $ 134 "A_VR2≔4"
  global A_VR2=4
  $ 135 "A_HOR≔5"
  global A_HOR=5
  $ 136 "A_HOR_R≔7"
  global A_HOR_R=7
  $ 137 "A_HOR_ML≔6"
  global A_HOR_ML=6
  $ 138 "A_HOR_MR≔8"
  global A_HOR_MR=8
  $ 139 "A_HOR_M≔9"
  global A_HOR_M=9
  $ 140 "A_VL1_END≔10"
  global A_VL1_END=10
  $ 141 "A_VL2_END≔11"
  global A_VL2_END=11
  $ 142 "A_VR1_END≔12"
  global A_VR1_END=12
  $ 143 "A_VR2_END≔13"
  global A_VR2_END=13
  $ 144 "A_HOR_2path≔14"
  global A_HOR_2path=14
  $ 145 "A_HOR_3path≔15"
  global A_HOR_3path=15
  $ 146 "A_HOR_4path≔16"
  global A_HOR_4path=16
  $ 147 "A_HOR_2path_CD≔17"
  global A_HOR_2path_CD=17
  $ 148 "A_HOR_3path_CD≔18"
  global A_HOR_3path_CD=18
  $ 149 "A_HOR_4path_CD≔19"
  global A_HOR_4path_CD=19
  $ 150 "Script: UR_samho_weaving_V7.0_CB.script"
  wv_wp1 = p[0,0,0,0,0,0]
  dumy_p = p[0,0,0,0,0,0]
  global background_cal = 0
  global background_pose = [dumy_p,dumy_p,dumy_p,dumy_p]
  global background_ready = 0
  global timer_counter = 0
  global timer_counting = False
  global wcr_counter = 0
  global wcr_counting = False
  global get_wcr = False
  global arc_sens_onoff = 0
  global welding_off_t = 55
  global weld_onoff = False
  global isHicomm = True
  global isTouchWCR = True
  global welding_program = False
  global arc_sens_2F = False
  
  thread thread_timer():
    error_time = 5
    start_gas_time = 2
    while (True):
      if (timer_counting):
        timer_counter = timer_counter + get_steptime()
        write_output_float_register(0,timer_counter)
  
        get_wcr = read_welder(5)
        weld_onoff = read_welder_control(0)
  
        welding_off_t = read_port_register(168)
        if(get_wcr):
          global arc_sens_onoff = 1
        else:
          global arc_sens_onoff = 0
        end
        if(get_wcr and welding_off_t == 2 and weld_onoff == True):
          wcr_counter=0
        elif(wcr_counter>(error_time+start_gas_time) and welding_off_t == 2 and weld_onoff == True):
          write_port_register(202,0)
          write_port_register(149,0)
          write_welder(0,False)
          set_standard_digital_out(0,False)
          write_port_register(142,131)
          sleep(0.5)
          halt
        elif(get_wcr == False and welding_off_t == 2 and weld_onoff == True):
          wcr_counter = wcr_counter + get_steptime()
        end
      end
      sync()
    end
  end
  
  def RTDE_init():
    # timer
    write_output_float_register(0,0)
    # WCR IN
    write_output_float_register(1,0)
    # Welding Current
    write_output_float_register(2,0)
    # Welding Voltage
    write_output_float_register(3,0)
    # X offset
    write_output_float_register(4,0)
    # Z offset
    write_output_float_register(5,0)
    # PLUS Integral
    write_output_float_register(6,0)
    # MINUS Integral
    write_output_float_register(7,0)
    # Standard_Arc_Current
    write_output_float_register(8,0)
    # ALL Integral
    write_output_float_register(9,0)
    # x up
    write_output_float_register(10,0)
    # x ui
    write_output_float_register(11,0)
    # z up
    write_output_float_register(12,0)
    # z ui
    write_output_float_register(13,0)
    # x
    write_output_float_register(14,0)
    # y
    write_output_float_register(15,0)
    # z
    write_output_float_register(16,0)
    # welding on/off polyscope
    write_output_float_register(17,0)
    # touch on/off polyscope
    write_output_float_register(18,0)
    # ratio_t
    write_output_float_register(19,0)
    # get_wcr polyscope
    write_output_float_register(20,0)
    # get_touch polyscope
    write_output_float_register(21,0)
    # write_welder
    write_output_float_register(22,0)
    # MIDDLE_Integral_org
    write_output_float_register(23,0)
    # PLUS Integral_org
    write_output_float_register(24,0)
    # MINUS Integral_org
    write_output_float_register(25,0)
  
    #init
    global cycle_number = 0
    global cycle_done = False
    global cycle1_plus = 0
    global cycle1_minus = 0
    global cycle1_middle = 0
    global current_to_welding_m = read_port_register(133)
    global voltage_to_welding_m = read_port_register(134)/10
    global c_maxcut = current_to_welding_m*1.2
    global c_mincut = current_to_welding_m*0.8
    global v_maxcut = voltage_to_welding_m*1.2
    global v_mincut = voltage_to_welding_m*0.8
    global Standard_Arc_Current = current_to_welding_m
    global Standard_Arc_voltage = voltage_to_welding_m
    global FB_CURRENT_UR = 0
    global FB_VOLTAGE_UR = 0
    global FB_CURRENT_UR_org = 0
    global FB_VOLTAGE_UR_org = 0
    global one_cycle_p_count = 0
    global one_cycle_m_count = 0
    global one_cycle_p_accum = 0
    global one_cycle_m_accum = 0
    global one_cycle_p_accum_org = 0
    global one_cycle_m_accum_org = 0
    global cal_off_ang_rx = 0
    global cal_off_ang_ry = 0
    global Up = 0
    global Ui = 0
    global Pi_sum = 0
    global Up_z = 0
    global Ui_z = 0
    global Pi_sum_z = 0
    global peak_value = 0
    global ratio_t = 0
    global welding_off_t = 55
    global program_weld_on = False
    global next_path_c = False
    global move_p = [dumy_p,dumy_p,dumy_p,dumy_p]
    global hicomm = True
    global current_on = False
    timer_counter = 0
    sync()
  end
  
  # get line distance without caring orientation
  def get_line_dist(get_wp1,get_wp2):
    return sqrt((get_wp2[0]-get_wp1[0])*(get_wp2[0]-get_wp1[0])+(get_wp2[1]-get_wp1[1])*(get_wp2[1]-get_wp1[1])+(get_wp2[2]-get_wp1[2])*(get_wp2[2]-get_wp1[2]))
  end
  
  def plus_minus(num):
    if(num<0):
      return -1
    else:
      return 1
    end
  end
  
  def get_feature_plane_xz(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dy = cross_product(d13, d12)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dy)
    uy = [ dy[0]/temp, dy[1]/temp, dy[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uz = cross_product(ux, uy)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def get_feature_plane_yz(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dx = cross_product(d12, d13)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    uy = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dx)
    ux = [ dx[0]/temp, dx[1]/temp, dx[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uz = cross_product(ux, uy)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def get_feature_plane_xy(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dz = cross_product(d12, d13)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dz)
    uz = [ dz[0]/temp, dz[1]/temp, dz[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uy = cross_product(uz, ux)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  #### ur_weaving_rev1 by Henry
  #  x_feature = pose_trans(N_Pose,pose_inv(p[0,0,x,0,0,0])
  def feature_offset(fun_pose,fun_offset,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    fun_offrot = rotvec2rpy([fun_p_feature[3],fun_p_feature[4],fun_p_feature[5]])
    fun_offset = p[fun_offset[0],fun_offset[1],fun_offset[2],fun_offrot[0]+fun_offset[3],fun_offrot[1]+fun_offset[4],fun_offrot[2]+fun_offset[5]]
    fun_offset_p = p[fun_offset[0],fun_offset[1],fun_offset[2],0,0,0]
    fun_offrpy_rot = rpy2rotvec([fun_offset[3],fun_offset[4],fun_offset[5]])
    fun_offset_rot = p[0,0,0,fun_offrpy_rot[0],fun_offrpy_rot[1],fun_offrpy_rot[2]]
    fun_cal_p = pose_trans(fun_plane,pose_trans(fun_offset_p,fun_p_feature))
    fun_cal_rot = pose_trans(fun_plane,fun_offset_rot)
    result_cal = p[fun_cal_p[0],fun_cal_p[1],fun_cal_p[2],fun_cal_rot[3],fun_cal_rot[4],fun_cal_rot[5]]
    return result_cal
  end
  
  ## same as changing feature in Move command
  ## Set offset into Plane and move position by it
  def plane_offset(fun_pose,p_offset,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    fun_plane = pose_trans(fun_plane,p[p_offset[0],p_offset[1],p_offset[2],0,0,0])
    fun_p_result = pose_trans(pose_trans(fun_plane,p[0,0,0,p_offset[3],p_offset[4],p_offset[5]]),fun_p_feature)
    return fun_p_result
  end
  
  #  convert from rotation matrix to rotation vector
  ####
  def rotmat2rotvec(rotmat):
  
    # array to matrix
    r11 = rotmat[0]
    r21 = rotmat[1]
    r31 = rotmat[2]
    r12 = rotmat[3]
    r22 = rotmat[4]
    r32 = rotmat[5]
    r13 = rotmat[6]
    r23 = rotmat[7]
    r33 = rotmat[8]
  
    # rotation matrix to rotation vector
    theta = acos((r11+r22+r33-1)/2)
    sth = sin(theta)
  
    if ( (theta > d2r(179.99)) or (theta < d2r(-179.99)) ):
      theta = d2r(180)
      if (r21 < 0):
        if (r31 < 0):
          ux = sqrt((r11+1)/2)
          uy = -sqrt((r22+1)/2)
          uz = -sqrt((r33+1)/2)
        else:
          ux = sqrt((r11+1)/2)
          uy = -sqrt((r22+1)/2)
          uz = sqrt((r33+1)/2)
        end
      else:
        if (r31 < 0):
          ux = sqrt((r11+1)/2)
          uy = sqrt((r22+1)/2)
          uz = -sqrt((r33+1)/2)
        else:
          ux = sqrt((r11+1)/2)
          uy = sqrt((r22+1)/2)
          uz = sqrt((r33+1)/2)
        end
      end
    else:
      ux = (r32-r23)/(2*sth)
      uy = (r13-r31)/(2*sth)
      uz = (r21-r12)/(2*sth)
    end
  
    rotvec = [(theta*ux),(theta*uy),(theta*uz)]
  
    return rotvec
  end
  
  # cross product of two vectors u and v
  ####
  def cross_product(u, v):
  
    u1 = u[0]
    u2 = u[1]
    u3 = u[2]
    v1 = v[0]
    v2 = v[1]
    v3 = v[2]
  
    s = [ (u2*v3-u3*v2), (u3*v1-u1*v3), (u1*v2-u2*v1) ]
  
    return s
  end
  ####
  def get_feature_Line(p1, p2):
    p3 = pose_trans(p1,p[0,0,0.01,0,0,0])
    d1 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
    d2 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    dx = cross_product(d1, d2)
    temp = norm(d2)
    uy = [ d2[0]/temp, d2[1]/temp, d2[2]/temp ]
    temp = norm(dx)
    ux = [ dx[0]/temp, dx[1]/temp, dx[2]/temp ]
    uz = cross_product(ux, uy)
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
    rotvec = rotmat2rotvec(rotmat)
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def calculate_p(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=posDir
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  
  def direction(feature, direction, position_distance,fun_speed=50,fun_acc=100):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
  
    thread fun_thread_direction():
      enter_critical
  
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    move_thread_dirr2 = run fun_thread_direction()
    while (True):
      sleep(1.0E-10)
      if (move_flag > 1):
        kill move_thread_dirr2
        break
      end
      sync()
    end
  end
  
  def movej_elbwrist(j_p,fun_height=-0.02,fun_speed=0.5,fun_acc=0.5):
    global g_jp = j_p
    global g_ac = fun_speed
    global g_sp = fun_acc
    global move_flag = 0
    g_cp = get_actual_tcp_pose()
    if(g_cp[2]<fun_height):
      move_flag = 1
      return True
    end
    thread fun_thread_elbwirst():
      enter_critical
      move_flag = 1
      movej(g_jp, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    move_thread_direlb = run fun_thread_elbwirst()
    while(True):
      g_cp = get_actual_tcp_pose()
      sync()
      if (move_flag > 1 or g_cp[2]<fun_height):
        kill move_thread_direlb
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def movel_singu(t_p,fun_speed=0.2,fun_acc=0.4,hard_mode=False):
    global g_pp = t_p
    global g_ac = fun_speed
    global g_sp = fun_acc
    move_flag = 0
    singu_var = singularity(t_p,hard_mode)
    if(singu_var==True):
      move_flag = 1
      return True
    end
    thread fun_thread_movelsingu():
      enter_critical
      move_flag = 1
      movel(g_pp, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    move_thread_dirr = run fun_thread_movelsingu()
    while(True):
      sleep(1.0E-10)
      if (move_flag > 1 or singularity(get_actual_tcp_pose(),hard_mode)):
        kill move_thread_dirr
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def direction_singu(feature, direction, position_distance,fun_speed=50,fun_acc=100,hard_mode=False):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global stepsToRetract = 0
    singu_var = singularity(get_actual_tcp_pose(),hard_mode)
    if(singu_var==True):
      move_flag = 1
      return True
    end
    thread fun_thread_sing():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    thread_han_sing = run fun_thread_sing()
    while (True):
      sleep(1.0E-10)
      if (move_flag > 1 or singularity(get_actual_tcp_pose(),hard_mode)):
        kill thread_han_sing
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def motion_num(m_num = [0,0,0,0,0,0]):
    VL1_r = 1
    VL2_r = 2
    VR1_r = 4
    VR2_r = 8
    HOR_r = 16
    var_i = 0
    r_val = 0
    while(var_i<5):
      if(m_num[var_i] == 1):
        r_val = r_val + VL1_r
      elif(m_num[var_i] == 2):
        r_val = r_val + VL2_r
      elif(m_num[var_i] == 3):
        r_val = r_val + VR1_r
      elif(m_num[var_i] == 4):
        r_val = r_val + VR2_r
      elif(m_num[var_i] == 5):
        r_val = r_val + HOR_r
      end
      var_i = var_i + 1
    end
    return r_val
  end
  
  def touch_cal(Num_L,Num_R,Cell_Sel):
    #VL1:1, VL2:2, VR1:3, VR2:4, HOR:5, HOR_ML:6, HOR_R:7, HOR_MR:8, HOR_M:9 VL1_END:10, VL2_END:11, VR1_END:12, VR2_END:13, HOR_2path:14, HOR_3path:15, HOR_4path:16, HOR_2path_CD:17, HOR_3path_CD:18, HOR_4path_CD:19
    #A : 1, B : 2, C : 3, c : 4, D : 5, d :6, E : 7
    touch_check = [False,False,False,False,False,False,False,False,False,False,False]
    #touch_left, touch_left2
    global Cell_t = integer_to_binary_list(Cell_Sel)
    if(Cell_t[0]==True):
      #touch_left
      touch_check[1] = True
    end
    if(Cell_t[1]==True):
      #touch_left2
      touch_check[2] = True
    end
    if(Cell_t[2]==True):
      #touch_right
      touch_check[3] = True
    end
    if(Cell_t[3]==True):
      #touch_right2
      touch_check[4] = True
    end
  
    if(Cell_t[4]==True):
      #touch_hor is needed for checking
      #left A or B
      touch_check[5] = True
    end
  
    if(Cell_t[4]==True):
      #HOR_R:7
      #right
      touch_check[7] = True
    end
  
    if(Cell_t[4]==True and (Num_L == 3 or Num_L == 4 or Num_L == 5 or Num_L == 6)):
      #HOR_ML:6
      #left c,C,D,d
      touch_check[6] = True
    elif(Cell_t[4]==True and (Num_R == 3 or Num_R == 4 or Num_R == 5 or Num_R == 6)):
      #HOR_MR:8
      #right c,C,D,d
      touch_check[8] = True
    end
    return touch_check
  end
  
  def cpm2mms(cpm_speed):
    return cpm_speed / 6
  end
  
  def time_diff(until_num):
    global get_143 = read_port_register(143)
    get_144 = read_port_register(144)
    global get_time = time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,until_num)
    time_diff = get_143 - get_time
    get_144 = get_144 + time_diff
    # write_port_register(144,get_144)
    return get_144
  end
  
  def time_cal(scenario_l,t_num,speed_l,distance_l,touch_l,until_num=0):
    VL1 = 1
    VL2 = 2
    VR1 = 3
    VR2 = 4
    HOR = 5
    HOR_ML = 6
    HOR_R = 7
    HOR_MR = 8
    HOR_M = 9
    w_time = 0
    t_count = 0
  
    if(until_num == 0):
      f_num = t_num
    else:
      f_num = until_num
    end
  
    while(t_count<f_num):
      c_scenario = scenario_l[t_count]
      if(c_scenario==VL1 or c_scenario==VL2 or c_scenario==VR1 or c_scenario==VR2):
        if(touch_l[c_scenario+9]==p[0,0,0,0,0,0]):
          w_time = w_time + distance_l[c_scenario]/cpm2mms(speed_l[c_scenario])
          w_time = w_time + 1.5
          # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
        else:
          w_time = w_time + point_dist(touch_l[c_scenario],touch_l[c_scenario+9])*1000/cpm2mms(speed_l[c_scenario])
          w_time = w_time + 1.5
          # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
        end
      else:
        w_time = w_time + point_dist(touch_l[HOR],touch_l[HOR_R])*1000/cpm2mms(speed_l[HOR])
        w_time = w_time + 1.5
        # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
      end
      t_count = t_count+1
    end
    return floor(w_time)
  end
  
  # 각 셀의 터치 위치를 바탕으로 내가 이번에 실행할 셀을 순서에 맞게 반환한다.
  # 예시 : value =[1,3] -> VL1, VR1 순서로 실행한다.
  def cell_motion(Touch_Sel,thickness_2f,ext_flag_pend,cell_info_l,cell_info_r):
    ex = 0
    num_2f = 0
    global return_pose = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    val_sum = 0
    VL1 = 1
    VL2 = 2
    VR1 = 3
    VR2 = 4
    HOR = 5
    HOR_ML = 6
    HOR_R = 7
    HOR_MR = 8
    HOR_M = 9
    HOR_2path = 14
    HOR_3path = 15
    HOR_4path = 16
    HOR_2path_CD = 17
    HOR_3path_CD = 18
    HOR_4path_CD = 19
    CD_check = 0
    Cell_l = Touch_Sel
    cell_c = 4
    cell_d = 6
  
    # 분할 X
    HOR_1 = 30
    # 분할 Left
    HOR_2_L = 31
    # 분할 Right
    HOR_2_R = 32
  
    # 분할 X, 2 Path
    HOR_1_2P = 40
    HOR_2_L_2P = 41
    HOR_2_R_2P = 42
  
    # 분할 X, 3 Path
    HOR_1_3P = 50
    HOR_2_R_3P = 52
    HOR_2_L_3P = 51
  
    # 분할 X, 3 Path
    HOR_1_4P = 60
    HOR_2_L_4P = 61
    HOR_2_R_4P = 62
    # EXT 4 이음, EXT 6 분할
    # 이음 O , 분할 X
    HOR_1_CD = 100
    # 이음 O, 분할 O (101 + 104)
    HOR_2_CD_connect = 101
    # 이음 X/O, 분할 O
    HOR_3_CD_left = 102
    # 이음 X, 분할 O (102 + 103 + 104)
    HOR_3_CD_middle = 103
    # 이음 X/O, 분할 O
    HOR_23_CD_right = 104
    # 이음 X, 분할 X (102 + 105)
    HOR_2_CD_midr = 105
  
    HOR_1_CD_2P = 110
    HOR_2_CD_connect_2P = 111
    HOR_3_CD_left_2P = 112
    HOR_3_CD_middle_2P = 113
    HOR_23_CD_right_2P = 114
    HOR_2_CD_midr_2P = 115
  
    HOR_1_CD_3P = 120
    HOR_2_CD_connect_3P = 121
    HOR_3_CD_left_3P = 122
    HOR_3_CD_middle_3P = 123
    HOR_23_CD_right_3P = 124
    HOR_2_CD_midr_3P = 125
  
    HOR_1_CD_4P = 130
    HOR_2_CD_connect_4P = 131
    HOR_3_CD_left_4P = 132
    HOR_3_CD_middle_4P = 133
    HOR_23_CD_right_4P = 134
    HOR_2_CD_midr_4P = 135
  
    RHOR_1_CD = 150
    RHOR_2_CD_connect = 151
    RHOR_3_CD_left = 152
    RHOR_3_CD_middle = 153
    RHOR_23_CD_right = 154
    RHOR_2_CD_midr = 155
  
    RHOR_1_CD_2P = 160
    RHOR_2_CD_connect_2P = 161
    RHOR_3_CD_left_2P = 162
    RHOR_3_CD_middle_2P = 163
    RHOR_23_CD_right_2P = 164
    RHOR_2_CD_midr_2P = 165
  
    RHOR_1_CD_3P = 170
    RHOR_2_CD_connect_3P = 171
    RHOR_3_CD_left_3P = 172
    RHOR_3_CD_middle_3P = 173
    RHOR_23_CD_right_3P = 174
    RHOR_2_CD_midr_3P = 175
  
    RHOR_1_CD_4P = 180
    RHOR_2_CD_connect_4P = 181
    RHOR_3_CD_left_4P = 182
    RHOR_3_CD_middle_4P = 183
    RHOR_23_CD_right_4P = 184
    RHOR_2_CD_midr_4P = 185
  
    l_var = 0
    l_counter=1
    multi_path_n = 10
    if(thickness_2f >=11):
      l_counter = 4
    elif(thickness_2f >=9):
      l_counter = 3
    elif(thickness_2f >=7):
      l_counter = 2
    end
  
    if(Cell_l[VL2]==True):
      return_pose[ex] = VL2
      ex = ex + 1
    end
    if(Cell_l[VR2]==True):
      return_pose[ex] = VR2
      ex = ex + 1
    end
  
    if(Cell_l[HOR_ML]==True or Cell_l[HOR_MR]==True ):
      if(Cell_l[HOR_MR]==True):
        MLMR = 50
      else:
        MLMR = 0
      end
      # ext 4 => 이음, ext 6 = > 분할
      while(l_var<l_counter):
        if(ext_flag_pend[4]==True and (cell_info_l!=cell_c and cell_info_l !=cell_d and cell_info_r!=cell_c and cell_info_r !=cell_d)):
          if(ext_flag_pend[6]==True):
            return_pose[ex] = HOR_2_CD_connect + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_23_CD_right + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          else:
            return_pose[ex] = HOR_1_CD + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          end
        else:
          if(ext_flag_pend[6]==True):
            return_pose[ex] = HOR_3_CD_left + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_3_CD_middle + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_23_CD_right + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          else:
            return_pose[ex] = HOR_3_CD_left + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_2_CD_midr + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          end
        end
        l_var = l_var + 1
      end
    elif(Cell_l[HOR]==True):
      while(l_var<l_counter):
        if(ext_flag_pend[6]==True):
          return_pose[ex] = HOR_2_L + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
          return_pose[ex] = HOR_2_R + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
        else:
          return_pose[ex] = HOR_1 + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
        end
        l_var = l_var + 1
      end
    end
    write_port_register(140,num_2f)
  
    if(Cell_l[VL1]==True):
      return_pose[ex] = VL1
      ex = ex + 1
    end
    if(Cell_l[VR1]==True):
      return_pose[ex] = VR1
      ex = ex + 1
    end
    return return_pose
  end
  
  def cell_num(Num):
    var_i = 0
    while(var_i<14):
      if(Num[var_i] == 0):
        return var_i
      else:
        var_i = var_i+1
      end
    end
    return var_i
  end
  
  def singularity_inner(target_pose):
    global angle_margin=4
    global inner_UR3e=0.18
    global outer_UR3e=0.45
    global cj= get_actual_joint_positions()
    global cp=get_actual_tool_flange_pose()
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1])
    if (distance_tool<inner_UR3e):
      global msg="inner singularity"
      return True
    end
    return False
  end
  #singularity check
  
  def singularity(target_pose,hard_mode=False):
    if(hard_mode):
      global angle_margin=15
      global inner_UR3e=0.215
      global outer_UR3e=0.5
    else:
      global angle_margin=8
      global inner_UR3e=0.18
      global outer_UR3e=0.56
    end
    global cj= get_actual_joint_positions()
    global cp=get_actual_tool_flange_pose()
    if (r2d(cj[4])>-angle_margin  and  r2d(cj[4]) <= angle_margin):
      global msg="wirst singularity"
      return True
    else:
      if (r2d(cj[4])>-angle_margin+180  and  r2d(cj[4])<angle_margin+180):
        global msg="wirst singularity"
        return True
      end
    end
  
    if (r2d(cj[2])>-angle_margin  and  r2d(cj[2]) <= angle_margin):
      global msg="wirst singularity2"
      return True
    end
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1])
    if (distance_tool<inner_UR3e):
      global msg="inner singularity"
      return True
    end
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1]+cp[2]*cp[2])
    if (distance_tool>outer_UR3e):
      global msg="outer singularity"
      return True
    end
    return False
  end
  #
  
  def contact_fun(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    if(isTouchWCR):
      get_contact_p = contact_fun_wcr(feature,direction,position_distance,fun_speed,fun_acc,back_trig,back_dis,sens)
    else:
      get_contact_p = contact_fun_sens(feature,direction,position_distance,fun_speed,fun_acc,back_trig,back_dis,sens)
    end
    return get_contact_p
  end
  
  def check_speed():
    global act_speed = get_actual_tcp_speed()
    var_i = 0
    while(var_i <5):
      if(act_speed[var_i] >= 2.5):
        write_port_register(142,113)
        halt
      end
      var_i = var_i + 1
    end
  end
  
  def home_ym(limit_p):
    get_po = pose_trans(get_actual_tcp_pose(),p[0,0,0,0,d2r(-10),0])
    global get_sing6 = singularity(get_po,hard_mode=True)
    if(get_sing6==False):
      current_tcp = get_tcp_offset()
      set_tcp(p[0,0,0,current_tcp[3],current_tcp[4],current_tcp[5]])
      get_po = pose_trans(get_actual_tcp_pose(),p[0,0,0,0,d2r(-10),0])
      ta_j = get_inverse_kin(get_po)
      home_movej2(ta_j,limit_p)
      set_tcp(current_tcp)
    end
  end
  
  def home_movej2(target_j,limit_p,speed_j=0):
    current_j = get_actual_joint_positions()
    global diff_po_x = [0,0,0,0,0,0]
    global diff_po_y = [0,0,0,0,0,0]
    global alimit_p2 = limit_p
    if(alimit_p2[0]>0.40):
      alimit_p2[0] = alimit_p2[0] + 0.003
      global spd_j = 65
    else:
      alimit_p2[0]=0.40
      global spd_j = 80
    end
    if(speed_j>0):
      global spd_j=speed_j
    end
  
    while(not(is_steady())):
      sync()
    end
    alimit_p2[1] = norm(alimit_p2[1]) + 0.003
    alimit_p2[2] = alimit_p2[2] + 0.003
  
    global dist_j = pose_dist(get_forward_kin(target_j),get_actual_tcp_pose())
    global time_j = (dist_j*1000) / spd_j
  
    if(dist_j*1000<100):
      time_j = time_j+1
    end
    global delta_t = time_j*1000/20
    global delta_a = 0
    global t_c = [r2d(current_j[0]),r2d(current_j[1]),r2d(current_j[2]),r2d(current_j[3]),r2d(current_j[4]),r2d(current_j[5])]
    global t_c_org = t_c
    global t_j = [(r2d(target_j[0])-t_c[0]),(r2d(target_j[1])-t_c[1]),(r2d(target_j[2])-t_c[2]),(r2d(target_j[3])-t_c[3]),(r2d(target_j[4])-t_c[4]),(r2d(target_j[5])-t_c[5])]
    arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
    global arrive_p = get_forward_kin(arrive_j)
    global l_j = [1,1,1,1,1,1]
    second_t = True
  
    while(delta_a<delta_t and l_j != [0,0,0,0,0,0] ):
      l_j = [1,1,1,1,1,1]
      var_i = 0
      # if(delta_a%15==0):
      #   global g_cp = get_actual_tcp_pose()
      #   if(alimit_p2[0]>g_cp[0]):
      #     alimit_p2[0]=g_cp[0] + 0.001
      #   end
      #   if(norm(alimit_p2[1])>norm(g_cp[1])):
      #     alimit_p2[1]=norm(g_cp[1]) + 0.001
      #   end
      # end
      if(delta_a==100 and second_t == True):
        current_j = get_actual_joint_positions()
        dist_j = pose_dist(get_forward_kin(target_j),get_actual_tcp_pose())
        time_j = (dist_j*1000) / spd_j
        delta_t = time_j*1000/20
        delta_a = 0
        t_c = [r2d(current_j[0]),r2d(current_j[1]),r2d(current_j[2]),r2d(current_j[3]),r2d(current_j[4]),r2d(current_j[5])]
        t_j = [(r2d(target_j[0])-t_c[0]),(r2d(target_j[1])-t_c[1]),(r2d(target_j[2])-t_c[2]),(r2d(target_j[3])-t_c[3]),(r2d(target_j[4])-t_c[4]),(r2d(target_j[5])-t_c[5])]
        second_t = False
        global g_cp = get_actual_tcp_pose()
        if(alimit_p2[0]>g_cp[0]):
          alimit_p2[0]=g_cp[0] + 0.003
        end
      end
      while(var_i<6):
        b_p = arrive_p
        t_c[var_i] = t_c[var_i] + (t_j[var_i] * 1/delta_t) * l_j[var_i]
        arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
        arrive_p = get_forward_kin(arrive_j)
        diff_po = pose_sub (arrive_p,b_p)
        diff_po_x[var_i] = diff_po[0]
        diff_po_y[var_i] = diff_po[1]
        if(alimit_p2[0]<arrive_p[0] or alimit_p2[1]<norm(arrive_p[1]) or alimit_p2[2]<arrive_p[2] or 0/1000>arrive_p[2] or (second_t == True and delta_a<100 and diff_po[0]>0.0005)):
          t_c[var_i] = t_c[var_i] - (t_j[var_i] * 1/delta_t) * l_j[var_i]
          l_j[var_i] = 0
        elif(delta_t>100 and arrive_p[0]<0.38 and norm(arrive_p[1])<0.3):
          t_c[var_i] = t_c[var_i] + (t_j[var_i] * 1/(delta_t*3)) * l_j[var_i]
        end
        if(t_j[var_i]<0 and t_c[var_i]<r2d(target_j[var_i])):
          t_c[var_i] = t_j[var_i]
        elif(t_j[var_i]>0 and t_c[var_i]>r2d(target_j[var_i])):
          t_c[var_i] = t_j[var_i]
        end
        var_i = var_i+1
      end
      arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
  
  
      if(l_j!=[0,0,0,0,0,0]):
        servoj(arrive_j,0,0,0.02,0.12,250)
      end
      delta_a = delta_a + 1
  
      #write_output_float_register(24,delta_a)
      #write_output_float_register(25,ceil(delta_t))
      sync()
    end
    stopj(2)
    if(l_j==[0,0,0,0,0,0]):
      return False
    else:
      return True
    end
  end
  
  
  def home_tilt_move():
    global g_cp = get_actual_tcp_pose()
    global g_tp = g_cp
    spd_j = 20
    g_tp[0] = g_tp[0] - 0.02
    if(g_tp[1]>0):
      g_tp[1] = g_tp[1] - 0.02
    else:
      g_tp[1] = g_tp[1] + 0.02
    end
    g_tp[2] = 0.1
    c_p = g_cp
    global dist_j = pose_dist(g_tp,g_cp)
    global time_j = (dist_j*1000) / spd_j
    global delta_t = time_j*1000/100
    global delta_a = 0
    global alpha_home = 0
  
    global get_angle_ry = welding_angle_cal_3f(g_tp[2],last_tilt_deg,last_z_bottom,1)
    T_angle = feature_offset(last_wv_wp1,p[0,0,0,d2r(last_tilt_deg[0]),d2r(last_tilt_deg[1] + get_angle_ry),d2r(last_tilt_deg[2])],last_wv_line)
    target_p = p[g_tp[0],g_tp[1],g_tp[2],T_angle[3],T_angle[4],T_angle[5]]
    movel(target_p,a=0.3,v=0.3)
    # while(delta_a<delta_t and c_p[2]>0.1):
    #   c_p = interpolate_pose(g_cp,g_tp,delta_a)
    #   global get_angle_ry = welding_angle_cal_3f(c_p[2],last_tilt_deg,last_z_bottom,1)
    #   T_angle = feature_offset(last_wv_wp1,p[0,0,0,d2r(last_tilt_deg[0]),d2r(last_tilt_deg[1] + get_angle_ry),d2r(last_tilt_deg[2])],last_wv_line)
    #   target_p = p[c_p[0],c_p[1],c_p[2],T_angle[3],T_angle[4],T_angle[5]]
    #   movel(target_p,a=0.3,v=0.3,t=0,r=0.01)
    #   delta_a = delta_a+1/delta_t
    # end
  end
  
  right_prep_p_j = [0.2742413878440857, -0.8092182318316858, -1.5809415022479456, -2.0764687697040003, 1.7196621894836426, 2.770606517791748]
  left_prep_p_j = [0.7465318441390991, -0.9293935934649866, -1.54653245607485, -2.120742146168844, 1.6612900495529175, 1.4639835357666016]
  
  right_pre_up = [-0.16877919832338506, -0.9831331411944788, -0.8493865172015589, -2.161825958882467, 1.3512022495269775, 1.6723911762237549]
  left_pre_up = [1.1051501035690308, -1.1542351881610315, -0.8232358137713831, -2.0545104185687464, 1.5833461284637451, 1.8991502523422241]
  
  def homeing(home_pos = get_inverse_kin(first_p_wp,qnear = home_pos_j),robot_dist=CELL_ROBOT_DIST,robot_width = CELL_WIDTH,robot_height=-50):
    current_jp = get_actual_joint_positions()
    global current_cp = get_actual_tcp_pose()
    global limit_p = current_cp
  
    global home_step = 0
  
    # X - FRONT, BACK
    if(current_cp[0]>0.05):
      #FRONT
      pos_dir_x=-1
    elif(current_cp[0]<-0.05):
      #BACK
      pos_dir_x=1
    else:
      pos_dir_x=0
    end
  
    if(current_cp[1]>0.05):
      #LEFT
      global pos_dir=-1
    elif(current_cp[1]<-0.05):
      #RIGHT
      global pos_dir=1
    else:
      global pos_dir=0
    end
  
    if ( pose_dist ( current_cp, Packing_pos_wp)<0.07):
      home_step = 1
      movej(home_pos,a=0.3,v=0.3)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
    if ( pose_dist ( current_cp, first_p_wp)<0.06):
      home_step = 2
      movej(home_pos,a=0.45,v=0.45)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
    if ( pose_dist ( current_cp, mounting_wp)<0.02):
      home_step = 3
      movej(pre_mounting_wp, a=0.45, v=0.45)
      movej(home_pos,a=0.45,v=0.45)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
  
    global dist_lastcp = point_dist(current_cp,last_pose)
    if ( current_cp[2] > 150/1000 and dist_lastcp<0.025 and last_tilt_deg != [0,0,0] and last_wv_wp1 != p[0,0,0,0,0,0] and last_wv_line != p[0,0,0,0,0,0] and last_z_bottom != 0):
      home_step=4
      home_tilt_move()
      if (pos_dir == 1 and current_cp[1]<-0.17):
          home_step=5
          movej(get_inverse_kin(right_prep_p_v,qnear=right_prep_p_j), a=1.3,v=1.3)
          movej(home_pos,a=1.3,v=1.3)
          return True
      elif (pos_dir == -1 and current_cp[1]>0.17):
          home_step=6
          movej(get_inverse_kin(left_prep_p_v,qnear=left_prep_p_j), a=1.3,v=1.3)
          movej(home_pos,a=1.3,v=1.3)
          return True
      end
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
    end
  
    if ( norm(current_cp[0]) > 300/1000):
      home_step = 15
      global m_dis = 20
      if ((norm(current_cp[0])>(280)/1000) and (norm(current_cp[1])>(280)/1000)):
        global m_dis = m_dis + 20
      end
      global get_sing = singularity(get_actual_tcp_pose(),hard_mode=True)
      if(pos_dir==-1 and get_sing==False):
        write_output_float_register(23,home_step)
        global home_step_check = True
        sing_dir = direction_singu(p[0,0,0,0,0,0],[-1,-0.5,0],m_dis,45,45,hard_mode=True)
        current_cp = get_actual_tcp_pose()
        current_jp = get_actual_joint_positions()
        limit_p[0] = current_cp[0]
        limit_p[1] = current_cp[1]
      elif(pos_dir==1 and get_sing==False):
        global home_step_check = True
        global sing_dir = direction_singu(p[0,0,0,0,0,0],[-1,0.5,0],m_dis,45,45,hard_mode=True)
        current_cp = get_actual_tcp_pose()
        current_jp = get_actual_joint_positions()
        limit_p[0] = current_cp[0]
        limit_p[1] = current_cp[1]
      end
    end
  
    if (pos_dir == 1):
      home_step=7
      if(current_cp[2]>0.364):
        movej(right_pre_up, a=1.3,v=1.3)
        current_cp = get_actual_tcp_pose()
      end
      if (current_cp[1]<-0.17):
        home_step=8
        movej(get_inverse_kin(right_prep_p_v,qnear=right_prep_p_j), a=1.3,v=1.3)
        movej(home_pos,a=1.3,v=1.3)
        return True
      end
    elif (pos_dir == -1):
      home_step=9
      if(current_cp[2]>0.311):
        movej(left_pre_up, a=1.3,v=1.3)
        current_cp = get_actual_tcp_pose()
      end
      if (current_cp[1]>0.17):
        home_step=10
        movej(get_inverse_kin(left_prep_p_v,qnear=left_prep_p_j), a=1.3,v=1.3)
        movej(home_pos,a=1.3,v=1.3)
        return True
      end
    end
  
    home_step=11
    movej(home_pos, a=1.3,v=1.3)
    home_step=0
  
    last_pose = p[0,0,0,0,0,0]
    last_wv_wp1 = p[0,0,0,0,0,0]
    last_wv_line = p[0,0,0,0,0,0]
    last_tilt_deg = [0,0,0]
  end
  
  def contact_fun_sens(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global force_T = p[0,0,0,0,0,0]
    global force_T_all = force()
    global contact_back_p = p[0,0,0,0,0,0]
    global touch_begin = get_actual_tcp_pose()
    global contact_trig = False
  
    thread fun_thread_contact():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    thread tool_contact_thread():
      while(True):
        global force_torque = get_tcp_force()
        force_B = p[ force_torque[0], force_torque[1], force_torque[2], 0, 0, 0 ]
        torque_B = p[ force_torque[3], force_torque[4], force_torque[5], 0, 0, 0 ]
        tcp = get_actual_tcp_pose()
        rotation_BT = p[ 0, 0, 0, tcp[3], tcp[4], tcp[5] ]
        if(norm(force_T[2])>4):
          global contact_back_p = get_actual_tcp_pose()
          contact_trig = True
        else:
          contact_trig = False
        end
        force_T = pose_trans( pose_inv(rotation_BT), force_B )
        torque_T = pose_trans( pose_inv(rotation_BT), torque_B )
        force_torque_T = p[ force_T[0], force_T[1], force_T[2], torque_T[0], torque_T[1], torque_T[2] ]
        sync()
      end
    end
    while(is_steady()==False):
      sync()
    end
    zero_ftsensor()
    move_thread_han5 = run fun_thread_contact()
    contact_thread_han5 = run tool_contact_thread()
  
    while (True):
      if (norm(force_T[2]) > sens and contact_back_p != p[0,0,0,0,0,0]):
        kill move_thread_han5
        kill contact_thread_han5
        global get_contact_p = get_actual_tcp_pose()
        stopl(3.0)
        if (back_trig==True):
          contact_back_p = feature_offset(contact_back_p,p[g_d[0]*back_dis/1000,g_d[1]*back_dis/1000,g_d[2]*back_dis/1000,0,0,0],feature)
          movel(contact_back_p, a=3, v=0.1)
        end
        break
      end
      # if (point_dist(touch_begin,contact_back_p)>0.15 and contact_back_p != p[0,0,0,0,0,0]):
      #   write_port_register(142,121)
      #   halt
      # end
      sync()
    end
    return contact_back_p
  end
  
  def contact_fun_wcr(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global contact_back_p = p[0,0,0,0,0,0]
    global contact_trig = False
    global touch_begin = get_actual_tcp_pose()
  
    thread fun_thread_contactw():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    write_welder(4,True)
    write_port_register(211,0)
    sleep(0.05)
    get_stick = read_welder(4)
    sleep(0.05)
    move_thread_hanw = run fun_thread_contactw()
    while (True):
      global contact_back_p = get_actual_tcp_pose()
      global get_stick = read_welder(4)
      global get_stick_out = read_welder_control(4)
      if(get_stick_out==False):
        write_welder(4,True)
      end
      if(isHicomm):
        touch_onoff=read_welder(4)
      else:
        touch_onoff = get_standard_digital_in(1)
      end
      if (touch_onoff):
        kill move_thread_hanw
        stopj(8.0)
        if (back_trig==True):
          back_p = feature_offset(get_actual_tcp_pose(),p[g_d[0]*back_dis/1000,g_d[1]*back_dis/1000,g_d[2]*back_dis/1000,0,0,0],feature)
          movel(back_p, a=0.05, v=0.02)
        end
        break
      end
      # if (point_dist(touch_begin,contact_back_p)>0.15 and contact_back_p != p[0,0,0,0,0,0]):
      #   write_port_register(142,121)
      #   halt
      # end
      sync()
    end
    return contact_back_p
  end
  
  def get_lr(get_pose,get_width,get_cell,get_distance=600,left_par2=True,par_2f=False,touch_dis=30,margin_z=30,side_touch=0,callar=0,par_cell=0,cent_line=p[0,0,0,0,0,0],angle_c=False):
    #A : 1, B : 2, C : 3, c : 4, D : 5, d :6, E : 7, e : 8
    #marzin_z : 터치높이
    margin_dis_3f = 30
    margin_dis_y = 30
    margin_dis_z = 55
    get_distance = get_distance
  
  
    if((par_cell==4 or par_cell==6) and callar > 1):
      margin_dis_3f = -50
    else:
      margin_dis_3f = 20
    end
  
    if((par_cell==1 or par_cell==3 or par_cell==4) and par_2f==False):
      touch_dis = 0
    elif((par_cell==2 or par_cell==5 or par_cell==6 or par_cell==7 or par_cell==8) and par_2f==False):
      margin_z = 0
    elif(par_cell==7 or par_cell==8 and par_2f):
      #2F e,E는 터치 높이 25 고정
      margin_z = 25
    end
  
    if(par_cell==3 or par_cell==5 or par_cell==7 or par_cell==8):
      margin_cal = 40
    else:
      margin_cal = 0
    end
    if((par_cell==5 or par_cell==6) and callar > 1):
      get_cell[1] = 0
      get_cell[2] = 0
    end
  
    if(par_2f==False):
      #3F
      if(left_par2):
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,(get_width/2-margin_dis_3f-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      else:
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,-(get_width/2-margin_dis_3f-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      end
      if(angle_c==False):
        return_v = feature_offset(return_v,p[0,0,0,0,d2r((((return_v[2]-30/1000)*1000) / 600) * 5),0],return_v)
      end
      return return_v
    else:
      #2F
      if(left_par2):## margin_dis_z -> get_width[1] up, down margin_dis_z -> get_width[2]
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,(-get_cell[1]+(get_width/2)-touch_dis-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,0,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,(-get_cell[1]+(get_width/2)-touch_dis-callar)/1000,0,0,0,0],cent_line)
        end
      else:
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,-(-get_cell[2]+(get_width/2)-touch_dis-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,0,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,-(-get_cell[2]+(get_width/2)-touch_dis-callar)/1000,0,0,0,0],cent_line)
        end
      end
      if(angle_c==False):
        r_v = pose_trans(return_v,p[0,0,0,0,0,d2r(-90)])
        return_v = feature_offset(return_v,p[0,0,0,d2r((return_v[1]*1000 / 500)*0.25) * 25,0,0],r_v)
      end
      return return_v
    end
  end
  
  def side_apply(apply_p,cent_line,side_touch):
    offset_v = p[0,side_touch/1000,0,0,0,0]
    if(cent_line==p[0,0,0,0,0,0]):
      return_v = pose_add(apply_p,offset_v)
    else:
      return_v = feature_offset(apply_p,offset_v,cent_line)
    end
    return return_v
  end
  
  def touch_angle_2f(left_dir = True,angle_get_up = [0,0,0],angle_get_down = [0,0,0]):
    if(left_dir):
      if(angle_get_up == [0,0,0]):
        touch_angle_rpy_2f_up = [-180,-55,30]
        touch_angle_rpy_2f_down = [-180,-50,30]
      else:
        touch_angle_rpy_2f_up = angle_get_up
        touch_angle_rpy_2f_down = angle_get_down
      end
      touch_angle_rot_2f_up = rpy2rotvec([d2r(touch_angle_rpy_2f_up[0]),d2r(touch_angle_rpy_2f_up[1]),d2r(touch_angle_rpy_2f_up[2])])
      touch_angle_rot_2f_down = rpy2rotvec([d2r(touch_angle_rpy_2f_down[0]),d2r(touch_angle_rpy_2f_down[1]),d2r(touch_angle_rpy_2f_down[2])])
    else:
      if(angle_get_down == [0,0,0]):
        touch_angle_rpy_2f_up = [-180,-55,-30]
        touch_angle_rpy_2f_down = [-180,-50,-30]
      else:
        touch_angle_rpy_2f_up = angle_get_up
        touch_angle_rpy_2f_down = angle_get_down
      end
      touch_angle_rot_2f_up = rpy2rotvec([d2r(touch_angle_rpy_2f_up[0]),d2r(touch_angle_rpy_2f_up[1]),d2r(touch_angle_rpy_2f_up[2])])
      touch_angle_rot_2f_down = rpy2rotvec([d2r(touch_angle_rpy_2f_down[0]),d2r(touch_angle_rpy_2f_down[1]),d2r(touch_angle_rpy_2f_down[2])])
    end
  
    touch_angle_rot = [touch_angle_rot_2f_up[0],touch_angle_rot_2f_up[1],touch_angle_rot_2f_up[2],touch_angle_rot_2f_down[0],touch_angle_rot_2f_down[1],touch_angle_rot_2f_down[2]]
    return touch_angle_rot
  end
  
  #degree ,modify
  def touch_fun_2f(start_pose,start_pose_2,left_dir = True,touch_sens=2,bottom_pose=p[0,0,0,0,0,0]):
    x_dis = 10
    next_distance = 20
  
    get_touch_angle = touch_angle_2f(left_dir)
    # start_pose_2 = p[start_pose[0],start_pose[1],start_pose[2],start_pose[3],start_pose[4],start_pose[5]]
  
    if(left_dir):
      l_dir = -1
    else:
      l_dir = +1
    end
    while(not(is_steady())):
      sync()
    end
    write_port_register(211,0)
    get_stick = read_welder(4)
    if(get_stick==False):
      write_welder(4,True)
    end
    sleep(0.1)
    global get_y_1=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-0.5,0,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[0,0,-1],x_dis,180,200)
    global get_y_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-1,0,0],next_distance,180,200)
  
    g_cp = get_actual_tcp_pose()
    g_cp = p[g_cp[0],g_cp[1],g_cp[2],start_pose_2[3],start_pose_2[4],start_pose_2[5]]
    movel(g_cp,a= 0.8,v=0.4)
  
    global get_z_2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0,0.5],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[-1,0,0],x_dis,180,200)
    global get_z_1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0,1],30,180,200)
    write_welder(4,False)
  
    result_p = touch_4p_get_middle(get_z_1,get_z_2,get_y_1,get_y_2,left_dir,bottom_pose,True)
  
    return result_p
  end
  
  def touch_fun2(start_pose,left_dir = True,touch_sens=2,par_CD=0,bottom_pose=p[0,0,0,0,0,0]):
    for_cd = 1
    if(par_CD==1):
      x_dis = 2.2
      next_distance = 5.5
      for_cd = 4
    else:
      x_dis = 20
      next_distance = 20
    end
    if(left_dir):
      l_dir = -1
    else:
      l_dir = +1
    end
    while(not(is_steady())):
      sync()
    end
    write_port_register(211,0)
    get_stick = read_welder(4)
    if(get_stick==False):
      write_welder(4,True)
    end
    sleep(0.1)
    get_y_1=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-0.5*for_cd,0,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[0,1 * l_dir*for_cd,0],x_dis,180,200)
    get_y_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-1,0,0],next_distance,180,200)
  
    get_z_2=contact_fun(p[0,0,0,0,0,0],[0,-1 * l_dir,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0.5 * l_dir*for_cd,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[-1,0,0],x_dis,180,200)
    get_z_1=contact_fun(p[0,0,0,0,0,0],[0,-1 * l_dir,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,1 * l_dir,0],x_dis,180,200)
    write_welder(4,False)
  
    if(left_dir):
      result_p = touch_4p_get_middle(get_y_2,get_y_1,get_z_1,get_z_2,left_dir,bottom_pose)
    else:
      result_p = touch_4p_get_middle(get_z_1,get_z_2,get_y_2,get_y_1,left_dir,bottom_pose)
    end
  
    return result_p
  end
  
  def touch_4point(get_wpx1,get_wpx2,get_wpy1):
    get_wpx2[2] = get_wpx1[2]
    get_wpy1[2] = get_wpx1[2]
    global feature_right2left = get_feature_Line(get_wpx1,get_wpx2)
  
    a_p1 = get_wpx1
    a_p2 = feature_offset(get_wpx1,p[0,0.02,0,0,0,0],feature_right2left)
    a_p3 = pose_add(get_wpx1,p[0,0,0.02,0,0,0])
    global plane_p = get_feature_plane_xz(a_p1,a_p2,a_p3)
  
    global get_r1 = get_feature_pose(get_wpy1,plane_p)
    global cent_p = feature_offset(plane_p,p[get_r1[0],0,0,0,0,0] ,plane_p)
  
    return cent_p
  end
  
  def touch_xyz_get_middle(get_wpx1,get_wpx2,get_wpy1,get_wpz1):
    get_wpx1[2] = get_wpz1[2]
    get_wpx2[2] = get_wpz1[2]
    get_wpy1[2] = get_wpz1[2]
  
    global feature_right2left = get_feature_Line(get_wpx1,get_wpx2)
  
    a_p1 = get_wpx1
    a_p2 = feature_offset(get_wpx1,p[0,0.02,0,0,0,0],feature_right2left)
    a_p3 = pose_add(get_wpx1,p[0,0,0.02,0,0,0])
    global plane_p = get_feature_plane_xz(a_p1,a_p2,a_p3)
  
    get_r1 = get_feature_pose(get_wpy1,plane_p)
    cent_p = feature_offset(plane_p,p[get_r1[0],0,0,0,0,0] ,plane_p)
  
    get_r_o = feature_offset(cent_p,p[-0.02,0,0,0,0,0],plane_p)
    get_l_o = feature_offset(cent_p,p[0,0.02,0,0,0,0],plane_p)
  
    middle_lr = interpolate_pose(get_r_o,get_l_o,0.2)
    cent_p[2] = middle_lr[2]
  
    plane_test = get_feature_plane_yz(middle_lr,get_l_o,cent_p)
    # global yy_dir = get_feature_Line(middle_lr,get_l_o)
    global zz_dir = get_feature_Line(cent_p,middle_lr)
  
    g_x_dir = pose_add(middle_lr,p[0,0,0.02,0,0,0])
    # g_y_dir = feature_offset(middle_lr,p[0,0.02,0,0,0,0],plane_test)
    # g_y_dir = feature_offset(middle_lr,p[0,-0.02,0,0,0,0],yy_dir)
  
    # g_z_dir = feature_offset(middle_lr,p[0,0,0.02,0,0,0],plane_test)
    g_z_dir = feature_offset(middle_lr,p[0,-0.02,0,0,0,0],zz_dir)
  
    g_z_dir = p[g_z_dir[0],g_z_dir[1],g_z_dir[2],get_wpx1[3],get_wpx1[4],get_wpx1[5]]
  
    # global final_feature = get_feature_plane_yz(middle_lr,g_y_dir,g_z_dir)
    global final_feature = get_feature_plane_xz(middle_lr,g_x_dir,g_z_dir)
  
    get_result = p[cent_p[0],cent_p[1],cent_p[2],final_feature[3],final_feature[4],final_feature[5]]
  
    # wp_test = p[cent_p[0],cent_p[1],cent_p[2],get_wpx1[3],get_wpx1[4],get_wpx1[5]]
    # get_result = feature_offset(get_result,p[0,0,0,d2r(-15),d2r(-45),0],get_result)
    # movel(get_result)
    return get_result
  end
  
  def touch_4p_get_middle(get_wpy1,get_wpy2,get_wpz1,get_wpz2,left_dir,bottom_pose=p[0,0,0,0,0,0],f2_par=False):
    feature_right = get_feature_Line(get_wpy1,get_wpy2)
    feature_left = get_feature_Line(get_wpz1,get_wpz2)
  
    f_gap1 = feature_offset(get_wpz1,p[0,1/1000,0,0,0,0],feature_left)
    f_gap2 = feature_offset(get_wpz1,p[0,2/1000,0,0,0,0],feature_left)
    gap_r1 = get_feature_pose(f_gap1, feature_right)
    gap_r2 = get_feature_pose(f_gap2, feature_right)
    test13 = gap_r1[0]/(gap_r1[0] - gap_r2[0])
  
    cent_p = feature_offset(get_wpz1,p[0,(1+test13)/1000,0,0,0,0],feature_left)
    cent_p = p[cent_p[0],cent_p[1],cent_p[2],get_wpy1[3],get_wpy1[4],get_wpy1[5]]
  
    get_r_o = feature_offset(cent_p,p[0,-0.02,0,0,0,0],feature_right)
    get_l_o = feature_offset(cent_p,p[0,-0.02,0,0,0,0],feature_left)
  
    middle_lr = interpolate_pose(get_r_o,get_l_o,0.5)
  
    yy_dir = get_feature_Line(middle_lr,get_l_o)
    zz_dir = get_feature_Line(cent_p,middle_lr)
  
    g_y_dir = feature_offset(middle_lr,p[0,-point_dist(middle_lr,cent_p),0,0,0,0],yy_dir)
    g_z_dir = feature_offset(middle_lr,p[0,-point_dist(middle_lr,cent_p),0,0,0,0],zz_dir)
  
    final_feature = get_feature_plane_yz(middle_lr,g_y_dir,g_z_dir)
    if(False):
      cent_p[2] = bottom_pose[2]
    end
    get_result = p[cent_p[0],cent_p[1],cent_p[2],final_feature[3],final_feature[4],final_feature[5]]
  
    #movel(get_result)
  
    return get_result
  end
  
  def get_feature_pose(fun_pose,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    return fun_p_feature
  end
  
  
  def get_base_pose(fun_p_feature,fun_plane=p[0,0,0,0,0,0]):
    fun_pose = pose_trans ( fun_plane, fun_p_feature)
    return fun_pose
  end
  
  def set_pos_xyz(get_pos_h=p[0,0,0,0,0,0],set_pos_h=[0,0,0]):
    if(set_pos_h[0] != 0):
      get_pos_h[0] = set_pos_h[0]
    end
    if(set_pos_h[1] != 0):
      get_pos_h[1] = set_pos_h[1]
    end
    if(set_pos_h[2] != 0):
      get_pos_h[2] = set_pos_h[2]
    end
    return get_pos_h
  end
  
  def set_rot_rpy_deg(get_pos_h=p[0,0,0,0,0,0],set_rot_h=[0,0,0]):
    cal_p_rpy = rotvec2rpy([get_pos_h[3],get_pos_h[4],get_pos_h[5]])
    if(set_rot_h[0] != 0):
      cal_p_rpy[0] = d2r(set_rot_h[0])
    end
    if(set_rot_h[1] != 0):
      cal_p_rpy[1] = d2r(set_rot_h[1])
    end
    if(set_rot_h[2] != 0):
      cal_p_rpy[2] = d2r(set_rot_h[2])
    end
    cal_p = rpy2rotvec(cal_p_rpy)
    get_pos_h[3] = cal_p[0]
    get_pos_h[4] = cal_p[1]
    get_pos_h[5] = cal_p[2]
    return get_pos_h
  end
  
  
  thread CalThread():
    while (True):
      FB_CURRENT_UR = get_standard_analog_in(1)*100
      #FB_CURRENT_UR = get_standard_analog_in(1)*125
      FB_VOLTAGE_UR = get_standard_analog_in(0)*8
  
      FB_CURRENT_UR_org = FB_CURRENT_UR
      FB_VOLTAGE_UR_org = FB_VOLTAGE_UR
  
      write_output_float_register(2,FB_CURRENT_UR)
      write_output_float_register(3,FB_VOLTAGE_UR)
      write_port_register(131,FB_CURRENT_UR)
      write_port_register(132,FB_VOLTAGE_UR*10)
  
      if(FB_CURRENT_UR>=c_maxcut and FB_CURRENT_UR>50):
        FB_CURRENT_UR = c_maxcut
      elif(FB_CURRENT_UR<=c_mincut and FB_CURRENT_UR>50):
        FB_CURRENT_UR = c_mincut
      end
  
      if(FB_CURRENT_UR>50):
        if(current_on==False):
          current_on=True
        end
        if(sin_dir==-1):
          if(peak_value==100):
            write_output_float_register(23,5)
            one_cycle_p_count = one_cycle_p_count + 1
            one_cycle_p_accum = one_cycle_p_accum + FB_CURRENT_UR
            one_cycle_p_accum_org = one_cycle_p_accum_org + FB_CURRENT_UR_org
          end
        else:
          if(peak_value==100):
            write_output_float_register(23,10)
            one_cycle_m_count = one_cycle_m_count + 1
            one_cycle_m_accum = one_cycle_m_accum + FB_CURRENT_UR
            one_cycle_m_accum_org = one_cycle_m_accum_org + FB_CURRENT_UR_org
          end
        end
      end
  
      GCP = get_feature_pose(get_actual_tcp_pose(),wv_Line_Feature2)
      write_output_float_register(14,GCP[0]*1000)
      write_output_float_register(15,GCP[1]*1000)
      write_output_float_register(16,GCP[2]*1000)
  
      GJP = get_actual_joint_positions()
  
      # write_output_float_register(20,r2d(GJP[0])*10)
      # write_output_float_register(21,r2d(GJP[1])*10)
      # write_output_float_register(22,r2d(GJP[2])*10)
      # write_output_float_register(23,r2d(GJP[3])*10)
      # write_output_float_register(24,r2d(GJP[4])*10)
      # write_output_float_register(25,r2d(GJP[5])*10)
  
  
      # if(get_wcr):
      #   write_output_float_register(20,1)
      # else:
      #   write_output_float_register(20,0)
      # end
  
      # write_output_float_register(21,read_port_register(201))
      sleep(0.004)
    end
  end
  
  thread diff_Thread():
    while (True):
      if(background_cal==1):
        background_cal = 0
        if(th_arc_sen[0]==1):
          if(counter_average_num == squash_cycle * counter_average*2 and squash_cycle!=0):
            counter_average_num = 0
            if(th_ext_fun[2]==1):
              #squash
              squash_cycle = 0
              w_voltage = th_ext_fun[0] #org vol
              w_current = th_ext_fun[1] #org cur
              set_current_voltage(w_current,w_voltage)
              th_wv_weldpar[4] = wving_amplitude_bak
              th_wv_weldpar[1] = cir_speed_org_bak
              if(th_par_2f):
                 global wv_system_speed = calculate_2f(th_wv_weldpar[4],th_wv_wp1,th_wv_wp2,th_wv_weldpar[1],th_wv_weldpar[3],th_wving_delay,th_wving_crater)
              else:
                global wv_system_speed = calculate_3f(th_wv_weldpar[4],th_wv_wp1,th_wv_wp2,th_wv_weldpar[1],th_wv_weldpar[3],th_wving_delay)
                x_radius = x_radius / 1000
              end
              global y_radius = y_radius / 1000
              global y_radius_bak = y_radius
            end
          end
          if(counter_average_num == (waste_cycle + squash_cycle)*counter_average*2 and waste_cycle != 0):
            write_output_float_register(19,100)
            counter_average_num = counter_average_num - waste_cycle
            waste_cycle = 0
            squash_cycle = 0
            one_cycle_p_count = 0
            one_cycle_m_count = 0
            one_cycle_p_accum = 0
            one_cycle_m_accum = 0
            one_cycle_p_accum_org = 0
            one_cycle_m_accum_org = 0
            counter_average_num = 0
          end
          if((counter_average_num >= (counter_average*2) + ((waste_cycle+squash_cycle) * counter_average*2))):
            cycle1_plus = one_cycle_p_accum / one_cycle_p_count
            cycle1_minus = one_cycle_m_accum / one_cycle_m_count
            cycle1_middle = (cycle1_plus+cycle1_minus)/2
            cycle1_plus_org = one_cycle_p_accum_org / one_cycle_p_count
            cycle1_minus_org = one_cycle_m_accum_org / one_cycle_m_count
            cycle1_middle_org = (cycle1_plus_org+cycle1_minus_org)/2
            write_output_float_register(9,cycle1_middle)
            write_output_float_register(6,cycle1_plus)
            write_output_float_register(7,cycle1_minus)
            # write_output_float_register(23,cycle1_plus_org)
            # write_output_float_register(24,cycle1_minus_org)
            # write_output_float_register(25,cycle1_middle_org)
            cycle_number = cycle_number + 1
            if(cycle_done == False):
              if(th_arc_sen[5] != 0):
                Standard_Arc_Current = th_arc_sen[5]
              else:
                if(th_par_2f):
                  Standard_Arc_Current = current_to_welding_m+10
                else:
                  Standard_Arc_Current = current_to_welding_m+15
                end
  
              end
              write_output_float_register(8,Standard_Arc_Current)
            end
            if(cycle_number==4):
              cycle_done = True
            end
            one_cycle_p_count = 0
            one_cycle_m_count = 0
            one_cycle_p_accum = 0
            one_cycle_m_accum = 0
            one_cycle_p_accum_org = 0
            one_cycle_m_accum_org = 0
  
            #---------------------------------------X offset --------------------------------------------
            if((norm(cycle1_plus - cycle1_minus) > 0.2) and cycle1_plus > (current_to_welding_m - 40) and cycle1_minus > (current_to_welding_m - 40)):
              arc_sensing_diff = cycle1_plus - cycle1_minus
              if(norm(arc_sensing_diff)>12):
                p_gain_u = th_arc_sen[1] / 100 *2 #0.28
                i_gain_u = th_arc_sen[2] / 1000 *2#0.004
              elif(norm(arc_sensing_diff)>7):
                p_gain_u = th_arc_sen[1] / 100 * 1.5#0.14
                i_gain_u = th_arc_sen[2] / 1000 * 1.5#0.004
              else:
                p_gain_u = th_arc_sen[1] / 100 #0.14
                i_gain_u = th_arc_sen[2] / 1000 #0.004
              end
  
              Ts = 1/system_bus_ms
  
              if(arc_sensing_diff>10):
                arc_sensing_diff = 10
              elif(arc_sensing_diff<-10):
                arc_sensing_diff = -10
              end
  
              Up = arc_sensing_diff * p_gain_u
              Ui = Ui + arc_sensing_diff * i_gain_u * Ts
              Pi_sum = Up + Ui
  
              if(Pi_sum>7):
                Pi_sum = 0
              elif(Pi_sum< -7):
                Pi_sum = 0
              end
  
              arc_x_off = Pi_sum * arc_sens_onoff
              if(th_par_2f==False):
                th_wv_wp2 = feature_offset(th_wv_wp2,p[0,-arc_x_off/1000,0,0,0,0],wv_Line_Feature2)
              end
              write_output_float_register(10,Up)
              write_output_float_register(11,Ui)
              write_output_float_register(4,-arc_x_off)
            end
  
            #write_output_float_register(4,Standard_Arc_Current)
  
            #---------------------------------------Z offset --------------------------------------------
            #record 36-46
            arc_sensing_diff_z = Standard_Arc_Current-cycle1_middle
            if(norm(arc_sensing_diff_z)>0.2):
              if(norm(arc_sensing_diff_z)>10):
                p_gain_u_z = th_arc_sen[3] / 1000 * 3.5#0.05
                i_gain_u_z = th_arc_sen[4] / 1000 * 3 #0.018
              elif(norm(arc_sensing_diff_z)>5):
                p_gain_u_z = th_arc_sen[3] / 1000 * 1.8 #0.025
                i_gain_u_z = th_arc_sen[4] / 1000 * 1.5 #0.008
              else:
                p_gain_u_z = th_arc_sen[3] / 1000 #0.015
                i_gain_u_z = th_arc_sen[4] / 1000 #0.004
              end
  
              Ts = 1/system_bus_ms
  
              if(arc_sensing_diff_z>10):
                arc_sensing_diff_z = 10
              elif(arc_sensing_diff_z<-10):
                arc_sensing_diff_z = -10
              end
  
              Up_z = arc_sensing_diff_z * p_gain_u_z
              Ui_z = Ui_z + arc_sensing_diff_z * i_gain_u_z * Ts
              #
  
              Pi_sum_z = Up_z + Ui_z
  
              if(Pi_sum_z > 5):
                Pi_sum_z = 5
              elif(Pi_sum_z< -5):
                Pi_sum_z = -5
              end
  
              global arc_z_off = Pi_sum_z *arc_sens_onoff
  
              if(th_par_2f==False):
                th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,arc_z_off/1000,0,0,0],wv_Line_Feature2)
              end
              write_output_float_register(12,Up_z)
              write_output_float_register(13,Ui_z)
              write_output_float_register(5,arc_z_off)
              # write_output_float_register(42,100)
            end
            arc_x_off = 0
            arc_z_off = 0
            counter_average_num = 0
          end
          counter_average_num = counter_average_num + 1
          sync()
        end
        if(th_wv_gap[0]==1):
          T1 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          global get_angle_rx = welding_angle_cal_2f(T1[1],th_tilt_deg,vir_v,cal_off_ang_rx)
          global get_angle_ry = welding_angle_cal_3f(T1[2],th_tilt_deg,z_bottom,cal_off_ang_ry)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T1 = p[T1[0],T1[1],T1[2],T_angle[3],T_angle[4],T_angle[5]]
          ratio_t = ratio_t + 1/get_total
          write_output_float_register(19,ratio_t)
  
          T2 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T2 = p[T2[0],T2[1],T2[2],T_angle[3],T_angle[4],T_angle[5]]
  
          T_P = interpolate_pose(T1,T2,0.5)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T_P = p[T_P[0],T_P[1],T_P[2],T_angle[3],T_angle[4],T_angle[5]]
          global cur_dis = move_dis_total-get_line_dist(T1,th_wv_wp2)*1000
          global amplitude_gap = th_wv_weldpar[4] + (th_wv_gap[1]-th_wv_weldpar[4]) * (cur_dis/move_dis_total)
          global speed_gap = th_wv_weldpar[1] + (th_wv_gap[2]-th_wv_weldpar[1]) * (cur_dis/move_dis_total)
          if(th_par_2f):
            global wv_system_speed = calculate_2f(amplitude_gap,th_wv_wp1,th_wv_wp2,speed_gap,th_wv_weldpar[3],th_wving_delay,th_wving_crater)
          else:
            global wv_system_speed = calculate_3f(amplitude_gap,th_wv_wp1,th_wv_wp2,speed_gap,th_wv_weldpar[3],th_wving_delay)
          end
          y_radius = y_radius/1000
        else:
          T1 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          global get_angle_rx = welding_angle_cal_2f(T1[1],th_tilt_deg,vir_v,cal_off_ang_rx)
          global get_angle_ry = welding_angle_cal_3f(T1[2],th_tilt_deg,z_bottom,cal_off_ang_ry)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T1 = p[T1[0],T1[1],T1[2],T_angle[3],T_angle[4],T_angle[5]]
          ratio_t = ratio_t + 1/get_total
          write_output_float_register(19,ratio_t)
  
          T2 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T2 = p[T2[0],T2[1],T2[2],T_angle[3],T_angle[4],T_angle[5]]
  
          T_P = interpolate_pose(T1,T2,0.5)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T_P = p[T_P[0],T_P[1],T_P[2],T_angle[3],T_angle[4],T_angle[5]]
          global cur_dis = move_dis_total-get_line_dist(T1,th_wv_wp2)*1000
        end
  
        sin_dir = sin_dir * -1
        if(th_wv_weldpar[5]==1):
          # 삼각
          Tp1 = T1
          Tp2 = feature_offset(T_P,p[0,th_dir*y_radius*sin_dir,0,0,0,0],wv_Line_Feature2)
          Tp3 = T2
          if(ratio_t + 1/get_total >= 1):
            background_pose = [Tp3,Tp3,Tp3,dumy_p]
          else:
            background_pose = [Tp1,Tp2,Tp3,dumy_p]
          end
        elif(th_wv_weldpar[5]==2):
          # 사선
          #y_radius = y_radius_bak/2
          global Tp1 = feature_offset(T1,p[0,th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          # Tp1 = feature_offset(T1,p[0,y_radius,0,0,0,0],wv_Line_Feature2)
          global push_angle_wv = th_wving_crater[6]
          global push_dis_wv = norm(y_radius)/tan(d2r(push_angle_wv))
  
          if(th_wv_weldpar[6] == 1):
            Tp1 = feature_offset(T1,p[push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
            # Tp1 = feature_offset(Tp1,p[push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
          else:
            Tp1 = feature_offset(T1,p[-push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
            # Tp1 = feature_offset(Tp1,p[-push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
          end
  
          if(ratio_t > 2/get_total):
            global Tp2 = interpolate_pose(Tp1,Tp3,0.5)
          else:
            global Tp2 = interpolate_pose(Tp1,get_actual_tcp_pose(),0.5)
          end
  
          global Tp3 = feature_offset(T2,p[0,-th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          # Tp3 = feature_offset(T2,p[0,-y_radius,0,0,0,0],wv_Line_Feature2)
  
          global Tp4 = interpolate_pose(Tp1,Tp3,0.5)
  
          gcp = get_actual_tcp_pose()
  
          if(ratio_t + 1/get_total >= 1):
            background_pose = [Tp2,Tp1,Tp4,Tp3]
          else:
            background_pose = [Tp2,Tp1,Tp4,Tp3]
          end
        end
      end
      #168:arc on/off,  169:stick +- 1 mm 170 - 2 next
      get_stick_2 = read_port_register(169)
      if(welding_off_t == 1 and weld_onoff == True):
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
      elif(welding_off_t == 2 and weld_onoff == False and program_weld_on == True and next_path_c == False):
        write_welder(0,True)
      end
      if(get_stick_2==1):
        th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,2/1000,0,0,0],wv_Line_Feature2)
        write_port_register(169,0)
      elif(get_stick_2==2):
        th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,-2/1000,0,0,0],wv_Line_Feature2)
        write_port_register(169,0)
      end
      if(read_port_register(167)>=1):
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
        next_path_c = True
        ratio_t = 1.5
        global current_list=999
      end
      background_ready=1
      sync()
    end
  end
  
  def welding_angle_cal_2f_old(c_pos,tilt_deg,vir_v,cal_off_ang_rx):
    if(cal_off_ang_rx==1):
      global wdangle = (((c_pos*1000 / 500*0.65)+0.35*vir_v) * tilt_deg[0])-tilt_deg[0]
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def welding_angle_cal_2f(c_pos,tilt_deg,vir_v,cal_off_ang_rx):
    if(cal_off_ang_rx==1):
      global wdangle = ((c_pos*1000 / 500) * tilt_deg[0])-tilt_deg[0]
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def welding_angle_cal_3f(c_pos,tilt_deg,z_bottom,cal_off_ang_ry):
    if(cal_off_ang_ry==1):
      global wdangle = (((c_pos-z_bottom)*1000) / 600) * 47 # start -27
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def inv_inching(time = 0.3):
    write_welder(2,True)
    sleep(time)
    write_welder(2,False)
  end
  
  def read_welder(status):
    if(isHicomm):
      return read_welder_hicomm(status)
    else:
      return read_welder_analog(status)
    end
  end
  
  def read_welder_hicomm(status):
    #status 4 - stick, 5 - WCR
    status_addr = [1,2,4,8,16,32,64,128]
    global r_data = read_port_register(211)
    global b_data = integer_to_binary_list(r_data)
    if(status_addr[status]<=r_data):
      return b_data[status]
    else:
      return False
    end
  end
  #0 - wcr, 1 - stick
  def read_welder_analog(status):
    #status 4 - stick, 5 - WCR
    # stick 1, WCR - 0번 digital INPUT
    status_addr = [6,6,6,6,1,0,6,6]
    return get_standard_digital_in(status_addr[status])
  end
  
  def read_welder_control(status):
    if(isHicomm):
      return read_welder_control_hicomm(status)
    else:
      return read_welder_control_analog(status)
    end
  end
  
  def read_welder_control_hicomm(status):
    #status 0 - torch, 1 - inch, 2 - inverse inch, 3 - gas check, 4 - stick check, 6 - robot error
    status_addr = [1,2,4,8,16,32,64,128]
    global r_data = read_port_register(202)
    global b_data = integer_to_binary_list(r_data)
    if(status_addr[status]<=r_data):
      return b_data[status]
    else:
      return False
    end
  end
  #DI 0: wcr, 1:stick , 2:error
  #DO - 0:torch,1:inching,2:invser,3:gas check, 4:touch
  #status 0 - torch, 1 - inchX, 2 - inverse inchX, 3 - gas checkX, 4 - stick check, 6 - robot errorX
  # touch 4 ,torch - 0 digital INPUT
  def read_welder_control_analog(status):
    status_addr = [0,1,2,3,4,5]
    return get_standard_digital_out(status_addr[status])
  end
  
  def write_welder(status,w_value):
    if(isHicomm):
      write_welder_hicomm(status,w_value)
    else:
      write_welder_analog(status,w_value)
    end
  end
  
  def write_welder_hicomm(status,w_value):
    #status 0 - torch, 1 - inch, 2 - inverse inch, 3 - gas check, 4 - stick check, 6 - robot error
    status_addr = [1,2,4,8,16,64]
    write_port_register(201,1)
    if(w_value):
      r_data = status_addr[status]
    elif(w_value==False):
      r_data = 0
    end
    write_port_register(202,r_data)
    write_port_register(149,r_data)
    # write_output_float_register(22,r_data)
  end
  
    #status 0 - torch, 1 - inchX, 2 - inverse inchX, 3 - gas checkX, 4 - stick check, 6 - robot errorX
    # touch 4, touch - 0 digital INPUT
  def write_welder_analog(status,w_value):
    status_addr = [0,1,2,3,4,5]
    set_standard_digital_out(status_addr[status],w_value)
    # write_output_float_register(22,status_addr[status])
  end
  
  def ori_move(origin_pose,angle_pose):
    global get_ori_p = p[origin_pose[0],origin_pose[1],origin_pose[2],angle_pose[3],angle_pose[4],angle_pose[5]]
    movel(get_ori_p,a=0.8,v=0.4)
  end
  
  def ori_pose(origin_pose,angle_pose):
    return p[origin_pose[0],origin_pose[1],origin_pose[2],angle_pose[3],angle_pose[4],angle_pose[5]]
  end
  
  def put_pose(origin_pose,put_index,put_value):
    origin_pose[put_index]=put_value
    return origin_pose
  end
  
  def register_read(register_num):
    r_data = read_port_register(register_num)
    if(r_data> 32768):
      return r_data - 65535
    else:
      return r_data
    end
  end
  
  def tilt_2f_fun(get_p,tilt_deg,welding_dir,rotat = False,get_feature=p[0,0,0,0,0,0]):
    if(get_feature==p[0,0,0,0,0,0]):
      get_feature = get_p
    end
    if(welding_dir==-1):
      vir_v = -1
    else:
      vir_v = 1
    end
    cal_off_ang_rx = 1
    get_angle_rx = welding_angle_cal_2f(get_p[1],tilt_deg,vir_v,cal_off_ang_rx)
  
    if(rotat==False):
      get_p = pose_trans(get_p,p[0,0,0,0,0,d2r(-90)])
    end
    get_p = feature_offset(get_p,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1]),d2r(tilt_deg[2])],get_feature)
    return get_p
  end
  
  def tilt_3f_fun(get_p,tilt_deg,z_bottom,get_feature=p[0,0,0,0,0,0]):
    if(get_feature==p[0,0,0,0,0,0]):
      get_feature = get_p
    end
    cal_off_ang_ry = 1
    global get_angle_ry = welding_angle_cal_3f(get_p[2],tilt_deg,z_bottom,cal_off_ang_ry)
    get_p = feature_offset(get_p,p[0,0,0,d2r(tilt_deg[0]),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],get_feature)
    return get_p
  end
  
  def calculate_3f(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay):
    # y_radius of tri wave is wving_amplitude (mm)
    global y_radius = wving_amplitude / 2
    # get total line distance without rotation (mm)
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis2 = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
    #global wving_frequency_2 = wving_frequency
  
    #Circle_Speed=(a2_speed_cpm/6)*(a4_wv_frequency*(b3_wv_delay1+b4_wv_delay2+b5_wv_delay3+b6_wv_delay4)+1)*1.2
    #cpm - cm per minute 1 cpm - 10mm per minute = 1/6mm per second = cpm * 1/6 mm/sec
    # total running time (sec) - cir_speed_org cpm.
    global wv_times_org = move_dis/(cir_speed_org/6)
    global wv_times = wv_times_org
  
    # wv tri total count (times) - speed and arrive right position is more important so floor hz
    # dwell time 0.4 초면 1.4초당 3.3회를 해야 한다.
    # total time 100초, delay 1초, hz5 - 2sec 5times. 100/5*2
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
  
    system_delay = 0.12044 + (wving_frequency-1)*0.038
    wv_times = wv_times_org - (wv_total_hz*2*system_delay)
    # wv_total_hz = floor(wv_times*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
  
    # wv tri_half total count (times)
    global get_total = wv_total_hz*2
    # wv step -> final value should be same with get_total
  
    # x radius of tri wave
    global x_radius = (move_dis/wv_total_hz)
    # single wave distance
    global wave_dis = sqrt((x_radius*x_radius)+(y_radius*y_radius))*4
    # total robot distance
    global total_dis = wv_total_hz * wave_dis
  
    # robot speed distance/time = speed
    wv_system_speed = total_dis / (wv_times)
    if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  
  
  def set_current_voltage(o_cur,o_vol):
    if(isHicomm):
      set_current_voltage_hicomm(o_cur,o_vol)
    else:
      set_current_voltage_analog(o_cur,o_vol)
    end
  end
  
  def set_current_voltage_hicomm(o_cur,o_vol):
      write_port_register(204,o_cur)
      write_port_register(205,o_vol*10)
      write_port_register(133,o_cur)
      write_port_register(134,o_vol*10)
  end
  
  def set_current_voltage_analog(o_cur,o_vol):
      vol_an=((o_vol-14)/2.8)/10
      amp_an=((o_cur-60)/44)/10
      set_standard_analog_out(0,vol_an)
      set_standard_analog_out(1,amp_an)
      write_port_register(133,o_cur)
      write_port_register(134,o_vol*10)
  end
  
  
  def calculate_2f_old(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay,wving_crater):
    global y_radius = wving_amplitude / 2
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
  
    global wv_times_org = move_dis/(cir_speed_org*1/6)
    global wv_times = wv_times_org
  
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
    system_delay = 0.00832
    global wv_times = wv_times_org - (wv_total_hz*2*system_delay)
  
    global get_total = wv_total_hz
    dir=1
    ratio_t_sam = 1/get_total*1
    T1_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    ratio_t_sam = ratio_t_sam + 1/get_total
    T2_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    global push_angle = wving_crater[6]
    global push_dis_sam = norm(y_radius)/tan(d2r(push_angle))
    Tp1_sam = feature_offset(T1_sam,p[0,dir*y_radius,0,0,0,0],wv_Line_Feature2)
    Tp1_sam = feature_offset(T1_sam,p[push_dis_sam,0,0,0,0,0],wv_Line_Feature2)
    Tp2_sam = feature_offset(T2_sam,p[0,-dir*y_radius,0,0,0,0],wv_Line_Feature2)
    Tp3_sam = feature_offset(T2_sam,p[0,dir*y_radius,0,0,0,0],wv_Line_Feature2)
    Tp3_sam = feature_offset(T2_sam,p[push_dis_sam,0,0,0,0,0],wv_Line_Feature2)
  
    global total_dis = wv_total_hz * (point_dist(Tp1_sam,Tp2_sam)+point_dist(Tp3_sam,Tp2_sam))
    wv_system_speed = total_dis / wv_times
      if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  
  
  def calculate_2f(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay,wving_crater):
    global y_radius = wving_amplitude / 2
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
    global wv_times_org = move_dis/(cir_speed_org*1/6)
    global wv_times = wv_times_org
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
    global get_total = wv_total_hz*4
  
    dir=1
    ratio_t_sam = 1/get_total*1
    T1_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    global ratio_t_sam = ratio_t_sam + 2/get_total
    T2_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    ratio_t_sam = ratio_t_sam + 1/get_total
    T3_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    global push_angle = wving_crater[6]
    global push_dis_sam = norm(y_radius)/tan(d2r(push_angle))
    Tp1_sam = feature_offset(T1_sam,p[0,dir*y_radius/1000,0,0,0,0],wv_Line_Feature2)
    Tp1_sam = feature_offset(Tp1_sam,p[push_dis_sam/1000,0,0,0,0,0],wv_Line_Feature2)
    Tp2_sam = feature_offset(T2_sam,p[0,-dir*y_radius/1000,0,0,0,0],wv_Line_Feature2)
    global total_dis = wv_total_hz * (get_line_dist(tg_wv_wp1,Tp1_sam)+get_line_dist(Tp1_sam,Tp2_sam)+get_line_dist(Tp2_sam,T3_sam))*1000
    wv_system_speed = total_dis / wv_times
    system_delay =  (wv_system_speed*2.1)/1000
    wv_times = wv_times_org - (wv_total_hz*2*system_delay)
    wv_system_speed = total_dis / wv_times
    get_total = wv_total_hz*2
  
      if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  def weaving_simple(wv_wp1,wv_wp3,cir_speed_org,wving_frequency,wving_amplitude,welding_on):
    wv_dist = 0
    tilt_deg = [0,0,0]
    wving_delay = [0,0,0,0]
    wving_type = 1
    Arc_sen=[0,0,0,0,0,0]
    wv_gap=[0,0,0,0]
    welding_dir=1
    z_param=[0,0,0,0,0]
    par_2f=False
    wving_crater=[0,0,0,0,0,0,0,0,0,0]
    ext_fun=[0,0,0,0,0,0,0,0,0,0,0]
    wv_seq = [0,-1]
    wv_feature=p[0,0,0,0,0,0]
    wv_weldpar=[0,cir_speed_org,0,wving_frequency,wving_amplitude,wving_type,welding_dir]
    line_weaving_tp(wv_wp1,wv_wp3,wv_weldpar,tilt_deg,wving_delay,welding_on,Arc_sen,wv_gap,z_param,par_2f,wving_crater,ext_fun,wv_seq,wv_feature)
  end
  
  def line_weaving_tp(wv_wp1,wv_wp3,wv_weldpar=[100,10,0,1,5,1,1],tilt_deg=[0,0,0],wving_delay=[0,0,0,0],welding_on=False,Arc_sen=[0,0,0,0,0,0],wv_gap=[0,0,0,0],z_param=[0,0,0,0,0],par_2f=False,wving_crater=[0,0,0,0,0,0,0,0,0,0],ext_fun=[0,0,0,0,0,0,0,0,0,0,0],wv_seq = [0,-1],wv_feature=p[0,0,0,0,0,0]):
    global start_gas_time = 2
    global counter_average = 1
    global counter_average_num = 0
    global waste_cycle = ext_fun[8]
    if(par_2f):
      global squash_cycle = 0
    else:
      global squash_cycle = ext_fun[7]
    end
    global th_ext_fun = ext_fun
    RTDE_init()
  
    # e-Series 2, CB-Seris 8
    global system_bus_ms = 2
  
    global sin_dir = wv_seq[1]
    global start_trig = False
    dir=1
  
    global tri_count=0
  
    global z_bottom = z_param[0]/1000
    if(wv_weldpar[6]==-1):
      global vir_v = -1
    else:
      global vir_v = 1
    end
  
    if(par_2f):
      global cal_off_ang_rx = 1
      global cal_off_ang_ry = 0
    else:
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 1
    end
  
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      tilt_deg = [0,0,0]
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 0
    end
  
    global wv_Line_Feature2 = wv_wp1
    if(wv_weldpar[0] > 650 and par_2f == False):
      wv_weldpar[0] = 650
    end
    if(wv_wp3==p[0,0,0,0,0,0]):
      global wv_wp2 = feature_offset(wv_wp1,p[wv_weldpar[0]/1000,0,0,0,0,0],wv_Line_Feature2)
    else:
      global wv_wp2 = wv_wp3
      wv_weldpar[0] = point_dist(wv_wp1,wv_wp2)*1000
      global wv_dist_bak = point_dist(wv_wp1,wv_wp2)*1000
    end
    if(wv_feature != p[0,0,0,0,0,0]):
      wv_Line_Feature2 = wv_feature
    end
    #setting
    if(par_2f):
      #todo - 1
      global offset_2f_k = -1 * ext_fun[9]
      global offset_2f_z = 1 * ext_fun[10]
      if(wv_seq[0] == 0 or wv_seq[0] == 1):
        line_feature = get_feature_Line(wv_wp1,wv_wp2)
        b_p1 = wv_wp1
        b_p2 = feature_offset(wv_wp1,p[0,0.02*vir_v,0,0,0,0],line_feature)
        # b_p2 = feature_offset(wv_wp1,p[0,0.01,0,0,0,0],line_feature)
        b_p3 = pose_add(wv_wp1,p[0,0,0.02,0,0,0])
  
        back_feature = get_feature_plane_xz(b_p1,b_p2,b_p3)
  
        wv_wp1 = pose_trans(wv_wp1,p[0,0,0,0,0,d2r(-90)])
        wv_wp1 = feature_offset(wv_wp1,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp1 = pose_add(wv_wp1,p[0,0,offset_2f_z/1000,0,0,0])
        global bak_wv_wp1 = wv_wp1
      end
        wv_wp2 = feature_offset(wv_wp2,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp2 = pose_add(wv_wp2,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp2 = p[wv_wp2[0],wv_wp2[1],wv_wp2[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        global bak_wv_wp2 = wv_wp2
    end
    if(ext_fun[2]==1 and par_2f==False):
      w_voltage = ext_fun[3]
      w_current = ext_fun[4]
      set_current_voltage(w_current,w_voltage)
      global cir_speed_org_bak = wv_weldpar[1]
      global wving_amplitude_bak = wv_weldpar[4]
      wv_weldpar[1] = ext_fun[6]
      wv_weldpar[4] = ext_fun[5]
    end
    if(par_2f):
      global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
    else:
      global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay)
      x_radius = x_radius / 1000
    end
    global wv_set_speed = wv_system_speed
    ratio_t=0
    global y_radius = y_radius / 1000
    global y_radius_bak = y_radius
    global ext_stick = 0
    global th_arc_sen=Arc_sen
    global th_wv_gap=wv_gap
    global th_tilt_deg=tilt_deg
    global last_tilt_deg = th_tilt_deg
    global last_wv_wp1 = wv_wp1
    global last_wv_line = wv_Line_Feature2
    global last_z_bottom = z_bottom
    global th_wving_crater=wving_crater
    global th_par_2f = par_2f
    global th_cir_speed_org=wv_weldpar[1]
    global th_wv_wp1 = wv_wp1
    global th_wv_wp2 = wv_wp2
    global th_wv_wp3 = wv_wp3
    global th_wv_weldpar=wv_weldpar
    global th_wving_delay=wving_delay
    global th_z_param=z_param
    global th_wv_seq = wv_seq
    global th_wv_feature=wv_feature
    global th_dir = dir
  
    # if want to use approach position
    if(wv_seq[0] ==0 or wv_seq[0] == 1):
      global get_angle_rx = welding_angle_cal_2f(wv_wp1[1],tilt_deg,vir_v,cal_off_ang_rx)
      global get_angle_ry = welding_angle_cal_3f(wv_wp1[2],tilt_deg,z_bottom,cal_off_ang_ry)
  
      target_p = feature_offset(wv_wp1,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],wv_Line_Feature2)
  
      if(wv_weldpar[2]==1):
        target_p_appr = feature_offset(target_p,p[0,0,-0.02,0,0,0],wv_Line_Feature2)
        movel(target_p_appr,a=0.5,v=0.125)
      end
      movel(target_p,a=0.5,v=0.125)
    end
    CThread = run CalThread()
    DThread = run diff_Thread()
    TThread = run thread_timer()
    global timer_counting=True
    global program_weld_on = True
  
    if(a9_wv_weldingon==True):
      while(welding_off_t==55):
        sync()
      end
      if(wving_crater[2]>0):
        set_current_voltage(wving_crater[0],wving_crater[1])
      end
      if(welding_off_t != 1):
        if(isHicomm):
          write_welder(0,True)
        else:
          set_standard_digital_out(0,True)
        end
        while(read_welder(5)==False):
          if(weld_onoff==False):
              write_welder(0,True)
          end
          sync()
        end
        if(wving_crater[2]>0):
          #Crater Begin option
          write_output_float_register(1,1)
          sleep(wving_crater[2])
          set_current_voltage(ext_fun[1],ext_fun[0])
        end
      end
    end
    start_gas_time = 0
  
    background_cal=1
    background_ready=0
    FT_trig=True
    timer_1_is_counting = True
    global welding_program = False
  
    while((ratio_t < 1)):
      if( (norm(tri_count)>=2 and par_2f==False or FT_trig==True) or (norm(tri_count)>=4 and par_2f or FT_trig==True) ):
        FT_trig = False
        while(background_ready==0):
          sync()
        end
        tri_count = 0
        background_ready = 0
        global move_p = background_pose
        wv_wp2 = th_wv_wp2
        if(par_2f):
          background_cal=1
        else:
          background_cal=1
        end
        global a_val = 3
        if(a_val >= 30):
          write_port_register(142,112)
          sleep(0.5)
          halt
        end
      end
      if(wv_weldpar[5] ==1):
          if( (sin_dir==1 and wving_delay[0]==0) or (sin_dir==-1 and wving_delay[2]==0)):
           tri_count = tri_count + 1
          end
          global target_p = move_p[tri_count]
          write_output_float_register(24,tri_count)
          # target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
          tri_count = tri_count + 1
      elif(wv_weldpar[5] ==2):
        if(tri_count==0 and wving_delay[0]==0):
         tri_count = tri_count + 1
        end
        global target_p = move_p[tri_count]
        if(tri_count==0 and wving_delay[2]==0):
         tri_count = tri_count + 1
        end
        write_output_float_register(24,tri_count)
        # target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
        tri_count = tri_count + 1
      else:
        popup("Please insert 0 - sin or 1 - triangle")
      end
      if(target_p == p[0,0,0,0,0,0]):
        target_p = get_actual_tcp_pose()
      end
      #3F tri_count 2 는 tri_count가 계속 move_p[1]만 간다
  
      if((norm(tri_count)== 2) and wving_delay[1]>0 and par_2f):
        #2
        write_output_float_register(25,1)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[1])
        peak_value = 100
      elif((norm(tri_count)== 4) and wving_delay[3]>0 and par_2f):
        #4
        write_output_float_register(25,2)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[3])
        peak_value = 100
      elif((norm(tri_count)== 2) and sin_dir==1 and wving_delay[1]>0 and par_2f == False):
        write_output_float_register(25,3)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[1])
        peak_value = 100
      elif((norm(tri_count)== 2) and sin_dir==-1 and wving_delay[3]>0 and par_2f == False):
        write_output_float_register(25,5)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[3])
        peak_value = 100
      elif((norm(tri_count)== 1) and wving_delay[0]>0 and par_2f):
        #1
        write_output_float_register(25,6)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[0])
        peak_value = 100
      elif((norm(tri_count)== 3) and wving_delay[2]>0 and par_2f):
        #3
        write_output_float_register(25,7)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[2])
        peak_value = 100
      else:
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        write_output_float_register(25,8)
        peak_value = 100
      end
      global last_pose = target_p
    end
    timer_1_is_counting = False
  
    if(a9_wv_weldingon == True and wving_crater[5]!=0):
      #crater end option
      set_current_voltage(wving_crater[3],wving_crater[4])
      sleep(wving_crater[5])
      program_weld_on = False
      set_current_voltage(ext_fun[1],ext_fun[0])
      if(isHicomm):
        write_port_register(202,0)
        write_port_register(149,0)
      else:
        set_standard_digital_out(0,False)
      end
      while(read_welder(5)==True):
        if(weld_onoff==True):
          write_welder(0,False)
        end
        sync()
      end
    end
    timer_counter = 0
    kill CThread
    kill DThread
    kill TThread
    timer_counter = 0
    timer_counting = False
    wcr_counter = 0
    wcr_counting = False
    get_wcr = False
    welding_off_t = 0
  
    if(wv_seq[0] == 0 or wv_seq[0] == 3):
      if(a9_wv_weldingon==True):
        program_weld_on = False
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
        if(wv_weldpar[2]==1):
          target_pos = feature_offset(get_actual_tcp_pose(),p[0,0,-0.01,0,0,0],wv_Line_Feature2)
          movel(target_pos,0.5,0.01)
        end
      end
    end
    background_pose = [dumy_p,dumy_p,dumy_p,dumy_p]
    move_p = background_pose
    return sin_dir
  end
  
  
  def line_weaving_tp_l(wv_wp1,wv_wp3,wv_weldpar=[100,10,0,1,5,1,1],tilt_deg=[0,0,0],wving_delay=[0,0,0,0],welding_on=False,Arc_sen=[0,0,0,0,0,0],wv_gap=[0,0,0,0],z_param=[0,0,0,0,0],par_2f=False,wving_crater=[0,0,0,0,0,0,0,0,0,0],ext_fun=[0,0,0,0,0,0,0,0,0,0,0],wv_seq = [0,-1],wv_feature=p[0,0,0,0,0,0]):
    global start_gas_time = 2
    global counter_average = 1
    global counter_average_num = 0
    global waste_cycle = ext_fun[8]
    global current_list = 0
    global wv_wp4 = wv_wp3
    global A_T1 = wv_wp4[0]
    global A_T2 = wv_wp4[1]
    global A_T3 = wv_wp4[2]
    if(par_2f):
      global squash_cycle = 0
    else:
      global squash_cycle = ext_fun[7]
    end
    global th_ext_fun = ext_fun
    RTDE_init()
  
    if (wv_gap[0]==1):
      gap_check = True
      wv_gap[0]=0
    else:
      gap_check= False
    end
    # e-Series 2, CB-Seris 8
    global system_bus_ms = 2
  
    global sin_dir = wv_seq[1]
    global start_trig = False
    dir=1
  
    global tri_count=0
  
    global z_bottom = z_param[0]/1000
    if(wv_weldpar[6]==-1):
      global vir_v = -1
    else:
      global vir_v = 1
    end
  
    if(par_2f):
      global cal_off_ang_rx = 1
      global cal_off_ang_ry = 0
    else:
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 1
    end
  
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      tilt_deg = [0,0,0]
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 0
    end
  
    global wv_Line_Feature2 = wv_wp1
    if(wv_weldpar[0] > 700 and par_2f == False):
      wv_weldpar[0] = 700
    end
    if(wv_wp3[0]==p[0,0,0,0,0,0]):
      global wv_wp2 = feature_offset(wv_wp1,p[wv_weldpar[0]/1000,0,0,0,0,0],wv_Line_Feature2)
    else:
      global wv_wp2 = wv_wp4[0]
      wv_weldpar[0] = point_dist(wv_wp1,wv_wp2)*1000
      global wv_dist_bak = point_dist(wv_wp1,wv_wp2)*1000
    end
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      wv_Line_Feature2 = wv_feature
    end
    #setting
    if(par_2f):
      #todo - 1
      offset_2f_k = -1 * ext_fun[9]
      offset_2f_z = 1 * ext_fun[10]
      if(wv_seq[0] == 0 or wv_seq[0] == 1):
        line_feature = get_feature_Line(wv_wp1,wv_wp2)
        b_p1 = wv_wp1
        b_p2 = feature_offset(wv_wp1,p[0,0.01*vir_v,0,0,0,0],line_feature)
        b_p3 = pose_add(wv_wp1,p[0,0,0.01,0,0,0])
  
        back_feature = get_feature_plane_xz(b_p1,b_p2,b_p3)
        wv_wp1 = pose_trans(wv_wp1,p[0,0,0,0,0,d2r(-90)])
        wv_wp1 = feature_offset(wv_wp1,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp1 = pose_add(wv_wp1,p[0,0,offset_2f_z/1000,0,0,0])
        # wv_wp1 = pose_add(wv_wp1,p[offset_2f_k/1000,0,0,0,0,0])
      end
        # wv_wp2 = pose_add(wv_wp2,p[offset_2f_k/1000,0,0,0,0,0])
        wv_wp2 = feature_offset(wv_wp2,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp2 = pose_add(wv_wp2,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp2 = p[wv_wp2[0],wv_wp2[1],wv_wp2[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[0],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[0] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[1],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[1] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[2],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[2] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
    end
    if(ext_fun[2]==1 and par_2f==False):
      #squash
      w_voltage = ext_fun[3]
      w_current = ext_fun[4]
      set_current_voltage(w_current,w_voltage)
      global cir_speed_org_bak = wv_weldpar[1]
      global wving_amplitude_bak = wv_weldpar[4]
      wv_weldpar[1] = ext_fun[6]
      wv_weldpar[4] = ext_fun[5]
    end
    if(par_2f):
      global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
    else:
      global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay)
      x_radius = x_radius / 1000
    end
    global wv_set_speed = wv_system_speed
    ratio_t=0
    # mm -> m
    global y_radius = y_radius / 1000
    global y_radius_bak = y_radius
    #init for thread
    global ext_stick = 0
    global th_arc_sen=Arc_sen
    global th_wv_gap=wv_gap
    global th_tilt_deg=tilt_deg
    global last_tilt_deg =th_tilt_deg
    global last_wv_wp1 = wv_wp1
    global last_wv_line = wv_Line_Feature2
    global th_wving_crater=wving_crater
    global last_z_bottom = z_bottom
    global th_par_2f = par_2f
    global th_cir_speed_org=wv_weldpar[1]
    global th_wv_wp1 = wv_wp1
    global th_wv_wp2 = wv_wp2
    global th_wv_wp3 = wv_wp3[0]
    global th_wv_weldpar=wv_weldpar
    global th_wving_delay=wving_delay
    global th_z_param=z_param
    global th_wv_seq = wv_seq
    global th_wv_feature=wv_feature
    global th_dir = dir
  
    # if want to use approach position
    if(wv_seq[0] ==0 or wv_seq[0] == 1):
      global get_angle_rx = welding_angle_cal_2f(wv_wp1[1],tilt_deg,vir_v,cal_off_ang_rx)
      global get_angle_ry = welding_angle_cal_3f(wv_wp1[2],tilt_deg,z_bottom,cal_off_ang_ry)
  
      target_p = feature_offset(wv_wp1,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],wv_Line_Feature2)
  
      if(wv_weldpar[2]==1):
        target_p_appr = feature_offset(target_p,p[0,0,-0.02,0,0,0],wv_Line_Feature2)
        movel(target_p_appr,a=0.5,v=0.125)
      end
      movel(target_p,a=0.5,v=0.125)
    end
  
    CThread = run CalThread()
    DThread = run diff_Thread()
    TThread = run thread_timer()
    global timer_counting=True
    global program_weld_on = True
  
    if(a9_wv_weldingon==True):
      while(welding_off_t==55):
        sync()
      end
      if(wving_crater[2]>0):
        set_current_voltage(wving_crater[0],wving_crater[1])
      end
      if(welding_off_t != 1):
        write_welder(0,True)
        while(get_wcr==False):
          if(weld_onoff==False):
            write_welder(0,True)
          end
          sync()
        end
        if(wving_crater[2]>0):
          #Crater Begin option
          write_output_float_register(1,1)
          sleep(wving_crater[2])
          set_current_voltage(ext_fun[1],ext_fun[0])
        end
      end
    end
    start_gas_time = 0
  
    background_cal=1
    background_ready=0
    FT_trig=True
  
    timer_1_is_counting = True
  
    while((ratio_t < 1) or current_list==0 or current_list==1):
      if(ratio_t>=1 and current_list!=2):
        if (gap_check):
          gap_check = True
          wv_gap[0]=1
          th_wv_gap[0]=1
          gap_check= False
        end
        ratio_t=0
        if(current_list==0):
          wving_amp_bak = wv_weldpar[4]
          wv_weldpar[4] = wv_weldpar[4] * 1
          th_wv_weldpar[4] = wv_weldpar[4]
          circle_speed_bak = wv_weldpar[1]
          wv_weldpar[1]= wv_weldpar[1]*0.7
          th_wv_weldpar[1]= wv_weldpar[1]
        elif(current_list==1):
          wv_weldpar[4] = wving_amp_bak
          th_wv_weldpar[4] = wv_weldpar[4]
          wv_weldpar[1] = circle_speed_bak
          th_wv_weldpar[1]= wv_weldpar[1]
        end
        wv_wp1=wv_wp4[current_list]
        wv_wp2=wv_wp4[current_list+1]
        global th_wv_wp1 = wv_wp4[current_list]
        global th_wv_wp2 = wv_wp4[current_list+1]
        global th_wv_wp3 = wv_wp4[current_list+1]
        wv_system_speed_bak = wv_system_speed
        if(par_2f):
          global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp4[current_list],wv_wp4[current_list+1],wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
          global y_radius = y_radius / 1000
          global y_radius_bak = y_radius
        else:
          global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp4[current_list],wv_wp4[current_list+1],wv_weldpar[1],wv_weldpar[3],wving_delay)
          x_radius = x_radius / 1000
        end
        wv_system_speed = wv_system_speed_bak
        current_list=current_list+1
      end
  
      if( (norm(tri_count)>=2 and par_2f==False or FT_trig==True) or (norm(tri_count)>=4 and par_2f==True or FT_trig==True)   ):
        FT_trig = False
        while(background_ready==0):
          sync()
        end
        tri_count = 0
        background_ready = 0
        global move_p = background_pose
        wv_wp2 = th_wv_wp2
        if(par_2f):
          background_cal=1
        else:
          background_cal=1
        end
        global a_val = 3
        if(a_val >= 30):
          write_port_register(142,112)
          sleep(0.5)
          halt
        end
      end
  
      if(wv_weldpar[5] ==1):
          if( (sin_dir==1 and wving_delay[0]==0) or (sin_dir==-1 and wving_delay[2]==0)):
           tri_count = tri_count + 1
          end
          global target_p = move_p[tri_count]
          target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
          tri_count = tri_count + 1
      elif(wv_weldpar[5] ==2):
        if( (tri_count==1 and sin_dir==1 and wving_delay[0]==0) or (tri_count==1 and sin_dir==-1 and wving_delay[2]==0)):
         tri_count = tri_count + 1
        end
        global target_p = move_p[tri_count]
        target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
        tri_count = tri_count + 1
      else:
        popup("Please insert 0 - sin or 1 - triangle")
      end
  
      write_output_float_register(24,tri_count)
      if(target_p == p[0,0,0,0,0,0]):
        target_p = get_actual_tcp_pose()
      end
  
      if((norm(tri_count)== 2) and wving_delay[1]>0 and par_2f):
        write_output_float_register(25,1)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[1])
        peak_value = 100
      elif((norm(tri_count)== 4) and wving_delay[3]>0 and par_2f):
        write_output_float_register(25,2)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[3])
        peak_value = 100
      elif((norm(tri_count)== 2) and sin_dir==1 and wving_delay[1]>0 and par_2f == False):
        write_output_float_register(25,3)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[1])
        peak_value = 100
      elif((norm(tri_count)== 2) and sin_dir==-1 and wving_delay[3]>0 and par_2f == False):
        write_output_float_register(25,5)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[3])
        peak_value = 100
      elif((norm(tri_count)== 1) and sin_dir==1 and wving_delay[0]>0 and par_2f):
        write_output_float_register(25,6)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[0])
        peak_value = 100
      elif((norm(tri_count)== 3) and sin_dir==-1 and wving_delay[2]>0 and par_2f):
        write_output_float_register(25,7)
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        peak_value = 0
        sleep(wving_delay[2])
        peak_value = 100
      else:
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        write_output_float_register(25,8)
        peak_value = 100
      end
      global last_pose = target_p
    end
    timer_1_is_counting = False
    welding_program = True
    if(a9_wv_weldingon == True and wving_crater[5]!=0):
      #crater end option
      set_current_voltage(wving_crater[3],wving_crater[4])
      sleep(wving_crater[5])
      program_weld_on = False
      set_current_voltage(ext_fun[1],ext_fun[0])
      if(isHicomm):
        write_port_register(202,0)
        write_port_register(149,0)
      else:
        set_standard_digital_out(0,False)
      end
      while(get_wcr==True):
        if(weld_onoff==True):
          if(isHicomm):
            write_port_register(202,0)
            write_port_register(149,0)
          else:
            set_standard_digital_out(0,False)
          end
        end
        sync()
      end
    end
  
    kill CThread
    kill DThread
    kill TThread
    timer_counting = False
    wcr_counter = 0
    wcr_counting = False
    get_wcr = False
    welding_off_t = 0
  
    if(wv_seq[0] == 0 or wv_seq[0] == 3):
      if(a9_wv_weldingon==True):
        program_weld_on = False
        if(isHicomm):
          write_port_register(202,0)
          write_port_register(149,0)
        else:
          set_standard_digital_out(0,False)
        end
        if(wv_weldpar[2]==1):
          target_pos = feature_offset(get_actual_tcp_pose(),p[0,0,-0.01,0,0,0],wv_Line_Feature2)
          movel(target_pos,0.5,0.01)
        end
      end
    end
    background_pose = [dumy_p,dumy_p,dumy_p,dumy_p]
    move_p = background_pose
    return sin_dir
  end
  $ 151 "Reset"
  $ 152 "If Reset_Trig"
  if (Reset_Trig):
    $ 153 "Reset_Trig≔ False "
    global Reset_Trig=  False  
    $ 154 "Call robotand_cell_initalizat"
    robotand_cell_initalizat()
    $ 155 "Auto_trig≔ False "
    global Auto_trig=  False  
    $ 156 "write_port_register(cell_3f_2f_151,0)"
    write_port_register(cell_3f_2f_151,0)
    $ 157 "write_port_register(cell_info_152,0)"
    write_port_register(cell_info_152,0)
    $ 158 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 159 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 160 "write_port_register(robot_move_163,0)"
    write_port_register(robot_move_163,0)
    $ 161 "write_port_register(robot_pose_164,0)"
    write_port_register(robot_pose_164,0)
    $ 162 "write_port_register(182,0)"
    write_port_register(182,0)
    $ 163 "write_port_register(185,0)"
    write_port_register(185,0)
    $ 164 "write_port_register(201,0)"
    write_port_register(201,0)
    $ 165 "write_port_register(202,0)"
    write_port_register(202,0)
  end
  $ 166 "Welding_Init"
  $ 167 "'welding parameter initialization'"
  # 'welding parameter initialization'
  $ 168 "welding_etc"
  $ 196 "c5_wv_gap_y≔0"
  global c5_wv_gap_y=0
  $ 197 "c6_wv_gap_cpm≔0"
  global c6_wv_gap_cpm=0
  $ 198 "c9_wv_gap_freq≔0"
  global c9_wv_gap_freq=0
  $ 199 "c4_gap_enable≔0"
  global c4_gap_enable=0
  $ 200 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
  global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
  $ 201 "init_reset_modbus_server"
  $ 202 "set_tool_voltage(24)"
  set_tool_voltage(24)
  $ 203 "write_port_register(163,0)"
  write_port_register(163,0)
  $ 204 "write_port_register(164,0)"
  write_port_register(164,0)
  $ 206 "write_port_register(201,1)"
  write_port_register(201,1)
  $ 207 "write_port_register(202,0)"
  write_port_register(202,0)
  $ 1277 "Thread_2"
  thread Thread_2():
    while (True):
      $ 1278 "Thread_heartbeat"
      $ 1279 "heartbeat≔heartbeat+1"
      global heartbeat=heartbeat+1
      $ 1280 "If heartbeat>499"
      if (heartbeat>499):
        $ 1281 "heartbeat≔0"
        global heartbeat=0
      end
      $ 1282 "write_port_register(128,heartbeat)"
      write_port_register(128,heartbeat)
      $ 1292 "Wait: 1.0"
      sleep(1.0)
    end
  end
  threadId_Thread_2 = run Thread_2()
  $ 1293 "Thread_1"
  thread Thread_1():
    while (True):
      $ 1294 "thread main"
      $ 1295 "a0_Job_Mode≔read_port_register(162)"
      global a0_Job_Mode= read_port_register (162)
      $ 1296 "a1_job_move≔read_port_register(163)"
      global a1_job_move= read_port_register (163)
      $ 1297 "If red_led≟ True "
      if (get_tool_digital_out(0) ==   True  ):
        $ 1298 "Set red_led=Off"
        set_tool_digital_out(0, False)
      end
      $ 1299 "If a0_Job_Mode≟2"
      if (a0_Job_Mode == 2):
        $ 1300 "If read_port_register(arc_onoff_168)≟2"
        if ( read_port_register (arc_onoff_168) == 2):
          $ 1301 "a9_wv_weldingon≔ True "
          global a9_wv_weldingon=  True  
        else:
          $ 1302 "Else" "noBreak"
          $ 1303 "a9_wv_weldingon≔ False "
          global a9_wv_weldingon=  False  
        end
        $ 1304 "If Auto_trig"
        if (Auto_trig):
          $ 1305 "get_next_number≔read_port_register(166)"
          global get_next_number= read_port_register (166)
          $ 1306 "get_move_trig≔read_port_register(167)"
          global get_move_trig= read_port_register (167)
          $ 1307 "If get_move_trig≟1 and running_trig≟ True "
          if (get_move_trig == 1  and  running_trig ==   True  ):
            $ 1308 "If get_next_number<0 or get_next_number>30"
            if (get_next_number<0  or  get_next_number>30):
              $ 1309 "write_port_register(142,141)"
              write_port_register(142,141)
              $ 1310 "Halt"
              halt
            end
            $ 1311 "If get_next_number≠Auto_cur_cell"
            if (get_next_number != Auto_cur_cell):
              $ 1312 "running_trig≔ False "
              global running_trig=  False  
              $ 1313 "write_welder(0, False )"
              write_welder(0,  False  )
              $ 1314 "write_port_register(149,0)"
              write_port_register(149,0)
              $ 1315 "write_port_register(202,0)"
              write_port_register(202,0)
            else:
              $ 1316 "Else" "noBreak"
              $ 1317 "write_port_register(166,0)"
              write_port_register(166,0)
              $ 1318 "write_port_register(167,0)"
              write_port_register(167,0)
            end
          end
        end
        $ 1319 "If t_time>timer_1"
        if (t_time>timer_1):
          $ 1320 "write_port_register(143,timer_1)"
          write_port_register(143,timer_1)
        else:
          $ 1321 "Else" "noBreak"
          $ 1322 "write_port_register(143,timer_1)"
          write_port_register(143,timer_1)
          $ 1323 "write_port_register(144,timer_1)"
          write_port_register(144,timer_1)
        end
        $ 1324 "Monitoring touch and welding"
        $ 1325 "If read_welder_control(0) and read_port_register(130)≠1"
        if (read_welder_control(0)  and   read_port_register (130) != 1):
          $ 1326 "write_port_register(130,1)"
          write_port_register(130,1)
        else:
          $ 1327 "ElseIf read_welder_control(0) and read_port_register(130)≠0"
          if (read_welder_control(0)  and   read_port_register (130) != 0):
            $ 1328 "write_port_register(130,0)"
            write_port_register(130,0)
          end
        end
        $ 1329 "If read_welder(5)"
        if (read_welder(5)):
          $ 1330 "'check wcr in (digital)'"
          # 'check wcr in (digital)'
          $ 1331 "write_output_float_register(20,1)"
          write_output_float_register(20,1)
        else:
          $ 1332 "Else" "noBreak"
          $ 1333 "write_output_float_register(20,0)"
          write_output_float_register(20,0)
        end
        $ 1334 "If read_welder(4)"
        if (read_welder(4)):
          $ 1335 "'check touch (digital)'"
          # 'check touch (digital)'
          $ 1336 "write_output_float_register(21,1)"
          write_output_float_register(21,1)
        else:
          $ 1337 "Else" "noBreak"
          $ 1338 "write_output_float_register(21,0)"
          write_output_float_register(21,0)
        end
        $ 1339 "If read_welder_control(0)"
        if (read_welder_control(0)):
          $ 1340 "'check welding out (digital)'"
          # 'check welding out (digital)'
          $ 1341 "write_output_float_register(17,1)"
          write_output_float_register(17,1)
        else:
          $ 1342 "Else" "noBreak"
          $ 1343 "write_output_float_register(17,0)"
          write_output_float_register(17,0)
        end
        $ 1344 "If read_welder_control(4)"
        if (read_welder_control(4)):
          $ 1345 "'check touch out (digital)'"
          # 'check touch out (digital)'
          $ 1346 "write_output_float_register(18,1)"
          write_output_float_register(18,1)
        else:
          $ 1347 "Else" "noBreak"
          $ 1348 "write_output_float_register(18,0)"
          write_output_float_register(18,0)
        end
      end
      $ 1349 "If get_tool_digital_in(1)≟ True "
      if (get_tool_digital_in(1) ==   True  ):
        $ 1350 "set_tool_digital_out(1, False )"
        set_tool_digital_out(1,  False  )
      else:
        $ 1351 "Else" "noBreak"
        $ 1352 "set_tool_digital_out(1, True )"
        set_tool_digital_out(1,  True  )
      end
      $ 1353 "If red_led≟ True "
      if (get_tool_digital_out(0) ==   True  ):
        $ 1354 "Set red_led=Off"
        set_tool_digital_out(0, False)
        $ 1355 "end_freedrive_mode()"
        end_freedrive_mode()
      end
      $ 1356 "check_speed()"
      check_speed()
      $ 1357 "Wait: 0.05"
      sleep(0.05)
    end
  end
  threadId_Thread_1 = run Thread_1()
  thread EventThread():
    while (True):
      if (event_cal_on):
        $ 1359 "calculate_position"
        $ 1362 "move_i_f≔1"
        global move_i_f=1
        $ 1363 "get_pose_side≔0"
        global get_pose_side=0
        $ 1364 "Loop move_i_f<10"
        while (move_i_f<10):
          $ 1365 "If A_Touch_trig_l[move_i_f]≟ True "
          if (A_Touch_trig_l[move_i_f] ==   True  ):
            $ 1366 "If move_i_f≟A_VL1 or move_i_f≟A_VL2"
            if (move_i_f == A_VL1  or  move_i_f == A_VL2):
              $ 1367 "A_sel_v≔move_i_f"
              global A_sel_v=move_i_f
              $ 1368 "If simulation_mode"
              if (simulation_mode):
                $ 1369 "Call welding_parameter_sim"
                welding_parameter_sim()
              else:
                $ 1370 "Else" "noBreak"
                $ 1371 "Call welding_parameter_init"
                welding_parameter_init()
              end
              $ 1372 "If a8_wv_distance<5"
              if (a8_wv_distance<5):
                $ 1373 "write_port_register(142,143)"
                write_port_register(142,143)
                $ 1374 "Halt"
                halt
              end
              $ 1375 "b2_left_par≔ True "
              global b2_left_par=  True  
              $ 1376 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 1377 "If move_i_f≟A_VL2"
              if (move_i_f == A_VL2):
                $ 1378 "callar_hor≔a6_callar_hor"
                global callar_hor=a6_callar_hor
                $ 1379 "If b1_cell_info_L≟E or b1_cell_info_L≟e"
                if (b1_cell_info_L == E  or  b1_cell_info_L == e):
                  $ 1380 "'For bottom touch(zero) after offset not used now'"
                  # 'For bottom touch(zero) after offset not used now'
                  $ 1381 "vert_scallup_l≔a5_f_hole[1]"
                  global vert_scallup_l=a5_f_hole[1]
                end
                $ 1382 "b2_cell≔b1_cell_info_L"
                global b2_cell=b1_cell_info_L
              else:
                $ 1385 "Else" "noBreak"
                $ 1386 "callar_hor≔0"
                global callar_hor=0
                $ 1387 "'For bottom touch(zero) after offset not used now'"
                # 'For bottom touch(zero) after offset not used now'
                $ 1388 "vert_scallup_l≔a5_f_hole[1]"
                global vert_scallup_l=a5_f_hole[1]
                $ 1389 "b2_cell≔b1_cell_info_L"
                global b2_cell=b1_cell_info_L
              end
              $ 1390 "get_pos≔get_lr(left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)"
              global get_pos=get_lr(p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)
              $ 1391 "pre_tp≔tilt_3f_fun(get_pos,[0,0,0],0)"
              global pre_tp=tilt_3f_fun(get_pos,[0,0,0],0)
              $ 1392 "A_Prepos_l[move_i_f]=pre_tp"
              A_Prepos_l[move_i_f]=pre_tp
            else:
              $ 1393 "ElseIf move_i_f≟A_VR1 or move_i_f≟A_VR2"
              if (move_i_f == A_VR1  or  move_i_f == A_VR2):
                $ 1394 "A_sel_v≔move_i_f"
                global A_sel_v=move_i_f
                $ 1395 "If simulation_mode"
                if (simulation_mode):
                  $ 1396 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1397 "Else" "noBreak"
                  $ 1398 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1399 "If a8_wv_distance<5"
                if (a8_wv_distance<5):
                  $ 1400 "write_port_register(142,143)"
                  write_port_register(142,143)
                  $ 1401 "Halt"
                  halt
                end
                $ 1402 "b2_left_par≔ False "
                global b2_left_par=  False  
                $ 1403 "b8_wv_2f≔ False "
                global b8_wv_2f=  False  
                $ 1404 "If move_i_f≟A_VR2"
                if (move_i_f == A_VR2):
                  $ 1405 "callar_hor≔a6_callar_hor"
                  global callar_hor=a6_callar_hor
                  $ 1406 "If b1_cell_info_R≟E or b1_cell_info_R≟e"
                  if (b1_cell_info_R == E  or  b1_cell_info_R == e):
                    $ 1407 "vert_scallup_r≔a5_f_hole[1]"
                    global vert_scallup_r=a5_f_hole[1]
                  end
                  $ 1408 "b2_cell≔b1_cell_info_R"
                  global b2_cell=b1_cell_info_R
                else:
                  $ 1411 "Else" "noBreak"
                  $ 1412 "callar_hor≔0"
                  global callar_hor=0
                  $ 1413 "vert_scallup_r≔a5_f_hole[1]"
                  global vert_scallup_r=a5_f_hole[1]
                  $ 1414 "b2_cell≔b1_cell_info_R"
                  global b2_cell=b1_cell_info_R
                end
                $ 1415 "get_pos≔get_lr(right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)"
                global get_pos=get_lr(p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,callar_hor,b2_cell,center_line)
                $ 1416 "pre_tp≔tilt_3f_fun(get_pos,[0,0,0],0)"
                global pre_tp=tilt_3f_fun(get_pos,[0,0,0],0)
                $ 1417 "A_Prepos_l[move_i_f]=pre_tp"
                A_Prepos_l[move_i_f]=pre_tp
              else:
                $ 1418 "ElseIf move_i_f≟A_HOR"
                if (move_i_f == A_HOR):
                  $ 1419 "A_sel_v≔A_HOR"
                  global A_sel_v=A_HOR
                  $ 1420 "If simulation_mode"
                  if (simulation_mode):
                    $ 1421 "Call welding_parameter_sim"
                    welding_parameter_sim()
                  else:
                    $ 1422 "Else" "noBreak"
                    $ 1423 "Call welding_parameter_init"
                    welding_parameter_init()
                  end
                  $ 1424 "hor_l_scallup≔a5_f_hole[1]"
                  global hor_l_scallup=a5_f_hole[1]
                  $ 1425 "b8_wv_2f≔ True "
                  global b8_wv_2f=  True  
                  $ 1426 "b2_left_par≔ True "
                  global b2_left_par=  True  
                  $ 1427 "b2_cell≔b1_cell_info_L"
                  global b2_cell=b1_cell_info_L
                  $ 1428 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)"
                  global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)
                  $ 1429 "pre_tp≔get_pos"
                  global pre_tp=get_pos
                  $ 1430 "A_Prepos_l[move_i_f]=pre_tp"
                  A_Prepos_l[move_i_f]=pre_tp
                else:
                  $ 1431 "ElseIf move_i_f≟A_HOR_R"
                  if (move_i_f == A_HOR_R):
                    $ 1432 "A_sel_v≔A_HOR"
                    global A_sel_v=A_HOR
                    $ 1433 "If simulation_mode"
                    if (simulation_mode):
                      $ 1434 "Call welding_parameter_sim"
                      welding_parameter_sim()
                    else:
                      $ 1435 "Else" "noBreak"
                      $ 1436 "Call welding_parameter_init"
                      welding_parameter_init()
                    end
                    $ 1437 "hor_r_scallup≔a5_f_hole[2]"
                    global hor_r_scallup=a5_f_hole[2]
                    $ 1438 "b2_left_par≔ False "
                    global b2_left_par=  False  
                    $ 1439 "b8_wv_2f≔ True "
                    global b8_wv_2f=  True  
                    $ 1440 "b2_cell≔b1_cell_info_R"
                    global b2_cell=b1_cell_info_R
                    $ 1441 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)"
                    global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,0,b2_cell,center_line)
                    $ 1442 "pre_tp≔get_pos"
                    global pre_tp=get_pos
                    $ 1443 "A_Prepos_l[move_i_f]=pre_tp"
                    A_Prepos_l[move_i_f]=pre_tp
                  else:
                    $ 1444 "ElseIf move_i_f≟A_HOR_ML"
                    if (move_i_f == A_HOR_ML):
                      $ 1445 "A_sel_v≔A_HOR_ML"
                      global A_sel_v=A_HOR_ML
                      $ 1446 "If simulation_mode"
                      if (simulation_mode):
                        $ 1447 "Call welding_parameter_sim"
                        welding_parameter_sim()
                      else:
                        $ 1448 "Else" "noBreak"
                        $ 1449 "Call welding_parameter_init"
                        welding_parameter_init()
                      end
                      $ 1450 "b8_wv_2f≔ True "
                      global b8_wv_2f=  True  
                      $ 1451 "b2_left_par≔ True "
                      global b2_left_par=  True  
                      $ 1452 "b2_cell≔b1_cell_info_L"
                      global b2_cell=b1_cell_info_L
                      $ 1453 "Touch_dis≔-1*Touch_dis"
                      global Touch_dis=-1*Touch_dis
                      $ 1454 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)"
                      global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)
                      $ 1455 "Touch_dis≔-1*Touch_dis"
                      global Touch_dis=-1*Touch_dis
                      $ 1456 "pre_tp≔get_pos"
                      global pre_tp=get_pos
                      $ 1457 "A_Prepos_l[move_i_f]=pre_tp"
                      A_Prepos_l[move_i_f]=pre_tp
                    else:
                      $ 1458 "ElseIf move_i_f≟A_HOR_MR"
                      if (move_i_f == A_HOR_MR):
                        $ 1459 "A_sel_v≔A_HOR_MR"
                        global A_sel_v=A_HOR_MR
                        $ 1460 "If simulation_mode"
                        if (simulation_mode):
                          $ 1461 "Call welding_parameter_sim"
                          welding_parameter_sim()
                        else:
                          $ 1462 "Else" "noBreak"
                          $ 1463 "Call welding_parameter_init"
                          welding_parameter_init()
                        end
                        $ 1464 "b2_left_par≔ False "
                        global b2_left_par=  False  
                        $ 1465 "b8_wv_2f≔ True "
                        global b8_wv_2f=  True  
                        $ 1466 "b2_cell≔b1_cell_info_R"
                        global b2_cell=b1_cell_info_R
                        $ 1467 "Touch_dis≔-1*Touch_dis"
                        global Touch_dis=-1*Touch_dis
                        $ 1468 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)"
                        global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side,a6_callar_hor,b2_cell,center_line)
                        $ 1469 "Touch_dis≔-1*Touch_dis"
                        global Touch_dis=-1*Touch_dis
                        $ 1470 "pre_tp≔get_pos"
                        global pre_tp=get_pos
                        $ 1471 "A_Prepos_l[move_i_f]=pre_tp"
                        A_Prepos_l[move_i_f]=pre_tp
                      end
                    end
                  end
                end
              end
            end
            $ 1472 "If move_i_f≤4"
            if (move_i_f <= 4):
              $ 1473 "A_Prepos_l[move_i_f+9]=p[0,0,0,0,0,0]"
              A_Prepos_l[move_i_f+9]=p[0,0,0,0,0,0]
            end
          end
          $ 1476 "move_i_f≔move_i_f+1"
          global move_i_f=move_i_f+1
        end
        $ 1477 "event_cal_on≔ False "
        global event_cal_on=  False  
      elif (event_side_on):
        $ 1479 "calculate_side"
        $ 1482 "Wait event_cal_on≟ False "
        while (not(event_cal_on ==   False  )):
          sync()
        end
        $ 1483 "move_i_f≔1"
        global move_i_f=1
        $ 1484 "get_pose_side≔get_pose_side_t"
        global get_pose_side=get_pose_side_t
        $ 1485 "Loop move_i_f<10"
        while (move_i_f<10):
          $ 1486 "If A_Touch_trig_l[move_i_f]≟ True "
          if (A_Touch_trig_l[move_i_f] ==   True  ):
            $ 1487 "If move_i_f≟A_VL1 or move_i_f≟A_VL2"
            if (move_i_f == A_VL1  or  move_i_f == A_VL2):
              $ 1488 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
              A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
            else:
              $ 1489 "ElseIf move_i_f≟A_VR1 or move_i_f≟A_VR2"
              if (move_i_f == A_VR1  or  move_i_f == A_VR2):
                $ 1490 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
              else:
                $ 1491 "ElseIf move_i_f≟A_HOR"
                if (move_i_f == A_HOR):
                  $ 1492 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                  A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                else:
                  $ 1493 "ElseIf move_i_f≟A_HOR_R"
                  if (move_i_f == A_HOR_R):
                    $ 1494 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                    A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                  else:
                    $ 1495 "ElseIf move_i_f≟A_HOR_ML"
                    if (move_i_f == A_HOR_ML):
                      $ 1496 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                      A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                    else:
                      $ 1497 "ElseIf move_i_f≟A_HOR_MR"
                      if (move_i_f == A_HOR_MR):
                        $ 1498 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                        A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                      end
                    end
                  end
                end
              end
            end
          end
          $ 1499 "move_i_f≔move_i_f+1"
          global move_i_f=move_i_f+1
        end
        $ 1500 "event_side_on≔ False "
        global event_side_on=  False  
      elif (reset_trig):
        $ 1502 "Call reset_weld_param"
        reset_weld_param()
        $ 1503 "reset_trig≔ False "
        global reset_trig=  False  
      elif (time_cal_trig):
        $ 1505 "t_time≔time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,0)"
        global t_time=time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,0)
        $ 1506 "write_port_register(144,t_time)"
        write_port_register(144,t_time)
        $ 1507 "time_cal_trig≔ False "
        global time_cal_trig=  False  
      elif (pause_trig):
        $ 1509 "s_conn≔socket_open('192.168.1.7',29999)"
        global s_conn=socket_open("192.168.1.7",29999)
        $ 1510 "s_send≔socket_send_string('pause')"
        global s_send=socket_send_string("pause")
        $ 1511 "s_send≔socket_send_byte(10)"
        global s_send=socket_send_byte(10)
        $ 1512 "socket_close()"
        socket_close()
        $ 1513 "pause_trig≔ False "
        global pause_trig=  False  
      end
      sync()
    end
  end
  eventThread = run EventThread()
  while (True):
    $ 208 "Robot Program"
    $ 226 "If simulation_mode"
    if (simulation_mode):
      $ 227 "'work mode 2'"
      # 'work mode 2'
      $ 228 "write_port_register(162,2)"
      write_port_register(162,2)
      $ 229 "touch_temp≔0"
      global touch_temp=0
    end
    $ 230 "If a0_Job_Mode≟1"
    if (a0_Job_Mode == 1):
      $ 231 "job mode 1"
      $ 232 "'JOB_MANUAL'"
      # 'JOB_MANUAL'
      $ 233 "write_port_register(robot_ready_141,1)"
      write_port_register(robot_ready_141,1)
      $ 234 "If freedrive≟ True  and freedrive_trg≟ False "
      if (get_tool_digital_in(1) ==   True    and  freedrive_trg ==   False  ):
        $ 235 "freedrive_trg≔ True "
        global freedrive_trg=  True  
        $ 236 "freedrive_mode()"
        freedrive_mode()
      else:
        $ 237 "ElseIf freedrive≟ False  and freedrive_trg≟ True "
        if (get_tool_digital_in(1) ==   False    and  freedrive_trg ==   True  ):
          $ 238 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 239 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
      end
      $ 243 "If freedrive≟ True  and save_tool≟ True "
      if (get_tool_digital_in(1) ==   True    and  get_tool_digital_in(0) ==   True  ):
        $ 247 "Wait: 0.01"
        sleep(0.01)
      else:
        $ 248 "ElseIf a1_job_move≟1"
        if (a1_job_move == 1):
          $ 249 "'Manual - Move Home/Packing/Warmup'"
          # 'Manual - Move Home/Packing/Warmup'
          $ 250 "If read_port_register(robot_pose_164)≟1"
          if ( read_port_register (robot_pose_164) == 1):
            $ 251 "write_port_register(robot_ready_141,0)"
            write_port_register(robot_ready_141,0)
            $ 252 "homeing()"
            homeing()
            $ 253 "MoveJ"
            $ 254 "Packing_pos" "breakAfter"
            movej([1.5877798795700073, -0.0173419157611292, -2.4983108679400843, -1.4065726439105433, 1.626846194267273, 3.0169763565063477], a=0.9599310885968813, v=0.9599310885968813)
          else:
            $ 255 "ElseIf read_port_register(robot_pose_164)≟2"
            if ( read_port_register (robot_pose_164) == 2):
              $ 256 "write_port_register(robot_ready_141,0)"
              write_port_register(robot_ready_141,0)
              $ 257 "homeing()"
              homeing()
            else:
              $ 258 "ElseIf read_port_register(robot_pose_164)≟3"
              global thread_flag_258=0
              thread Thread_if_258():
                $ 259 "write_port_register(robot_ready_141,0)"
                write_port_register(robot_ready_141,0)
                $ 260 "Warm-up"
                $ 261 "Loop 22 times"
                Loop_9 = 0
                while (Loop_9 < 22):
                  $ 262 "MoveJ"
                  $ 263 "Warming_1" "breakAfter"
                  movej([1.0598392486572266, -1.0896032492267054, -1.2158034483539026, -2.3403762022601526, 1.497584342956543, 2.354665517807007], a=0.17453292519943295, v=0.08726646259971647)
                  $ 264 "Warming_2" "breakAfter"
                  movej([0.7106529474258423, -1.0894954840289515, -1.215731445943014, -2.3402441183673304, 1.4977161884307861, 2.3545455932617188], a=0.17453292519943295, v=0.08726646259971647)
                  $ 265 "Warming_3" "breakAfter"
                  movej([0.8852421641349792, -1.0894234816180628, -1.215863052998678, -2.340435806904928, 1.497644305229187, 2.3545212745666504], a=0.17453292519943295, v=0.08726646259971647)
                  $ 266 "Warming_4" "breakAfter"
                  movej([0.885266125202179, -1.263935391102926, -1.2099388281451624, -2.352635685597555, 1.4888625144958496, 2.3787333965301514], a=0.17453292519943295, v=0.08726646259971647)
                  $ 267 "Wariming_5" "breakAfter"
                  movej([0.8852541446685791, -0.9149578253375452, -1.217938248311178, -2.335618321095602, 1.501125693321228, 2.3452301025390625], a=0.17453292519943295, v=0.08726646259971647)
                  $ 268 "Warming_6" "breakAfter"
                  movej([0.8852177858352661, -1.0895074049579065, -1.3828147093402308, -2.343850914631979, 1.489568829536438, 2.3598153591156006], a=0.17453292519943295, v=0.08726646259971647)
                  $ 269 "Warming_7" "breakAfter"
                  movej([0.885229766368866, -1.0894115606891077, -1.220372502003805, -2.335630242024557, 1.5009583234786987, 2.3453502655029297], a=0.17453292519943295, v=0.08726646259971647)
                  $ 270 "Warming_8" "breakAfter"
                  movej([0.6920775233962951, -1.0506328608604214, -1.2152130579572011, -2.5072867131215766, 1.4917910996963177, 2.3459413556024855], a=0.17453292519943295, v=0.08726646259971647)
                  $ 271 "Warming_9" "breakAfter"
                  movej([0.6929177641868591, -1.0475013891803187, -1.2503178755389612, -2.327541176472799, 1.5014369487762451, 2.345398187637329], a=0.17453292519943295, v=0.08726646259971647)
                  $ 272 "Warming_10" "breakAfter"
                  movej([0.8162043690681458, -1.1462538878070276, -1.3285825888263147, -2.3897975126849573, 1.2906681299209595, 2.3704988956451416], a=0.17453292519943295, v=0.08726646259971647)
                  $ 273 "Warming_11" "breakAfter"
                  movej([0.6952417412291937, -1.0226626805382075, -1.3187663864026051, -2.3852732107244847, 1.5281305955128988, 2.3484138521676003], a=0.17453292519943295, v=0.08726646259971647)
                  $ 274 "Warming_12" "breakAfter"
                  movej([0.6938896179199219, -1.0222962538348597, -1.3204510847674769, -2.403698269520895, 1.7271294593811035, 2.3448219299316406], a=0.17453292519943295, v=0.08726646259971647)
                  $ 275 "Warming_13" "breakAfter"
                  movej([0.685538113117218, -1.038980786000387, -1.3163254896747034, -2.3712590376483362, 1.5282130241394043, 2.0345256328582764], a=0.17453292519943295, v=0.08726646259971647)
                  $ 276 "Warming_14" "breakAfter"
                  movej([0.721284806728363, -1.0075753370868128, -1.3205111662494105, -2.399587933217184, 1.5282011032104492, 2.539506673812866], a=0.17453292519943295, v=0.08726646259971647)
                  Loop_9 = Loop_9 + 1
                end
                $ 277 "homeing()"
                homeing()
                $ 278 "Wait: 2.0"
                sleep(2.0)
                thread_flag_258 = 1
              end
              if ( read_port_register (robot_pose_164) == 3):
                global thread_handler_258=run Thread_if_258()
                while (thread_flag_258 == 0):
                  if not( read_port_register (robot_pose_164) == 3):
                    kill thread_handler_258
                    thread_flag_258 = 2
                  else:
                    sync()
                  end
                end
              else:
                thread_flag_258 = 2
              end
              if (thread_flag_258 == 2):
                $ 279 "ElseIf read_port_register(robot_pose_164)≟4"
                if ( read_port_register (robot_pose_164) == 4):
                  $ 280 "write_port_register(robot_ready_141,0)"
                  write_port_register(robot_ready_141,0)
                  $ 281 "homeing()"
                  homeing()
                  $ 282 "MoveJ"
                  $ 283 "pre_mounting" "breakAfter"
                  movej([1.2356762886047363, -0.8703244368182581, -0.942230526600973, -2.3905327955829065, 1.3216267824172974, 2.6514604091644287], a=0.7853981633974483, v=0.7853981633974483)
                  $ 284 "Mounting_pos" "breakAfter"
                  movej([0.6231353085164267, -0.6300961531972575, -0.9034285948871803, -1.770059340221131, 1.417516049558281, 1.7792033261567348], a=0.7853981633974483, v=0.7853981633974483)
                else:
                  $ 285 "ElseIf read_port_register(robot_pose_164)≟5"
                  if ( read_port_register (robot_pose_164) == 5):
                    $ 286 "c_p≔get_actual_tcp_pose()"
                    global c_p= get_actual_tcp_pose ()
                    $ 287 "MoveL"
                    $ 288 "m_p≔pose_trans(c_p, p[0,0,0,d2r(tilt_deg_man),0,0])"
                    global m_p= pose_trans (c_p, p[0,0,0,d2r(tilt_deg_man),0,0])
                    $ 289 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 290 "m_p≔pose_trans(c_p, p[0,0,0,d2r(-tilt_deg_man),0,0])"
                    global m_p= pose_trans (c_p, p[0,0,0,d2r(-tilt_deg_man),0,0])
                    $ 291 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 292 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                    $ 293 "m_p≔pose_trans(c_p, p[0,0,0,0,d2r(tilt_deg_man),0])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,d2r(tilt_deg_man),0])
                    $ 294 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 295 "m_p≔pose_trans(c_p, p[0,0,0,0,d2r(-tilt_deg_man),0])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,d2r(-tilt_deg_man),0])
                    $ 296 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 297 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                    $ 298 "m_p≔pose_trans(c_p, p[0,0,0,0,0,d2r(tilt_deg_man)])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,0,d2r(tilt_deg_man)])
                    $ 299 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 300 "m_p≔pose_trans(c_p, p[0,0,0,0,0,d2r(-tilt_deg_man)])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,0,d2r(-tilt_deg_man)])
                    $ 301 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 302 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                  end
                end
              end
            end
          end
          $ 303 "Call Move_done"
          Move_done()
        end
      end
      $ 304 "Call robotand_cell_initalizat"
      robotand_cell_initalizat()
    else:
      $ 305 "ElseIf a0_Job_Mode≟2"
      global thread_flag_305=0
      thread Thread_if_305():
        $ 306 "'JOB_AUTO'"
        # 'JOB_AUTO'
        $ 307 "auto_on≔ True "
        global auto_on=  True  
        $ 308 "Init"
        $ 309 "If freedrive_trg"
        if (freedrive_trg):
          $ 310 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 311 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
        $ 312 "write_port_register(202,0)"
        write_port_register(202,0)
        $ 313 "write_port_register(robot_ready_141,0)"
        write_port_register(robot_ready_141,0)
        $ 314 "homeing()"
        homeing()
        $ 315 "Wait: 0.2"
        sleep(0.2)
        $ 316 "Cell_calculation"
        $ 317 "'setting'"
        # 'setting'
        $ 318 "Auto_trig≔ False "
        global Auto_trig=  False  
        $ 319 "If Auto_trig≟ False "
        if (Auto_trig ==   False  ):
          $ 320 "If simulation_mode"
          if (simulation_mode):
            $ 321 "b1_cell_info_L≔B"
            global b1_cell_info_L=B
            $ 322 "b1_cell_info_R≔B"
            global b1_cell_info_R=B
            $ 323 "b1_cell_select≔motion_num([A_VL1,A_VR1,A_HOR,0,0,0])"
            global b1_cell_select=motion_num([A_VL1,A_VR1,A_HOR,0,0,0])
            $ 324 "b1_cell_select≔motion_num([A_HOR,0,0,0,0,0])"
            global b1_cell_select=motion_num([A_HOR,0,0,0,0,0])
            $ 325 "EXT_flag1≔integer_to_binary_list(read_port_register(2048))"
            global EXT_flag1= integer_to_binary_list ( read_port_register (2048))
            $ 326 "b1_cell_thickne≔6"
            global b1_cell_thickne=6
            $ 327 "A_Touch_trig_l≔touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)"
            global A_Touch_trig_l=touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)
            $ 328 "Auto_W_num≔cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)"
            global Auto_W_num=cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)
            $ 330 "Auto_total_cell≔cell_num(Auto_W_num)"
            global Auto_total_cell=cell_num(Auto_W_num)
            $ 331 "Auto_trig≔ True "
            global Auto_trig=  True  
            $ 332 "A_sel_v≔Auto_W_num[0]"
            global A_sel_v=Auto_W_num[0]
          else:
            $ 333 "Else" "noBreak"
            $ 334 "b1_cell_info_L≔read_port_register(171)"
            global b1_cell_info_L= read_port_register (171)
            $ 335 "b1_cell_info_R≔read_port_register(172)"
            global b1_cell_info_R= read_port_register (172)
            $ 336 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
            global EXT_flag1= integer_to_binary_list ( read_port_register (179))
            $ 337 "b1_cell_select≔read_port_register(178)"
            global b1_cell_select= read_port_register (178)
            $ 338 "b1_cell_thickne≔read_port_register(183)"
            global b1_cell_thickne= read_port_register (183)
            $ 339 "A_Touch_trig_l≔touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)"
            global A_Touch_trig_l=touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)
            $ 340 "Auto_W_num≔cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)"
            global Auto_W_num=cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)
            $ 341 "Auto_total_cell≔cell_num(Auto_W_num)"
            global Auto_total_cell=cell_num(Auto_W_num)
            $ 342 "Auto_trig≔ True "
            global Auto_trig=  True  
            $ 343 "A_sel_v≔Auto_W_num[0]"
            global A_sel_v=Auto_W_num[0]
          end
          $ 344 "write_port_register(139,Auto_total_cell-1)"
          write_port_register(139,Auto_total_cell-1)
        end
        $ 345 "Auto_cur_cell≔0"
        global Auto_cur_cell=0
        $ 346 "Touch,Welding"
        $ 347 "'Calculate total sequence and decide way'"
        # 'Calculate total sequence and decide way'
        $ 348 "Calculate & Move & Touch"
        $ 349 "touch_init"
        $ 350 "Call cell_info"
        cell_info()
        $ 351 "If simulation_mode"
        if (simulation_mode):
          $ 352 "Call welding_parameter_sim"
          welding_parameter_sim()
        else:
          $ 353 "Else" "noBreak"
          $ 354 "Call welding_parameter_init"
          welding_parameter_init()
          $ 355 "touch_temp≔read_port_register(180)"
          global touch_temp= read_port_register (180)
          $ 356 "A_cur_2f≔0"
          global A_cur_2f=0
          $ 357 "wv_direction≔1"
          global wv_direction=1
        end
        $ 358 "If touch_temp≟0"
        if (touch_temp == 0):
          $ 359 "reset Variable"
          $ 360 "A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]"
          A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]
          $ 361 "A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]"
          A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]
          $ 362 "reset_par"
          $ 363 "for_cal_rot≔p[0,0,0,0,0,0]"
          global for_cal_rot=p[0,0,0,0,0,0]
          $ 364 "for_cal_zr≔p[0,0,0,0,0,0]"
          global for_cal_zr=p[0,0,0,0,0,0]
          $ 365 "for_z_VLR2≔p[0,0,0,0,0,0]"
          global for_z_VLR2=p[0,0,0,0,0,0]
          $ 366 "for_cal_x_wel≔p[0,0,0,0,0,0]"
          global for_cal_x_wel=p[0,0,0,0,0,0]
          $ 367 "for_cal_xy≔p[0,0,0,0,0,0]"
          global for_cal_xy=p[0,0,0,0,0,0]
          $ 368 "for_cal_y_wel≔p[0,0,0,0,0,0]"
          global for_cal_y_wel=p[0,0,0,0,0,0]
          $ 369 "for_x_HOR≔p[0,0,0,0,0,0]"
          global for_x_HOR=p[0,0,0,0,0,0]
          $ 370 "for_x_HOR_R≔p[0,0,0,0,0,0]"
          global for_x_HOR_R=p[0,0,0,0,0,0]
          $ 371 "for_z_VL1≔p[0,0,0,0,0,0]"
          global for_z_VL1=p[0,0,0,0,0,0]
          $ 372 "for_z_VR1≔p[0,0,0,0,0,0]"
          global for_z_VR1=p[0,0,0,0,0,0]
        end
        $ 373 "write_port_register(143,0)"
        write_port_register(143,0)
        $ 374 "write_port_register(144,0)"
        write_port_register(144,0)
        $ 375 "timer_1: Reset"
        timer_1 = 0
        $ 376 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
        global EXT_flag1= integer_to_binary_list ( read_port_register (179))
        $ 378 "If touch_temp≟0"
        if (touch_temp == 0):
          $ 379 "write_port_register(138,0)"
          write_port_register(138,0)
          $ 380 "get_touch_position"
          $ 381 "get pre-positions"
          $ 382 "If read_port_register(work_type_165)≟2"
          if ( read_port_register (work_type_165) == 2):
            $ 383 "freedrive touch"
            $ 384 "move_i≔1"
            global move_i=1
            $ 385 "Loop move_i<9"
            while (move_i<9):
              $ 386 "Wait: 0.1"
              sleep(0.1)
              $ 387 "Wait save_tool=LO"
              while (get_tool_digital_in(0) == True):
                sync()
              end
              $ 388 "If A_Touch_trig_l[move_i]≟ True "
              if (A_Touch_trig_l[move_i] ==   True  ):
                $ 389 "If move_i≟A_HOR"
                if (move_i == A_HOR):
                  $ 390 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                  if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                    $ 391 "write_port_register(touch_cell_155,5)"
                    write_port_register(touch_cell_155,5)
                    $ 392 "write_port_register(touch_num_156,1)"
                    write_port_register(touch_num_156,1)
                    $ 393 "Call touch_sub"
                    touch_sub()
                    $ 394 "g_cp≔get_actual_tcp_pose()"
                    global g_cp= get_actual_tcp_pose ()
                    $ 395 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                    if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                      $ 396 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                      g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                    end
                    $ 397 "A_Prepos_l[move_i]=g_cp"
                    A_Prepos_l[move_i]=g_cp
                  end
                else:
                  $ 398 "ElseIf move_i≟A_HOR_ML"
                  if (move_i == A_HOR_ML):
                    $ 399 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                    if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                      $ 400 "write_port_register(touch_cell_155,5)"
                      write_port_register(touch_cell_155,5)
                      $ 401 "write_port_register(touch_num_156,3)"
                      write_port_register(touch_num_156,3)
                      $ 402 "Call touch_sub"
                      touch_sub()
                      $ 403 "g_cp≔get_actual_tcp_pose()"
                      global g_cp= get_actual_tcp_pose ()
                      $ 404 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                      if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                        $ 405 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                        g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                      end
                      $ 406 "A_Prepos_l[move_i]=g_cp"
                      A_Prepos_l[move_i]=g_cp
                    end
                  else:
                    $ 407 "ElseIf move_i≟A_HOR_R"
                    if (move_i == A_HOR_R):
                      $ 408 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                      if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                        $ 409 "write_port_register(touch_cell_155,5)"
                        write_port_register(touch_cell_155,5)
                        $ 410 "write_port_register(touch_num_156,2)"
                        write_port_register(touch_num_156,2)
                        $ 411 "Call touch_sub"
                        touch_sub()
                        $ 412 "g_cp≔get_actual_tcp_pose()"
                        global g_cp= get_actual_tcp_pose ()
                        $ 413 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                        if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                          $ 414 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                          g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                        end
                        $ 415 "A_Prepos_l[move_i]=g_cp"
                        A_Prepos_l[move_i]=g_cp
                      end
                    else:
                      $ 416 "ElseIf move_i≟A_HOR_MR"
                      if (move_i == A_HOR_MR):
                        $ 417 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                        if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                          $ 418 "write_port_register(touch_cell_155,5)"
                          write_port_register(touch_cell_155,5)
                          $ 419 "write_port_register(touch_num_156,4)"
                          write_port_register(touch_num_156,4)
                          $ 420 "Call touch_sub"
                          touch_sub()
                          $ 421 "g_cp≔get_actual_tcp_pose()"
                          global g_cp= get_actual_tcp_pose ()
                          $ 422 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                          if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                            $ 423 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                            g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                          end
                          $ 424 "A_Prepos_l[move_i]=g_cp"
                          A_Prepos_l[move_i]=g_cp
                        end
                      else:
                        $ 425 "Else" "noBreak"
                        $ 426 "write_port_register(touch_cell_155,move_i)"
                        write_port_register(touch_cell_155,move_i)
                        $ 427 "write_port_register(touch_num_156,1)"
                        write_port_register(touch_num_156,1)
                        $ 428 "Call touch_sub"
                        touch_sub()
                        $ 429 "A_Prepos_l[move_i]=get_actual_tcp_pose()"
                        A_Prepos_l[move_i]= get_actual_tcp_pose ()
                        $ 430 "If move_i≤4"
                        if (move_i <= 4):
                          $ 431 "write_port_register(touch_cell_155,move_i)"
                          write_port_register(touch_cell_155,move_i)
                          $ 432 "write_port_register(touch_num_156,2)"
                          write_port_register(touch_num_156,2)
                          $ 433 "Wait: 0.1"
                          sleep(0.1)
                          $ 434 "Call touch_sub"
                          touch_sub()
                          $ 435 "A_Prepos_l[move_i+9]=get_actual_tcp_pose()"
                          A_Prepos_l[move_i+9]= get_actual_tcp_pose ()
                        end
                      end
                    end
                  end
                end
              else:
                $ 436 "Else" "noBreak"
                $ 437 "A_Prepos_l[move_i]=p[0,0,0,0,0,0]"
                A_Prepos_l[move_i]=p[0,0,0,0,0,0]
                $ 438 "If move_i≤4"
                if (move_i <= 4):
                  $ 439 "A_Prepos_l[move_i+7]=p[0,0,0,0,0,0]"
                  A_Prepos_l[move_i+7]=p[0,0,0,0,0,0]
                else:
                  $ 440 "ElseIf move_i≟A_HOR"
                  if (move_i == A_HOR):
                    $ 441 "A_Prepos_l[A_HOR_ML]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_ML]=p[0,0,0,0,0,0]
                    $ 442 "A_Prepos_l[A_HOR_MR]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_MR]=p[0,0,0,0,0,0]
                    $ 443 "A_Prepos_l[A_HOR_M]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_M]=p[0,0,0,0,0,0]
                    $ 444 "A_Prepos_l[A_HOR_R]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_R]=p[0,0,0,0,0,0]
                  end
                end
              end
              $ 445 "move_i≔move_i+1"
              global move_i=move_i+1
            end
            $ 446 "change deg"
            $ 447 "move_i≔1"
            global move_i=1
            $ 448 "Loop move_i<14"
            while (move_i<14):
              $ 449 "If A_Prepos_l[move_i]≠p[0,0,0,0,0,0]"
              if (A_Prepos_l[move_i] != p[0,0,0,0,0,0]):
                $ 450 "If move_i≟A_VL1 or move_i≟A_VL2 or move_i≟A_VL1_END or move_i≟A_VL2_END"
                if (move_i == A_VL1  or  move_i == A_VL2  or  move_i == A_VL1_END  or  move_i == A_VL2_END):
                  $ 451 "b2_left_par≔ True "
                  global b2_left_par=  True  
                  $ 452 "b8_wv_2f≔ False "
                  global b8_wv_2f=  False  
                  $ 453 "get_pos≔A_Prepos_l[move_i]"
                  global get_pos=A_Prepos_l[move_i]
                  $ 454 "get_org≔left"
                  global get_org=p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605]
                  $ 455 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                  global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                  $ 456 "pre_tp≔tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])"
                  global pre_tp=tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])
                else:
                  $ 457 "ElseIf move_i≟A_VR1 or move_i≟A_VR2 or move_i≟A_VR1_END or move_i≟A_VR2_END"
                  if (move_i == A_VR1  or  move_i == A_VR2  or  move_i == A_VR1_END  or  move_i == A_VR2_END):
                    $ 458 "b2_left_par≔ False "
                    global b2_left_par=  False  
                    $ 459 "b8_wv_2f≔ False "
                    global b8_wv_2f=  False  
                    $ 460 "get_pos≔A_Prepos_l[move_i]"
                    global get_pos=A_Prepos_l[move_i]
                    $ 461 "get_org≔right"
                    global get_org=p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292]
                    $ 462 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                    global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                    $ 463 "pre_tp≔tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])"
                    global pre_tp=tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])
                  else:
                    $ 464 "ElseIf move_i≟A_HOR or move_i≟A_HOR_ML"
                    if (move_i == A_HOR  or  move_i == A_HOR_ML):
                      $ 465 "b8_wv_2f≔ True "
                      global b8_wv_2f=  True  
                      $ 466 "b2_left_par≔ True "
                      global b2_left_par=  True  
                      $ 467 "get_pos≔A_Prepos_l[move_i]"
                      global get_pos=A_Prepos_l[move_i]
                      $ 468 "get_org≔up_left"
                      global get_org=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                      $ 469 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                      global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                      $ 470 "pre_tp≔tilt_2f_fun(get_pos,[0,0], True , True )"
                      global pre_tp=tilt_2f_fun(get_pos,[0,0],  True  ,  True  )
                    else:
                      $ 471 "ElseIf move_i≟A_HOR_R or move_i≟A_HOR_MR"
                      if (move_i == A_HOR_R  or  move_i == A_HOR_MR):
                        $ 472 "b8_wv_2f≔ True "
                        global b8_wv_2f=  True  
                        $ 473 "b2_left_par≔ False "
                        global b2_left_par=  False  
                        $ 474 "get_pos≔A_Prepos_l[move_i]"
                        global get_pos=A_Prepos_l[move_i]
                        $ 475 "get_org≔up_right"
                        global get_org=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                        $ 476 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                        global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                        $ 477 "pre_tp≔tilt_2f_fun(get_pos,[0,0], False , True )"
                        global pre_tp=tilt_2f_fun(get_pos,[0,0],  False  ,  True  )
                      end
                    end
                  end
                end
                $ 478 "A_Prepos_l[move_i]=pre_tp"
                A_Prepos_l[move_i]=pre_tp
              end
              $ 479 "move_i≔move_i+1"
              global move_i=move_i+1
            end
            $ 480 "homeing()"
            homeing()
            $ 481 "Wait read_port_register(170)≟1"
            while (not( read_port_register (170) == 1)):
              sync()
            end
            $ 482 "write_port_register(170,0)"
            write_port_register(170,0)
          else:
            $ 483 "Else" "noBreak"
            $ 484 "value from pendant"
            $ 485 "move_i≔1"
            global move_i=1
            $ 487 "Touch_FrontandSide"
            $ 488 "If EXT_flag1[11]≟ True "
            if (EXT_flag1[11] ==   True  ):
              $ 489 "Touch front and side_Right"
              $ 490 "move_center≔pose_add(first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])"
              global move_center= pose_add (first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])
              $ 491 "get_pose_side_t≔0"
              global get_pose_side_t=0
              $ 493 "move_center[2]=(center_height+a7_cell_bottom)/1000"
              move_center[2]=(center_height+a7_cell_bottom)/1000
              $ 495 "MoveL"
              $ 496 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 497 "touch_center≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 498 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 499 "get_center≔touch_center[0]*1000"
              global get_center=touch_center[0]*1000
              $ 500 "a7_f_distance≔get_center"
              global a7_f_distance=get_center
              $ 501 "move_center≔pose_add(move_center,p[0,sec_touch_dis/1000,0,0,0,0])"
              global move_center= pose_add (move_center,p[0,sec_touch_dis/1000,0,0,0,0])
              $ 502 "move_center[0]=touch_center[0]-20/1000"
              move_center[0]=touch_center[0]-20/1000
              $ 503 "MoveL"
              $ 504 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 505 "touch_center2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 506 "center_line≔get_feature_Line(touch_center,touch_center2)"
              global center_line=get_feature_Line(touch_center,touch_center2)
              $ 507 "event_cal_on≔ True "
              global event_cal_on=  True  
              $ 508 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 510 "homeing()"
              homeing()
              $ 511 "b2_left_par≔ False "
              global b2_left_par=  False  
              $ 512 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 513 "b2_cell≔b1_cell_info_R"
              global b2_cell=b1_cell_info_R
              $ 514 "get_pos≔get_lr(side_p_R,a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line, True )"
              global get_pos=get_lr(p[.471584857321, -.427242166643, .026448165242, 1.806736638758, -1.227818761912, 1.383474453522],a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line,  True  )
              $ 516 "pre_tp≔get_pos"
              global pre_tp=get_pos
              $ 517 "pre_tp≔pose_add(pre_tp, p[side_pos_x/1000,0,0,0,0,0])"
              global pre_tp= pose_add (pre_tp, p[side_pos_x/1000,0,0,0,0,0])
              $ 518 "pre_tp[2]=(center_height+a7_cell_bottom)/1000"
              pre_tp[2]=(center_height+a7_cell_bottom)/1000
              $ 519 "MoveL"
              $ 520 "pre_tp" "breakAfter"
              movel(pose_trans(Base, pre_tp), a=0.8, v=0.4)
              $ 521 "touch_side≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,13,13)"
              global touch_side=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,13,13)
              $ 522 "touch_side≔get_feature_pose(touch_side,center_line)"
              global touch_side=get_feature_pose(touch_side,center_line)
              $ 523 "direction(p[0,0,0,0,0,0],[0,1,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[0,1,0],10,180,200)
              $ 524 "write_welder(4, False )"
              write_welder(4,  False  )
              $ 525 "get_pose_side_t≔touch_side[1]*1000"
              global get_pose_side_t=touch_side[1]*1000
              $ 526 "get_pose_side_t≔get_pose_side_t+(a6_f_width/2)"
              global get_pose_side_t=get_pose_side_t+(a6_f_width/2)
              $ 527 "event_side_on≔ True "
              global event_side_on=  True  
              $ 528 "MoveL"
              $ 529 "Direction: Base"
              global move_thread_flag_529=0
              thread move_thread_529():
                enter_critical
                move_thread_flag_529 = 1
                local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,1,0], 0.03)
                movel(towardsPos, a=0.3, v=0.15)
                move_thread_flag_529 = 2
                exit_critical
              end
              move_thread_flag_529 = 0
              move_thread_han_529 = run move_thread_529()
              while (True):
                sleep(1.0E-10)
                if (move_thread_flag_529 > 1):
                  join move_thread_han_529
                  $ 530 "Until (distance)"
                  break
                end
                sync()
              end
              $ 531 "homeing()"
              homeing()
            else:
              $ 532 "Else" "noBreak"
              $ 533 "Touch front and side_Left"
              $ 534 "move_center≔pose_add(first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])"
              global move_center= pose_add (first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])
              $ 535 "get_pose_side_t≔0"
              global get_pose_side_t=0
              $ 537 "move_center[2]=(center_height+a7_cell_bottom)/1000"
              move_center[2]=(center_height+a7_cell_bottom)/1000
              $ 539 "MoveL"
              $ 540 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 541 "touch_center≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 542 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 543 "get_center≔touch_center[0]*1000"
              global get_center=touch_center[0]*1000
              $ 544 "a7_f_distance≔get_center"
              global a7_f_distance=get_center
              $ 545 "move_center≔pose_add(move_center,p[0,sec_touch_dis/1000,0,0,0,0])"
              global move_center= pose_add (move_center,p[0,sec_touch_dis/1000,0,0,0,0])
              $ 546 "move_center[0]=touch_center[0]-20/1000"
              move_center[0]=touch_center[0]-20/1000
              $ 547 "MoveL"
              $ 548 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 549 "touch_center2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 550 "center_line≔get_feature_Line(touch_center,touch_center2)"
              global center_line=get_feature_Line(touch_center,touch_center2)
              $ 551 "event_cal_on≔ True "
              global event_cal_on=  True  
              $ 552 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 554 "homeing()"
              homeing()
              $ 555 "b2_left_par≔ True "
              global b2_left_par=  True  
              $ 556 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 557 "b2_cell≔b1_cell_info_L"
              global b2_cell=b1_cell_info_L
              $ 558 "get_pos≔get_lr(side_p_L,a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line, True )"
              global get_pos=get_lr(p[.411215372122, .375785944375, -.010176539343, -1.953488355698, -1.125710367676, -1.228829273458],a6_f_width,[35,0,0,0,0],a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,get_pose_side_t,30,0,center_line,  True  )
              $ 560 "pre_tp≔get_pos"
              global pre_tp=get_pos
              $ 561 "pre_tp≔pose_add(pre_tp, p[side_pos_x/1000,0,0,0,0,0])"
              global pre_tp= pose_add (pre_tp, p[side_pos_x/1000,0,0,0,0,0])
              $ 562 "pre_tp[2]=(center_height+a7_cell_bottom)/1000"
              pre_tp[2]=(center_height+a7_cell_bottom)/1000
              $ 563 "MoveL"
              $ 564 "pre_tp" "breakAfter"
              movel(pose_trans(Base, pre_tp), a=0.8, v=0.4)
              $ 565 "touch_side≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,13,13)"
              global touch_side=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,13,13)
              $ 566 "touch_side≔get_feature_pose(touch_side,center_line)"
              global touch_side=get_feature_pose(touch_side,center_line)
              $ 567 "direction(p[0,0,0,0,0,0],[0,-1,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[0,-1,0],10,180,200)
              $ 568 "write_welder(4, False )"
              write_welder(4,  False  )
              $ 569 "get_pose_side_t≔touch_side[1]*1000"
              global get_pose_side_t=touch_side[1]*1000
              $ 570 "get_pose_side_t≔get_pose_side_t-(a6_f_width/2)"
              global get_pose_side_t=get_pose_side_t-(a6_f_width/2)
              $ 571 "event_side_on≔ True "
              global event_side_on=  True  
              $ 572 "MoveL"
              $ 573 "Direction: Base"
              global move_thread_flag_573=0
              thread move_thread_573():
                enter_critical
                move_thread_flag_573 = 1
                local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1,0], 0.03)
                movel(towardsPos, a=0.3, v=0.15)
                move_thread_flag_573 = 2
                exit_critical
              end
              move_thread_flag_573 = 0
              move_thread_han_573 = run move_thread_573()
              while (True):
                sleep(1.0E-10)
                if (move_thread_flag_573 > 1):
                  join move_thread_han_573
                  $ 574 "Until (distance)"
                  break
                end
                sync()
              end
              $ 575 "homeing()"
              homeing()
            end
            $ 577 "Wait event_side_on≟ False "
            while (not(event_side_on ==   False  )):
              sync()
            end
          end
          $ 578 "move and touch"
          $ 579 "Touch Move"
          $ 580 "HOR_L"
          $ 581 "If A_Prepos_l[A_HOR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR] != p[0,0,0,0,0,0]):
            $ 582 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 583 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 584 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 585 "A_sel_v≔A_HOR"
            global A_sel_v=A_HOR
            $ 586 "wv_direction≔1"
            global wv_direction=1
            $ 587 "Call MoveandTouchFun_2f"
            MoveandTouchFun_2f()
            $ 588 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 589 "If A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                $ 591 "g_tp≔A_Prepos_l[A_HOR]"
                global g_tp=A_Prepos_l[A_HOR]
                $ 594 "Folder"
                $ 595 "g_cp≔get_actual_tcp_pose()"
                global g_cp= get_actual_tcp_pose ()
                $ 596 "g_cp≔pose_trans(g_cp, p[0,0,0,d2r(12),d2r(5),0])"
                global g_cp= pose_trans (g_cp, p[0,0,0,d2r(12),d2r(5),0])
                $ 597 "MoveL"
                $ 598 "g_cp" "breakAfter"
                movel(pose_trans(Base, g_cp), a=0.08, v=0.08)
                $ 599 "for_x_HOR≔contact_fun(A_Touch_p[A_sel_v],[-1*wv_direction,0,0],10000,15,15,  False)"
                global for_x_HOR=contact_fun(A_Touch_p[A_sel_v],[-1*wv_direction,0,0],10000,15,15,  False)
                $ 600 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
                $ 601 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 602 "Else" "noBreak"
                $ 603 "for_x_HOR≔p[0,0,0,0,0,0]"
                global for_x_HOR=p[0,0,0,0,0,0]
              end
            end
            $ 611 "If point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032"
            if (point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032):
              $ 612 "homeing()"
              homeing()
            end
          end
          $ 613 "VL1"
          $ 614 "If A_Prepos_l[A_VL1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL1] != p[0,0,0,0,0,0]):
            $ 615 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 616 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 617 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 618 "A_sel_v≔A_VL1"
            global A_sel_v=A_VL1
            $ 619 "A_sel_v_end≔A_VL1_END"
            global A_sel_v_end=A_VL1_END
            $ 620 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 621 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 622 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 623 "Else" "noBreak"
              $ 624 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 625 "Call MoveandTouchFun_3f"
            MoveandTouchFun_3f()
            $ 626 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 627 "If A_Prepos_l[A_HOR]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_HOR] == p[0,0,0,0,0,0]):
                $ 628 "direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)
                $ 630 "AAgcp≔get_actual_tcp_pose()"
                global AAgcp= get_actual_tcp_pose ()
                $ 631 "AAgangle≔up_left"
                global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                $ 632 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                $ 633 "MoveL"
                $ 634 "AAgtp" "breakAfter"
                movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                $ 636 "for_z_VL1≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)"
                global for_z_VL1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)
                $ 637 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                $ 638 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 639 "Else" "noBreak"
                $ 640 "for_z_VL1≔p[0,0,0,0,0,0]"
                global for_z_VL1=p[0,0,0,0,0,0]
              end
            end
          end
          $ 641 "HOR_ML"
          $ 642 "If A_Prepos_l[A_HOR_ML]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_ML] != p[0,0,0,0,0,0]):
            $ 643 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 644 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 645 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 646 "A_sel_v≔A_HOR_ML"
            global A_sel_v=A_HOR_ML
            $ 647 "If b1_cell_info_L≟C or b1_cell_info_L≟D"
            if (b1_cell_info_L == C  or  b1_cell_info_L == D):
              $ 648 "wv_direction≔1"
              global wv_direction=1
              $ 649 "Call MoveFun"
              MoveFun()
              $ 650 "for_cal_xy≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_xy=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 651 "direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)
              $ 652 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
              $ 653 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
              $ 654 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
              $ 655 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
              $ 656 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 657 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 658 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 659 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
              $ 660 "for_cal_rot≔A_Touch_p[A_HOR]"
              global for_cal_rot=A_Touch_p[A_HOR]
              $ 661 "A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_z_VLR2[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
              A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_z_VLR2[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
              $ 662 "A_Touch_p[A_sel_v]=pose_trans(A_Touch_p[A_sel_v], p[Touch_dis/1000,0,0,0,0,0])"
              A_Touch_p[A_sel_v]= pose_trans (A_Touch_p[A_sel_v], p[Touch_dis/1000,0,0,0,0,0])
              $ 663 "write_welder(4, False )"
              write_welder(4,  False  )
            else:
              $ 664 "Else" "noBreak"
              $ 665 "wv_direction≔1"
              global wv_direction=1
              $ 666 "for_cal_rot≔A_Touch_p[A_HOR]"
              global for_cal_rot=A_Touch_p[A_HOR]
              $ 667 "Call MoveFun_cd"
              MoveFun_cd()
              $ 668 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 669 "for_cal_y_wel[2]=for_cal_rot[2]"
              for_cal_y_wel[2]=for_cal_rot[2]
              $ 670 "dir_x_cal≔get_feature_Line(for_cal_rot,for_cal_y_wel)"
              global dir_x_cal=get_feature_Line(for_cal_rot,for_cal_y_wel)
              $ 671 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              $ 672 "direction(p[0,0,0,0,0,0],[0,-1,0],80,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],80,120,160)
              $ 673 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 674 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
              $ 675 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
              $ 676 "direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)
              $ 677 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
              $ 678 "get_ml≔get_feature_pose(for_cal_x_wel,for_cal_rot)"
              global get_ml=get_feature_pose(for_cal_x_wel,for_cal_rot)
              $ 680 "A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)"
              A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)
              $ 681 "direction(p[0,0,0,0,0,0],[0,1,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],5,120,160)
              $ 682 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 683 "write_welder(4, False )"
              write_welder(4,  False  )
            end
            $ 684 "homeing()"
            homeing()
          else:
            $ 685 "Else" "noBreak"
            $ 686 "homeing()"
            homeing()
          end
          $ 687 "VL2"
          $ 688 "If A_Prepos_l[A_VL2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL2] != p[0,0,0,0,0,0]):
            $ 689 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 690 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 691 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 692 "A_sel_v≔A_VL2"
            global A_sel_v=A_VL2
            $ 693 "A_sel_v_end≔A_VL2_END"
            global A_sel_v_end=A_VL2_END
            $ 694 "b2_par_cd≔1"
            global b2_par_cd=1
            $ 695 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 696 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 697 "Else" "noBreak"
              $ 698 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 699 "If b1_cell_info_L≟d or b1_cell_info_L≟c"
            if (b1_cell_info_L == d  or  b1_cell_info_L == c):
              $ 700 "Halt"
              halt
            else:
              $ 701 "Else" "noBreak"
              $ 702 "If A_Touch_p[A_VL1]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_VL1] == p[0,0,0,0,0,0]):
                $ 703 "Call MoveandTouchFun_3f"
                MoveandTouchFun_3f()
                $ 704 "If A_Prepos_l[A_HOR_ML]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_ML] == p[0,0,0,0,0,0]):
                  $ 705 "direction(p[0,0,0,0,0,0],[-1,-1,0],8,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,-1,0],8,120,160)
                  $ 706 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 707 "AAgangle≔up_left"
                  global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                  $ 708 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 709 "MoveL"
                  $ 710 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 712 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 713 "direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)"
                  direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)
                end
                $ 714 "touch_tmp≔A_Touch_p[A_sel_v]"
                global touch_tmp=A_Touch_p[A_sel_v]
                $ 715 "touch_tmp[2]=for_z_VLR2[2]"
                touch_tmp[2]=for_z_VLR2[2]
                $ 716 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 717 "for_cal_y_wel≔A_Touch_p[A_sel_v]"
                global for_cal_y_wel=A_Touch_p[A_sel_v]
                $ 718 "for_cal_x_wel≔A_Touch_p[A_sel_v]"
                global for_cal_x_wel=A_Touch_p[A_sel_v]
              else:
                $ 719 "Else" "noBreak"
                $ 720 "If A_Prepos_l[A_HOR_ML]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_ML] == p[0,0,0,0,0,0]):
                  $ 721 "Call MoveFun"
                  MoveFun()
                  $ 722 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 723 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
                  $ 724 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
                  $ 725 "var_2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global var_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 726 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
                  $ 727 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
                  $ 728 "direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)"
                  direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)
                  $ 729 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                  global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                  $ 730 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
                  $ 731 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 732 "AAgangle≔up_left"
                  global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                  $ 733 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 734 "MoveL"
                  $ 735 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 737 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 738 "direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)"
                  direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)
                  $ 739 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                end
                $ 740 "for_cal_rot≔A_Touch_p[A_VL1]"
                global for_cal_rot=A_Touch_p[A_VL1]
                $ 741 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                $ 742 "If Scallup_check≟ False "
                if (Scallup_check ==   False  ):
                  $ 743 "touch_tmp≔pose_trans(touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])"
                  global touch_tmp= pose_trans (touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])
                else:
                  $ 744 "Else" "noBreak"
                  $ 745 "Scallup_check≔ False "
                  global Scallup_check=  False  
                end
                $ 746 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 747 "write_welder(4, False )"
                write_welder(4,  False  )
              end
            end
            $ 748 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 749 "homeing()"
            homeing()
          else:
            $ 750 "Else" "noBreak"
            $ 751 "homeing()"
            homeing()
          end
          $ 752 "HOR_R"
          $ 753 "If A_Prepos_l[A_HOR_R]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_R] != p[0,0,0,0,0,0]):
            $ 754 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 755 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 756 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 757 "A_sel_v≔A_HOR_R"
            global A_sel_v=A_HOR_R
            $ 758 "wv_direction≔-1"
            global wv_direction=-1
            $ 759 "Call MoveandTouchFun_2f"
            MoveandTouchFun_2f()
            $ 761 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 762 "If A_Prepos_l[A_VR1]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VR1] == p[0,0,0,0,0,0]):
                $ 764 "g_tp≔A_Prepos_l[A_HOR_R]"
                global g_tp=A_Prepos_l[A_HOR_R]
                $ 765 "Folder"
                $ 766 "g_cp≔get_actual_tcp_pose()"
                global g_cp= get_actual_tcp_pose ()
                $ 767 "g_cp≔pose_trans(g_cp, p[0,0,0,d2r(-12),d2r(5),0])"
                global g_cp= pose_trans (g_cp, p[0,0,0,d2r(-12),d2r(5),0])
                $ 768 "MoveL"
                $ 769 "g_cp" "breakAfter"
                movel(pose_trans(Base, g_cp), a=0.08, v=0.08)
                $ 772 "for_x_HOR_R≔contact_fun(A_Touch_p[A_HOR_R],[-1*wv_direction,0,0],10000,15,15,  False)"
                global for_x_HOR_R=contact_fun(A_Touch_p[A_HOR_R],[-1*wv_direction,0,0],10000,15,15,  False)
                $ 773 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                $ 774 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 775 "Else" "noBreak"
                $ 776 "for_x_HOR_R≔p[0,0,0,0,0,0]"
                global for_x_HOR_R=p[0,0,0,0,0,0]
              end
            end
            $ 777 "wv_direction≔1"
            global wv_direction=1
            $ 778 "If point_dist(A_Prepos_l[A_HOR_R], A_Prepos_l[A_VR1])>0.0327"
            if (point_dist(A_Prepos_l[A_HOR_R], A_Prepos_l[A_VR1])>0.0327):
              $ 779 "homeing()"
              homeing()
            end
          end
          $ 780 "VR1"
          $ 781 "If A_Prepos_l[A_VR1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR1] != p[0,0,0,0,0,0]):
            $ 782 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 783 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 784 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 785 "A_sel_v≔A_VR1"
            global A_sel_v=A_VR1
            $ 786 "A_sel_v_end≔A_VR1_END"
            global A_sel_v_end=A_VR1_END
            $ 787 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 788 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 789 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 790 "Else" "noBreak"
              $ 791 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 792 "Call MoveandTouchFun_3f"
            MoveandTouchFun_3f()
            $ 793 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 794 "If A_Prepos_l[A_HOR_R]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_HOR_R] == p[0,0,0,0,0,0]):
                $ 795 "direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)
                $ 796 "AAgcp≔get_actual_tcp_pose()"
                global AAgcp= get_actual_tcp_pose ()
                $ 797 "AAgangle≔up_right"
                global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                $ 798 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                $ 799 "MoveL"
                $ 800 "AAgtp" "breakAfter"
                movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                $ 802 "for_z_VR1≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)"
                global for_z_VR1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)
                $ 803 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                $ 804 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 805 "Else" "noBreak"
                $ 806 "for_z_VR1≔p[0,0,0,0,0,0]"
                global for_z_VR1=p[0,0,0,0,0,0]
              end
            end
          end
          $ 807 "HOR_MR"
          $ 808 "If A_Prepos_l[A_HOR_MR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_MR] != p[0,0,0,0,0,0]):
            $ 809 "INIT"
            $ 810 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 811 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 812 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 813 "A_sel_v≔A_HOR_MR"
            global A_sel_v=A_HOR_MR
            $ 814 "If b1_cell_info_R≟C or b1_cell_info_R≟D"
            if (b1_cell_info_R == C  or  b1_cell_info_R == D):
              $ 815 "wv_direction≔-1"
              global wv_direction=-1
              $ 816 "Call MoveFun_cd"
              MoveFun_cd()
              $ 817 "for_cal_xy≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_xy=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 818 "direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)
              $ 819 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
              $ 820 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
              $ 821 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
              $ 822 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
              $ 823 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 824 "direction(p[0,0,0,0,0,0],[-1,0,0],8,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],8,120,160)
              $ 825 "for_cal_zr≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global for_cal_zr=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 826 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
              $ 827 "for_cal_rot≔A_Touch_p[A_HOR_R]"
              global for_cal_rot=A_Touch_p[A_HOR_R]
              $ 828 "A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
              A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
              $ 829 "A_Touch_p[A_sel_v]=pose_trans(A_Touch_p[A_sel_v], p[-Touch_dis/1000,0,0,0,0,0])"
              A_Touch_p[A_sel_v]= pose_trans (A_Touch_p[A_sel_v], p[-Touch_dis/1000,0,0,0,0,0])
              $ 830 "write_welder(4, False )"
              write_welder(4,  False  )
            else:
              $ 831 "Else" "noBreak"
              $ 832 "wv_direction≔-1"
              global wv_direction=-1
              $ 833 "for_cal_rot≔A_Touch_p[A_HOR_R]"
              global for_cal_rot=A_Touch_p[A_HOR_R]
              $ 834 "Call MoveFun_cd"
              MoveFun_cd()
              $ 835 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 836 "vr2_p1≔for_cal_y_wel"
              global vr2_p1=for_cal_y_wel
              $ 837 "for_cal_y_wel[2]=for_cal_rot[2]"
              for_cal_y_wel[2]=for_cal_rot[2]
              $ 838 "dir_x_cal≔get_feature_Line(for_cal_rot,for_cal_y_wel)"
              global dir_x_cal=get_feature_Line(for_cal_rot,for_cal_y_wel)
              $ 839 "vr2_p2≔feature_offset(vr2_p1,p[0,0.02,0,0,0,0],dir_x_cal)"
              global vr2_p2=feature_offset(vr2_p1,p[0,0.02,0,0,0,0],dir_x_cal)
              $ 840 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              $ 841 "direction(p[0,0,0,0,0,0],[0,1,0],80,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],80,120,160)
              $ 842 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 843 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
              $ 844 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
              $ 845 "direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)
              $ 846 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
              $ 847 "vr2_p3≔for_cal_x_wel"
              global vr2_p3=for_cal_x_wel
              $ 848 "get_ml≔get_feature_pose(for_cal_x_wel,for_cal_rot)"
              global get_ml=get_feature_pose(for_cal_x_wel,for_cal_rot)
              $ 850 "A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,-get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)"
              A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,-get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)
              $ 851 "vr2_p4≔A_Touch_p[A_HOR_MR]"
              global vr2_p4=A_Touch_p[A_HOR_MR]
              $ 852 "direction(p[0,0,0,0,0,0],[0,-1,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],5,120,160)
              $ 853 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 854 "write_welder(4, False )"
              write_welder(4,  False  )
            end
            $ 855 "homeing()"
            homeing()
            $ 856 "wv_direction≔1"
            global wv_direction=1
          else:
            $ 857 "Else" "noBreak"
            $ 858 "homeing()"
            homeing()
          end
          $ 859 "VR2"
          $ 860 "If A_Prepos_l[A_VR2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR2] != p[0,0,0,0,0,0]):
            $ 861 "Init"
            $ 862 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 863 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 864 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 865 "A_sel_v≔A_VR2"
            global A_sel_v=A_VR2
            $ 866 "A_sel_v_end≔A_VR2_END"
            global A_sel_v_end=A_VR2_END
            $ 867 "b2_par_cd≔1"
            global b2_par_cd=1
            $ 868 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 869 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 870 "Else" "noBreak"
              $ 871 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 872 "If b1_cell_info_R≟d or b1_cell_info_R≟c"
            if (b1_cell_info_R == d  or  b1_cell_info_R == c):
              $ 873 "Halt"
              halt
              $ 874 "If vr2_p1≟p[0,0,0,0,0,0]"
              if (vr2_p1 == p[0,0,0,0,0,0]):
                $ 875 "Call MoveFun_cd"
                MoveFun_cd()
                $ 876 "vr2_p1≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p1=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 877 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 878 "direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)
                $ 879 "vr2_p2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 880 "direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)
                $ 881 "vr2_p3≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                global vr2_p3=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                $ 882 "direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)
                $ 883 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 884 "vr2_p4≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                global vr2_p4=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                $ 885 "direction(p[0,0,0,0,0,0],[0,0,1],40,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],40,120,160)
                $ 886 "A_Touch_p[A_sel_v]=touch_xyz_get_middle(vr2_p1,vr2_p2,vr2_p3,vr2_p4)"
                A_Touch_p[A_sel_v]=touch_xyz_get_middle(vr2_p1,vr2_p2,vr2_p3,vr2_p4)
                $ 887 "var_4≔A_Touch_p[A_sel_v]"
                global var_4=A_Touch_p[A_sel_v]
                $ 888 "var_4≔pose_trans(var_4, p[a6_callar_vert/1000,0,0,0,0,0])"
                global var_4= pose_trans (var_4, p[a6_callar_vert/1000,0,0,0,0,0])
                $ 889 "var_5≔get_actual_tcp_pose()"
                global var_5= get_actual_tcp_pose ()
                $ 890 "var_5[2]=var_4[2]"
                var_5[2]=var_4[2]
                $ 891 "var_5≔pose_trans(var_5, p[0,0,0,0,d2r(10),0])"
                global var_5= pose_trans (var_5, p[0,0,0,0,d2r(10),0])
                $ 892 "MoveL"
                $ 893 "var_5" "breakAfter"
                movel(pose_trans(Base, var_5), a=0.1, v=0.1)
                $ 894 "vr2_p1_up≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p1_up=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 895 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 896 "direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)
                $ 897 "vr2_p2_up≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p2_up=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 898 "direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)
                $ 899 "vr2_p3_up≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                global vr2_p3_up=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                $ 900 "direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)
                $ 901 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              end
              $ 902 "A_Touch_p[A_sel_v+9]=touch_4point(vr2_p1_up,vr2_p2_up,vr2_p3_up)"
              A_Touch_p[A_sel_v+9]=touch_4point(vr2_p1_up,vr2_p2_up,vr2_p3_up)
              $ 903 "A_Touch_p[A_sel_v+9]=ori_pose(A_Touch_p[A_sel_v+9],A_Touch_p[A_sel_v])"
              A_Touch_p[A_sel_v+9]=ori_pose(A_Touch_p[A_sel_v+9],A_Touch_p[A_sel_v])
            else:
              $ 904 "Else" "noBreak"
              $ 905 "If A_Touch_p[A_VR1]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_VR1] == p[0,0,0,0,0,0]):
                $ 906 "Call MoveandTouchFun_3f"
                MoveandTouchFun_3f()
                $ 907 "touch_tmp≔A_Touch_p[A_sel_v]"
                global touch_tmp=A_Touch_p[A_sel_v]
                $ 908 "If A_Prepos_l[A_HOR_MR]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_MR] == p[0,0,0,0,0,0]):
                  $ 909 "direction(p[0,0,0,0,0,0],[-1,1,0],8,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,1,0],8,120,160)
                  $ 910 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 911 "AAgangle≔up_right"
                  global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                  $ 912 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 913 "MoveL"
                  $ 914 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 916 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 917 "touch_tmp[2]=for_z_VLR2[2]"
                  touch_tmp[2]=for_z_VLR2[2]
                end
                $ 918 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 919 "for_cal_y_wel≔A_Touch_p[A_sel_v]"
                global for_cal_y_wel=A_Touch_p[A_sel_v]
                $ 920 "for_cal_x_wel≔A_Touch_p[A_sel_v]"
                global for_cal_x_wel=A_Touch_p[A_sel_v]
              else:
                $ 921 "Else" "noBreak"
                $ 922 "If A_Prepos_l[A_HOR_MR]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_MR] == p[0,0,0,0,0,0]):
                  $ 923 "Call MoveFun"
                  MoveFun()
                  $ 924 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 925 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
                  $ 926 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
                  $ 927 "var_2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global var_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 928 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
                  $ 929 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
                  $ 930 "direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)"
                  direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)
                  $ 931 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
                  global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
                  $ 932 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                  $ 933 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 934 "AAgangle≔up_right"
                  global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                  $ 935 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 936 "MoveL"
                  $ 937 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.1, v=0.1)
                  $ 939 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 940 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                  $ 941 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                end
                $ 942 "for_cal_rot≔A_Touch_p[A_VR1]"
                global for_cal_rot=A_Touch_p[A_VR1]
                $ 944 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                $ 945 "If Scallup_check≟ False "
                if (Scallup_check ==   False  ):
                  $ 946 "touch_tmp≔pose_trans(touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])"
                  global touch_tmp= pose_trans (touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])
                else:
                  $ 947 "Else" "noBreak"
                  $ 948 "Scallup_check≔ False "
                  global Scallup_check=  False  
                end
                $ 949 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 950 "write_welder(4, False )"
                write_welder(4,  False  )
              end
            end
            $ 951 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 952 "homeing()"
            homeing()
          else:
            $ 953 "Else" "noBreak"
            $ 954 "homeing()"
            homeing()
          end
          $ 955 "write_welder(4,False)"
          write_welder(4,False)
          $ 1012 "Touch After Offset"
          $ 1013 "touch_after_offset"
          $ 1014 "HOR"
          $ 1015 "If A_Prepos_l[A_HOR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR] != p[0,0,0,0,0,0]):
            $ 1016 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 1017 "If for_x_HOR≟p[0,0,0,0,0,0] and A_Touch_p[A_VL1]≠p[0,0,0,0,0,0]"
              if (for_x_HOR == p[0,0,0,0,0,0]  and  A_Touch_p[A_VL1] != p[0,0,0,0,0,0]):
                $ 1018 "for_x_HOR≔A_Touch_p[A_VL1]"
                global for_x_HOR=A_Touch_p[A_VL1]
              end
              $ 1019 "If for_x_HOR≠p[0,0,0,0,0,0]"
              if (for_x_HOR != p[0,0,0,0,0,0]):
                $ 1020 "x_diff≔get_feature_pose(for_x_HOR,A_Touch_p[A_HOR])"
                global x_diff=get_feature_pose(for_x_HOR,A_Touch_p[A_HOR])
                $ 1021 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[x_diff[0],0,0,0,0,0])"
                A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[x_diff[0],0,0,0,0,0])
                $ 1022 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or b1_cell_info_L≟E or b1_cell_info_L≟e"
                if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  b1_cell_info_L == E  or  b1_cell_info_L == e):
                  $ 1023 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[hor_l_scallup/1000,0,0,0,0,0])"
                  A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[hor_l_scallup/1000,0,0,0,0,0])
                end
              end
            end
            $ 1024 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[offset_2f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[offset_2f_begin/1000,0,0,0,0,0])
          end
          $ 1025 "VL1"
          $ 1026 "If A_Prepos_l[A_VL1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL1] != p[0,0,0,0,0,0]):
            $ 1027 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 1028 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1029 "If for_z_VL1≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR]≠p[0,0,0,0,0,0]"
              if (for_z_VL1 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR] != p[0,0,0,0,0,0]):
                $ 1030 "for_z_VL1≔A_Touch_p[A_HOR]"
                global for_z_VL1=A_Touch_p[A_HOR]
              end
              $ 1031 "Comment"
              # Comment
              $ 1032 "If for_z_VL1≠p[0,0,0,0,0,0]"
              if (for_z_VL1 != p[0,0,0,0,0,0]):
                $ 1033 "z_diff≔get_feature_pose(for_z_VL1,A_Touch_p[A_VL1])"
                global z_diff=get_feature_pose(for_z_VL1,A_Touch_p[A_VL1])
                $ 1034 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[z_diff[0],0,0,0,0,0])
              end
              $ 1035 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or b1_cell_info_L≟E or b1_cell_info_L≟e"
              if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  b1_cell_info_L == E  or  b1_cell_info_L == e):
                $ 1036 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[vert_scallup_l/1000,0,0,0,0,0])"
                A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[vert_scallup_l/1000,0,0,0,0,0])
              end
            end
            $ 1038 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1039 "VL2"
          $ 1040 "If A_Prepos_l[A_VL2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL2] != p[0,0,0,0,0,0]):
            $ 1041 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c or b1_cell_info_L≟D or b1_cell_info_L≟d or b1_cell_info_L≟E"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  b1_cell_info_L == E):
              $ 1042 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1043 "If for_z_VLR2≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR_ML]≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR_ML] != p[0,0,0,0,0,0]):
                $ 1044 "for_z_VLR2≔A_Touch_p[A_HOR_ML]"
                global for_z_VLR2=A_Touch_p[A_HOR_ML]
              end
              $ 1045 "Comment"
              # Comment
              $ 1046 "If for_z_VLR2≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 != p[0,0,0,0,0,0]):
                $ 1047 "z_diff≔get_feature_pose(for_z_VLR2,A_Touch_p[A_VL2])"
                global z_diff=get_feature_pose(for_z_VLR2,A_Touch_p[A_VL2])
                $ 1048 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[z_diff[0],0,0,0,0,0])
              end
              $ 1049 "If b1_cell_info_L≟E or b1_cell_info_L≟e"
              if (b1_cell_info_L == E  or  b1_cell_info_L == e):
                $ 1050 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[vert_scallup_l/1000,0,0,0,0,0])"
                A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[vert_scallup_l/1000,0,0,0,0,0])
              end
            end
            $ 1051 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1052 "HOR_R"
          $ 1053 "If A_Prepos_l[A_HOR_R]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_R] != p[0,0,0,0,0,0]):
            $ 1054 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 1055 "If for_x_HOR_R≟p[0,0,0,0,0,0] and A_Touch_p[A_VR1]≠p[0,0,0,0,0,0]"
              if (for_x_HOR_R == p[0,0,0,0,0,0]  and  A_Touch_p[A_VR1] != p[0,0,0,0,0,0]):
                $ 1056 "for_x_HOR_R≔A_Touch_p[A_VR1]"
                global for_x_HOR_R=A_Touch_p[A_VR1]
              end
              $ 1057 "If for_x_HOR≠p[0,0,0,0,0,0]"
              if (for_x_HOR != p[0,0,0,0,0,0]):
                $ 1058 "x_diff≔get_feature_pose(for_x_HOR_R,A_Touch_p[A_HOR_R])"
                global x_diff=get_feature_pose(for_x_HOR_R,A_Touch_p[A_HOR_R])
                $ 1059 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[x_diff[0],0,0,0,0,0])"
                A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[x_diff[0],0,0,0,0,0])
                $ 1060 "If b1_cell_info_R≟B or b1_cell_info_R≟D or b1_cell_info_R≟d or b1_cell_info_R≟E or b1_cell_info_R≟e"
                if (b1_cell_info_R == B  or  b1_cell_info_R == D  or  b1_cell_info_R == d  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
                  $ 1061 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[-hor_r_scallup/1000,0,0,0,0,0])"
                  A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[-hor_r_scallup/1000,0,0,0,0,0])
                end
              end
            end
            $ 1062 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[-offset_2f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[-offset_2f_begin/1000,0,0,0,0,0])
          end
          $ 1063 "VR1"
          $ 1064 "If A_Prepos_l[A_VR1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR1] != p[0,0,0,0,0,0]):
            $ 1065 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 1066 "If for_z_VR1≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR_R]≠p[0,0,0,0,0,0]"
              if (for_z_VR1 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR_R] != p[0,0,0,0,0,0]):
                $ 1067 "for_z_VR1≔A_Touch_p[A_HOR_R]"
                global for_z_VR1=A_Touch_p[A_HOR_R]
              end
              $ 1068 "If for_z_VR1≠p[0,0,0,0,0,0]"
              if (for_z_VR1 != p[0,0,0,0,0,0]):
                $ 1069 "z_diff≔get_feature_pose(for_z_VR1,A_Touch_p[A_VR1])"
                global z_diff=get_feature_pose(for_z_VR1,A_Touch_p[A_VR1])
                $ 1070 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[z_diff[0],0,0,0,0,0])
              end
              $ 1071 "If b1_cell_info_R≟B or b1_cell_info_R≟D or b1_cell_info_R≟d or b1_cell_info_R≟E or b1_cell_info_R≟e"
              if (b1_cell_info_R == B  or  b1_cell_info_R == D  or  b1_cell_info_R == d  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
                $ 1072 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[vert_scallup_r/1000,0,0,0,0,0])"
                A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[vert_scallup_r/1000,0,0,0,0,0])
              end
            end
            $ 1074 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1075 "VR2"
          $ 1076 "If A_Prepos_l[A_VR2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR2] != p[0,0,0,0,0,0]):
            $ 1077 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c or b1_cell_info_R≟D or b1_cell_info_R≟d or b1_cell_info_R≟E"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c  or  b1_cell_info_R == D  or  b1_cell_info_R == d  or  b1_cell_info_R == E):
              $ 1078 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1079 "If for_z_VLR2≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR_MR]≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR_MR] != p[0,0,0,0,0,0]):
                $ 1080 "for_z_VLR2≔A_Touch_p[A_HOR_MR]"
                global for_z_VLR2=A_Touch_p[A_HOR_MR]
              end
              $ 1081 "Comment"
              # Comment
              $ 1082 "If for_z_VLR2≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 != p[0,0,0,0,0,0]):
                $ 1083 "z_diff≔get_feature_pose(for_z_VLR2,A_Touch_p[A_VR2])"
                global z_diff=get_feature_pose(for_z_VLR2,A_Touch_p[A_VR2])
                $ 1084 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[z_diff[0],0,0,0,0,0])
              end
              $ 1085 "If b1_cell_info_R≟E or b1_cell_info_R≟e"
              if (b1_cell_info_R == E  or  b1_cell_info_R == e):
                $ 1086 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[vert_scallup_r/1000,0,0,0,0,0])"
                A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[vert_scallup_r/1000,0,0,0,0,0])
              end
            end
            $ 1087 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1088 "HOR_ML"
          $ 1089 "If A_Prepos_l[A_HOR_ML]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_ML] != p[0,0,0,0,0,0]):
            $ 1090 "A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_ML]"
            A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_ML]
            $ 1091 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])"
            global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])
            $ 1092 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_ML], p[x_welding_axis[0],0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_ML], p[x_welding_axis[0],0,0,0,0,0])
            $ 1093 "A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])"
            A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])
            $ 1094 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[10/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[10/1000,0,0,0,0,0])
            $ 1095 "If b1_cell_info_L≟C or b1_cell_info_L≟D"
            if (b1_cell_info_L == C  or  b1_cell_info_L == D):
              $ 1097 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])"
              global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])
              $ 1098 "A_Touch_p[A_HOR_ML]=pose_trans(A_Touch_p[A_HOR_ML],p[x_welding_axis[0],0,0,0,0,0])"
              A_Touch_p[A_HOR_ML]= pose_trans (A_Touch_p[A_HOR_ML],p[x_welding_axis[0],0,0,0,0,0])
              $ 1099 "A_Touch_p[A_HOR_ML]=pose_trans(A_Touch_p[A_HOR_ML],p[0/1000,0,0,0,0,0])"
              A_Touch_p[A_HOR_ML]= pose_trans (A_Touch_p[A_HOR_ML],p[0/1000,0,0,0,0,0])
            end
          end
          $ 1100 "HOR_MR"
          $ 1101 "If A_Prepos_l[A_HOR_MR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_MR] != p[0,0,0,0,0,0]):
            $ 1103 "A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_MR]"
            A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_MR]
            $ 1104 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])"
            global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])
            $ 1105 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[x_welding_axis[0],0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[x_welding_axis[0],0,0,0,0,0])
            $ 1106 "A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])"
            A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])
            $ 1107 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[-10/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[-10/1000,0,0,0,0,0])
            $ 1108 "If b1_cell_info_R≟C or b1_cell_info_R≟D"
            if (b1_cell_info_R == C  or  b1_cell_info_R == D):
              $ 1110 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])"
              global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])
              $ 1111 "A_Touch_p[A_HOR_MR]=pose_trans(A_Touch_p[A_HOR_MR],p[x_welding_axis[0],0,0,0,0,0])"
              A_Touch_p[A_HOR_MR]= pose_trans (A_Touch_p[A_HOR_MR],p[x_welding_axis[0],0,0,0,0,0])
              $ 1112 "A_Touch_p[A_HOR_MR]=pose_trans(A_Touch_p[A_HOR_MR],p[-0/1000,0,0,0,0,0])"
              A_Touch_p[A_HOR_MR]= pose_trans (A_Touch_p[A_HOR_MR],p[-0/1000,0,0,0,0,0])
            end
          end
          $ 1113 "'Touch Remember On/OFF'"
          # 'Touch Remember On/OFF'
          $ 1114 "write_port_register(180,1)"
          write_port_register(180,1)
        else:
          $ 1115 "Else" "noBreak"
          $ 1116 "Ignore Touch and check error"
          $ 1117 "Auto_cur_cell≔0"
          global Auto_cur_cell=0
          $ 1118 "Loop Auto_cur_cell<Auto_total_cell"
          while (Auto_cur_cell<Auto_total_cell):
            $ 1119 "A_sel_v≔Auto_W_num[Auto_cur_cell]"
            global A_sel_v=Auto_W_num[Auto_cur_cell]
            $ 1120 "If A_sel_v<A_HOR_2path"
            if (A_sel_v<A_HOR_2path):
              $ 1121 "If A_Touch_p[A_sel_v]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_sel_v] == p[0,0,0,0,0,0]):
                $ 1122 "write_port_register(142,120)"
                write_port_register(142,120)
                $ 1123 "Halt"
                halt
              end
            end
            $ 1124 "Auto_cur_cell≔Auto_cur_cell+1"
            global Auto_cur_cell=Auto_cur_cell+1
          end
          $ 1125 "Auto_cur_cell≔0"
          global Auto_cur_cell=0
        end
        $ 1126 "welding"
        $ 1127 "weldings"
        $ 1128 "Auto_cur_cell≔read_port_register(138)"
        global Auto_cur_cell= read_port_register (138)
        $ 1129 "time_cal_trig≔ True "
        global time_cal_trig=  True  
        $ 1130 "Loop Auto_cur_cell<Auto_total_cell"
        while (Auto_cur_cell<Auto_total_cell):
          $ 1131 "write_port_register(138,Auto_cur_cell)"
          write_port_register(138,Auto_cur_cell)
          $ 1132 "running_trig≔ True "
          global running_trig=  True  
          $ 1133 "'[2F_AB - 30] , [2F_CD_LEFT - 100] , [2F_CD_RIGHT - 150] , [3F - ELSE]'"
          # '[2F_AB - 30] , [2F_CD_LEFT - 100] , [2F_CD_RIGHT - 150] , [3F - ELSE]'
          $ 1134 "If Auto_W_num[Auto_cur_cell]≥100 and Auto_W_num[Auto_cur_cell]≤149"
          if (Auto_W_num[Auto_cur_cell] >= 100  and  Auto_W_num[Auto_cur_cell] <= 149):
            $ 1135 "'2F CD LEFT'"
            # '2F CD LEFT'
            $ 1136 "A_sel_v≔A_HOR"
            global A_sel_v=A_HOR
            $ 1137 "A_sel_v_end≔A_HOR_ML"
            global A_sel_v_end=A_HOR_ML
            $ 1138 "A_sel_v2≔A_HOR_M"
            global A_sel_v2=A_HOR_M
            $ 1139 "A_sel_v_end2≔A_HOR_R"
            global A_sel_v_end2=A_HOR_R
            $ 1140 "If floor(Auto_W_num[Auto_cur_cell]/10)≟10"
            if (floor(Auto_W_num[Auto_cur_cell]/10) == 10):
              $ 1141 "current_path≔1"
              global current_path=1
              $ 1142 "multi_path≔1"
              global multi_path=1
            else:
              $ 1143 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟11"
              if (floor(Auto_W_num[Auto_cur_cell]/10) == 11):
                $ 1144 "current_path≔2"
                global current_path=2
                $ 1145 "multi_path≔2"
                global multi_path=2
              else:
                $ 1146 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟12"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 12):
                  $ 1147 "current_path≔3"
                  global current_path=3
                  $ 1148 "multi_path≔3"
                  global multi_path=3
                else:
                  $ 1149 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟13"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 13):
                    $ 1150 "current_path≔4"
                    global current_path=4
                    $ 1151 "multi_path≔4"
                    global multi_path=4
                  end
                end
              end
            end
            $ 1152 "current_2f≔current_2f+1"
            global current_2f=current_2f+1
            $ 1153 "CD_MLR≔ True "
            global CD_MLR=  True  
            $ 1154 "write_port_register(135,A_HOR)"
            write_port_register(135,A_HOR)
            $ 1155 "write_port_register(136,current_2f)"
            write_port_register(136,current_2f)
            $ 1156 "If simulation_mode"
            if (simulation_mode):
              $ 1157 "Call welding_parameter_sim"
              welding_parameter_sim()
            else:
              $ 1158 "Else" "noBreak"
              $ 1159 "Call welding_parameter_init"
              welding_parameter_init()
            end
            $ 1160 "wv_direction≔1"
            global wv_direction=1
            $ 1161 "If Auto_W_num[Auto_cur_cell]%10≟4"
            if (Auto_W_num[Auto_cur_cell]%10 == 4):
              $ 1162 "A_sel_v≔A_HOR_R"
              global A_sel_v=A_HOR_R
              $ 1163 "Call MoveFun"
              MoveFun()
              $ 1164 "A_sel_v≔A_HOR"
              global A_sel_v=A_HOR
            else:
              $ 1165 "ElseIf Auto_W_num[Auto_cur_cell]%10≟0 or Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2"
              if (Auto_W_num[Auto_cur_cell]%10 == 0  or  Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2):
                $ 1166 "Call MoveFun"
                MoveFun()
              end
            end
            $ 1167 "Call weav_welding_2f_CD"
            weav_welding_2f_CD()
          else:
            $ 1168 "ElseIf Auto_W_num[Auto_cur_cell]≥150 and Auto_W_num[Auto_cur_cell]≤189"
            if (Auto_W_num[Auto_cur_cell] >= 150  and  Auto_W_num[Auto_cur_cell] <= 189):
              $ 1169 "'2F CD RIGHT'"
              # '2F CD RIGHT'
              $ 1170 "A_sel_v≔A_HOR_R"
              global A_sel_v=A_HOR_R
              $ 1171 "A_sel_v_end≔A_HOR_MR"
              global A_sel_v_end=A_HOR_MR
              $ 1172 "A_sel_v2≔A_HOR_M"
              global A_sel_v2=A_HOR_M
              $ 1173 "A_sel_v_end2≔A_HOR"
              global A_sel_v_end2=A_HOR
              $ 1174 "If floor(Auto_W_num[Auto_cur_cell]/10)≟15"
              if (floor(Auto_W_num[Auto_cur_cell]/10) == 15):
                $ 1175 "current_path≔1"
                global current_path=1
                $ 1176 "multi_path≔1"
                global multi_path=1
              else:
                $ 1177 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟16"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 16):
                  $ 1178 "current_path≔2"
                  global current_path=2
                  $ 1179 "multi_path≔2"
                  global multi_path=2
                else:
                  $ 1180 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟17"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 17):
                    $ 1181 "current_path≔3"
                    global current_path=3
                    $ 1182 "multi_path≔3"
                    global multi_path=3
                  else:
                    $ 1183 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟18"
                    if (floor(Auto_W_num[Auto_cur_cell]/10) == 18):
                      $ 1184 "current_path≔4"
                      global current_path=4
                      $ 1185 "multi_path≔4"
                      global multi_path=4
                    end
                  end
                end
              end
              $ 1186 "current_2f≔current_2f+1"
              global current_2f=current_2f+1
              $ 1187 "CD_MLR≔ False "
              global CD_MLR=  False  
              $ 1188 "write_port_register(135,A_HOR)"
              write_port_register(135,A_HOR)
              $ 1189 "write_port_register(136,current_2f)"
              write_port_register(136,current_2f)
              $ 1190 "If simulation_mode"
              if (simulation_mode):
                $ 1191 "Call welding_parameter_sim"
                welding_parameter_sim()
              else:
                $ 1192 "Else" "noBreak"
                $ 1193 "Call welding_parameter_init"
                welding_parameter_init()
              end
              $ 1194 "wv_direction≔-1"
              global wv_direction=-1
              $ 1195 "If Auto_W_num[Auto_cur_cell]%10≟4"
              if (Auto_W_num[Auto_cur_cell]%10 == 4):
                $ 1196 "A_sel_v≔A_HOR"
                global A_sel_v=A_HOR
                $ 1197 "Call MoveFun"
                MoveFun()
                $ 1198 "A_sel_v≔A_HOR_R"
                global A_sel_v=A_HOR_R
              else:
                $ 1199 "ElseIf Auto_W_num[Auto_cur_cell]%10≟0 or Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2"
                if (Auto_W_num[Auto_cur_cell]%10 == 0  or  Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2):
                  $ 1200 "Call MoveFun"
                  MoveFun()
                end
              end
              $ 1201 "Call weav_welding_2f_CD"
              weav_welding_2f_CD()
            else:
              $ 1202 "ElseIf Auto_W_num[Auto_cur_cell]≥30 and Auto_W_num[Auto_cur_cell]≤65"
              if (Auto_W_num[Auto_cur_cell] >= 30  and  Auto_W_num[Auto_cur_cell] <= 65):
                $ 1203 "'2F'"
                # '2F'
                $ 1204 "A_sel_v≔A_HOR"
                global A_sel_v=A_HOR
                $ 1205 "A_sel_v_end≔A_HOR_R"
                global A_sel_v_end=A_HOR_R
                $ 1206 "If floor(Auto_W_num[Auto_cur_cell]/10)≟3"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 3):
                  $ 1207 "current_path≔1"
                  global current_path=1
                  $ 1208 "multi_path≔1"
                  global multi_path=1
                else:
                  $ 1209 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟4"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 4):
                    $ 1210 "current_path≔2"
                    global current_path=2
                    $ 1211 "multi_path≔2"
                    global multi_path=2
                  else:
                    $ 1212 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟5"
                    if (floor(Auto_W_num[Auto_cur_cell]/10) == 5):
                      $ 1213 "current_path≔3"
                      global current_path=3
                      $ 1214 "multi_path≔3"
                      global multi_path=3
                    else:
                      $ 1215 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟6"
                      if (floor(Auto_W_num[Auto_cur_cell]/10) == 6):
                        $ 1216 "current_path≔4"
                        global current_path=4
                        $ 1217 "multi_path≔4"
                        global multi_path=4
                      end
                    end
                  end
                end
                $ 1218 "current_2f≔current_2f+1"
                global current_2f=current_2f+1
                $ 1219 "write_port_register(135,A_HOR)"
                write_port_register(135,A_HOR)
                $ 1220 "write_port_register(136,current_2f)"
                write_port_register(136,current_2f)
                $ 1221 "If simulation_mode"
                if (simulation_mode):
                  $ 1222 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1223 "Else" "noBreak"
                  $ 1224 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1225 "If Auto_W_num[Auto_cur_cell]%10≟2"
                if (Auto_W_num[Auto_cur_cell]%10 == 2):
                  $ 1226 "A_sel_v≔A_HOR_R"
                  global A_sel_v=A_HOR_R
                  $ 1227 "Call MoveFun"
                  MoveFun()
                  $ 1228 "A_sel_v≔A_HOR"
                  global A_sel_v=A_HOR
                else:
                  $ 1229 "Else" "noBreak"
                  $ 1230 "Call MoveFun"
                  MoveFun()
                end
                $ 1231 "Call weav_welding_2f"
                weav_welding_2f()
              else:
                $ 1232 "Else" "noBreak"
                $ 1233 "A_sel_v≔Auto_W_num[Auto_cur_cell]"
                global A_sel_v=Auto_W_num[Auto_cur_cell]
                $ 1234 "write_port_register(135,A_sel_v)"
                write_port_register(135,A_sel_v)
                $ 1235 "current_path≔1"
                global current_path=1
                $ 1236 "current_2f≔0"
                global current_2f=0
                $ 1237 "write_port_register(136,current_2f)"
                write_port_register(136,current_2f)
                $ 1238 "If simulation_mode"
                if (simulation_mode):
                  $ 1239 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1240 "Else" "noBreak"
                  $ 1241 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1242 "A_sel_v_end≔A_sel_v+9"
                global A_sel_v_end=A_sel_v+9
                $ 1243 "Call weav_welding_3f"
                weav_welding_3f()
              end
            end
          end
          $ 1244 "Call reset_weld_param"
          reset_weld_param()
          $ 1245 "next_before"
          $ 1246 "If get_move_trig≟1"
          if (get_move_trig == 1):
            $ 1247 "If get_next_number≠Auto_cur_cell"
            if (get_next_number != Auto_cur_cell):
              $ 1248 "Auto_cur_cell≔get_next_number"
              global Auto_cur_cell=get_next_number
            else:
              $ 1249 "Else" "noBreak"
              $ 1250 "Auto_cur_cell≔Auto_cur_cell+1"
              global Auto_cur_cell=Auto_cur_cell+1
            end
            $ 1251 "write_port_register(166,0)"
            write_port_register(166,0)
            $ 1252 "write_port_register(167,0)"
            write_port_register(167,0)
            $ 1253 "get_move_trig≔0"
            global get_move_trig=0
          else:
            $ 1254 "Else" "noBreak"
            $ 1255 "Auto_cur_cell≔Auto_cur_cell+1"
            global Auto_cur_cell=Auto_cur_cell+1
          end
        end
        $ 1256 "homeing()"
        homeing()
        $ 1257 "write_port_register(162,1)"
        write_port_register(162,1)
        $ 1258 "write_port_register(180,0)"
        write_port_register(180,0)
        thread_flag_305 = 1
      end
      if (a0_Job_Mode == 2):
        global thread_handler_305=run Thread_if_305()
        while (thread_flag_305 == 0):
          if not(a0_Job_Mode == 2):
            kill thread_handler_305
            thread_flag_305 = 2
          else:
            sync()
          end
        end
      else:
        thread_flag_305 = 2
      end
    end
    $ 1259 "Wait: 0.01"
    sleep(0.01)
    $ 1260 "after init auto"
    $ 1261 "If auto_on"
    if (auto_on):
      $ 1262 "write_port_register(202,0)"
      write_port_register(202,0)
      $ 1263 "timer_1: Stop"
      timer_1_is_counting = False
      $ 1264 "write_welder(0, False )"
      write_welder(0,  False  )
      $ 1265 "write_welder(4, False )"
      write_welder(4,  False  )
      $ 1266 "Call reset_weld_param"
      reset_weld_param()
      $ 1267 "multi_path≔1"
      global multi_path=1
      $ 1268 "auto_on≔ False "
      global auto_on=  False  
      $ 1269 "current_2f≔0"
      global current_2f=0
      $ 1270 "get_center≔get_center_bak"
      global get_center=get_center_bak
      $ 1271 "vr2_p1≔p[0,0,0,0,0,0]"
      global vr2_p1=p[0,0,0,0,0,0]
      $ 1272 "welding_program≔ False "
      global welding_program=  False  
      $ 1273 "start_num≔135"
      global start_num=135
      $ 1274 "Loop start_num<141"
      while (start_num<141):
        $ 1275 "write_port_register(start_num,0)"
        write_port_register(start_num,0)
        $ 1276 "start_num≔start_num+1"
        global start_num=start_num+1
      end
    end
  end
end
