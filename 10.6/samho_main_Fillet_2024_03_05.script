def samho_main_Fillet_2024_03_05():
  modbus_add_signal("127.0.0.1", 255, 239, 2, "MODBUS_1", False)
  modbus_set_signal_update_frequency("MODBUS_1", 1)
  modbus_add_signal("127.0.0.1", 255, 153, 2, "MODBUS_2", False)
  modbus_set_signal_update_frequency("MODBUS_2", 10)
  modbus_add_signal("127.0.0.1", 255, 154, 2, "MODBUS_3", False)
  modbus_set_signal_update_frequency("MODBUS_3", 10)
  modbus_add_signal("127.0.0.1", 255, 204, 2, "MODBUS_4", False)
  modbus_set_signal_update_frequency("MODBUS_4", 10)
  modbus_add_signal("127.0.0.1", 255, 205, 2, "MODBUS_5", False)
  modbus_set_signal_update_frequency("MODBUS_5", 10)
  modbus_add_signal("127.0.0.1", 255, 201, 2, "MODBUS_6", False)
  modbus_set_signal_update_frequency("MODBUS_6", 10)
  modbus_add_signal("127.0.0.1", 255, 202, 2, "MODBUS_7", False)
  modbus_set_signal_update_frequency("MODBUS_7", 10)
  set_tcp(p[-0.20862,-0.00524,0.38449,1.2551,0.019,-2.8747])
  set_payload(2.4, [-0.085, 0.00191, 0.125])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 1)
  set_analog_outputdomain(1, 1)
  set_input_actions_to_default()
  set_tool_digital_input_action(1, "freedrive")
  set_runstate_standard_digital_outputs([0])
  set_runstate_standard_digital_output_to_value(0, 1)
  set_runstate_standard_digital_output_to_value(7, 3)
  set_gravity([0.0, 0.0, 9.82])
  set_tool_voltage(24)
  set_safety_mode_transition_hardness(1)
  step_count_f2810c44_adc3_46b3_ab5f_e83060e03eab = 0.0
  thread Step_Counter_Thread_7db14191_1226_40d4_95da_5f36167022e0():
    while (True):
      step_count_f2810c44_adc3_46b3_ab5f_e83060e03eab = step_count_f2810c44_adc3_46b3_ab5f_e83060e03eab + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_7db14191_1226_40d4_95da_5f36167022e0()
  global A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0.46809, 0.38153, 0.04984, -2.35756, -1.0346, -1.29868], p[0, 0, 0, 0, 0, 0], p[0.46992, -0.42847, 0.05169, 2.24214, -1.10327, 1.24657], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
  global x_offset_3=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global x_offset_2=[0, 0, 0, 0.0209, 0.0209, 0.0209, 0.0209, 0.02404, 0.02404, 0.02404, 0.67295, 0.67295, 0.67295, 2.17295, 2.17295, 2.17295, 2.71631, 2.71631, 2.71631, 4.21631, 4.21631, 4.70369, 4.70369, 4.70369, 4.88237, 4.88237, 4.88237, 4.71508, 4.71508, 4.71508, 4.94078, 4.94078, 4.79072, 4.79072, 4.79072, 4.75658, 4.75658, 4.75658, 4.91311, 4.91311, 4.91311, 4.93686, 4.93686, 4.93686, 5.14007, 5.14007, 5.1772, 5.1772, 5.1772, 5.18907, 5.18907, 5.18907, 5.23752, 5.23752, 5.23752, 6.44215, 6.44215, 6.47898, 6.47898, 6.47898, 6.4358, 6.4358, 6.4358, 6.27225, 6.27225, 6.27225, 6.28625, 6.28625, 6.28625, 6.32596, 6.32596, 6.09664, 6.09664, 6.09664, 5.90683, 5.90683, 5.90683, 5.8852, 5.8852, 5.8852, 7.21499, 7.21499, 7.23472, 7.23472, 7.23472, 6.60284, 6.60284, 6.60284, 6.76782, 6.76782, 6.76782, 6.77998, 6.77998, 6.77998, 7.28903, 7.28903, 7.28454, 7.28454, 7.28454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global A_Distance_list=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global x_offset_1=[0, 0, 0, -0.02252, -0.02252, -0.02252, -0.02252, 0.13096, 0.13096, 0.13096, 2.13096, 2.13096, 2.13096, 2.79881, 2.79881, 2.79881, 2.79282, 2.79282, 2.79282, 2.61839, 2.61839, 2.63263, 2.63263, 2.63263, 2.62365, 2.62365, 2.62365, 3.30637, 3.30637, 3.30637, 4.74748, 4.74748, 4.71042, 4.71042, 4.71042, 4.68978, 4.68978, 4.68978, 4.48892, 4.48892, 4.48892, 3.24306, 3.24306, 3.24306, 3.21841, 3.21841, 3.25956, 3.25956, 3.25956, 5.25956, 5.25956, 5.25956, 5.09671, 5.09671, 5.09671, 5.11266, 5.11266, 4.90289, 4.90289, 4.90289, 4.02534, 4.02534, 4.02534, 4.19985, 4.19985, 4.19985, 4.03315, 4.03315, 4.03315, 4.03825, 4.03825, 4.0859, 4.0859, 4.0859, 4.12182, 4.12182, 4.12182, 5.56392, 5.56392, 5.56392, 5.61278, 5.61278, 5.56799, 5.56799, 5.56799, 6.3781, 6.3781, 6.3781, 5.52948, 5.52948, 5.52948, 5.5349, 5.5349, 5.5349, 5.52338, 5.52338, 6.3895, 6.3895, 6.3895, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global last_tilt_deg=[30, -0, 0]
  global step_2f=2
  global A_touch_bottom=p[0.4884, 0.0279, -0.05448, 2.85052, -0.02454, 1.30656]
  global A_Touch_trig_l=[False, False, False, False, False, True, False, True, False, False, False]
  global Auto_trig=True
  global Auto_W_num=[31, 32, 41, 42, 51, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global Reset_Trig=False
  global last_wv_wp1=p[0.48809, -0.02364, -0.05448, 2.88623, -0.01704, 1.22388]
  global A_Speed_list=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global last_z_bottom=-0.0502
  global A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0.49492, 0.37647, -0.00373, -1.74067, 1.76135, -0.74873], p[0, 0, 0, 0, 0, 0], p[0.49325, -0.42377, 0.00921, -1.77678, 1.78638, -0.71819], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0]]
  global z_offset_3=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global z_offset_2=[0, 0, 0, 0.77652, 0.77652, 0.77652, 0.77652, 4.77652, 4.77652, 4.77652, 8.77652, 8.77652, 8.77652, 9.70696, 9.70696, 9.70696, 9.70696, 9.70696, 9.70696, 9.86322, 9.86322, 11.04005, 11.04005, 11.04005, 11.70378, 11.70378, 11.70378, 12.6435, 12.6435, 12.6435, 12.8145, 12.8145, 13.44251, 13.44251, 13.44251, 14.37812, 14.37812, 14.37812, 14.43959, 14.43959, 14.43959, 14.63644, 14.63644, 14.63644, 14.76133, 14.76133, 16.3973, 16.3973, 16.3973, 17.51846, 17.51846, 17.51846, 17.46024, 17.46024, 17.46024, 16.57938, 16.57938, 15.57852, 15.57852, 15.57852, 14.06174, 14.06174, 14.06174, 13.91328, 13.91328, 13.91328, 14.75741, 14.75741, 14.75741, 14.95018, 14.95018, 14.9305, 14.9305, 14.9305, 14.91085, 14.91085, 14.91085, 13.42972, 13.42972, 13.42972, 12.56827, 12.56827, 11.94768, 11.94768, 11.94768, 11.06049, 11.06049, 11.06049, 10.36556, 10.36556, 10.36556, 9.66223, 9.66223, 9.66223, 8.10136, 8.10136, 4.45952, 4.45952, 4.45952, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global z_offset_1=[0, 0, 0, 3.84239, 3.84239, 3.84239, 3.84239, 7.76295, 7.76295, 7.76295, 7.92335, 7.92335, 7.92335, 8.7083, 8.7083, 8.7083, 9.56251, 9.56251, 9.56251, 11.37986, 11.37986, 13.17871, 13.17871, 13.17871, 14.66928, 14.66928, 14.66928, 14.80578, 14.80578, 14.80578, 14.83719, 14.83719, 15.63828, 15.63828, 15.63828, 15.72912, 15.72912, 15.72912, 15.59233, 15.59233, 15.59233, 15.55065, 15.55065, 15.55065, 17.0551, 17.0551, 20.57114, 20.57114, 20.57114, 20.52132, 20.52132, 20.52132, 19.36419, 19.36419, 19.36419, 19.2215, 19.2215, 19.17005, 19.17005, 19.17005, 18.97372, 18.97372, 18.97372, 18.80152, 18.80152, 18.80152, 19.52527, 19.52527, 19.52527, 19.70213, 19.70213, 19.80342, 19.80342, 19.80342, 18.96513, 18.96513, 18.96513, 17.54204, 17.54204, 17.54204, 16.80619, 16.80619, 13.73593, 13.73593, 13.73593, 13.62525, 13.62525, 13.62525, 12.71187, 12.71187, 12.71187, 11.52228, 11.52228, 11.52228, 9.66149, 9.66149, 9.49537, 9.49537, 9.49537, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  global last_wv_line=p[0.49409, -0.02365, -0.05448, -1.74067, 1.76135, -0.74873]
  global last_pose=p[0.50354, -0.16852, -0.0383, 2.73154, -0.12092, 1.1572]
  global Auto_total_cell=6
  global Auto_cur_cell=3
  global Base=p[0.0,0.0,0.0,0.0,0.0,0.0]
  global save_timer=0
  global timer_1=0
  def calculate_point_to_move_towards(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=normalize(posDir)
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  global save_timer_is_counting=False
  global timer_1_is_counting=False
  thread Timer_Thread():
    while (True):
      if (save_timer_is_counting):
        save_timer = save_timer + get_steptime()
      end
      if (timer_1_is_counting):
        timer_1 = timer_1 + get_steptime()
      end
      sync()
    end
  end
  run Timer_Thread()
  def cell_info():
    $ 1549 "cell_info" "noBreak"
    $ 1550 "'cell_setting'"
    # 'cell_setting'
    $ 1551 "a7_f_distance≔get_center"
    global a7_f_distance=get_center
    $ 1552 "'dis + 125'"
    # 'dis + 125'
    $ 1553 "If simulation_mode"
    if (simulation_mode):
      $ 1554 "a6_f_height_l≔190"
      global a6_f_height_l=190
      $ 1555 "a6_f_height_r≔190"
      global a6_f_height_r=190
      $ 1556 "a6_f_width≔690"
      global a6_f_width=690
      $ 1557 "a6_callar_hor≔100"
      global a6_callar_hor=100
      $ 1558 "a6_callar_vert≔100"
      global a6_callar_vert=100
      $ 1559 "center_height≔50"
      global center_height=50
      $ 1560 "EXT_flag1≔integer_to_binary_list(2048)"
      global EXT_flag1= integer_to_binary_list (2048)
      $ 1561 "get_margin_z≔50"
      global get_margin_z=50
    else:
      $ 1562 "Else" "noBreak"
      $ 1563 "a6_f_height_l≔read_port_register(173)"
      global a6_f_height_l= read_port_register (173)
      $ 1564 "a6_f_height_r≔read_port_register(174)"
      global a6_f_height_r= read_port_register (174)
      $ 1565 "a6_f_width≔read_port_register(175)"
      global a6_f_width= read_port_register (175)
      $ 1566 "a6_callar_hor≔read_port_register(181)"
      global a6_callar_hor= read_port_register (181)
      $ 1567 "a6_callar_vert≔read_port_register(182)"
      global a6_callar_vert= read_port_register (182)
      $ 1568 "center_height≔read_port_register(237)"
      global center_height=read_port_register(237)
      $ 1569 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
      global EXT_flag1= integer_to_binary_list ( read_port_register (179))
      $ 1571 "get_margin_z≔read_port_register(238)"
      global get_margin_z=read_port_register(238)
      $ 1573 "If center_height>32765"
      if (center_height>32765):
        $ 1574 "center_height≔center_height-65535"
        global center_height=center_height-65535
      end
      $ 1575 "If get_margin_z>32765"
      if (get_margin_z>32765):
        $ 1576 "get_margin_z≔get_margin_z-65535"
        global get_margin_z=get_margin_z-65535
      end
    end
    $ 1577 "Initialization"
    $ 1578 "CELL_ROBOT_DIST≔a7_f_distance"
    global CELL_ROBOT_DIST=a7_f_distance
    $ 1579 "CELL_WIDTH≔a6_f_width"
    global CELL_WIDTH=a6_f_width
  end
  def robotand_cell_initalizat():
    $ 1580 "robotand_cell_initalizat" "noBreak"
    $ 1581 "If Auto_trig≟ True "
    if (Auto_trig ==   True  ):
      $ 1582 "Auto_trig≔ False "
      global Auto_trig=  False  
      $ 1583 "init"
      $ 1584 "write_port_register(cell_3f_2f_151,0)"
      write_port_register(cell_3f_2f_151,0)
      $ 1585 "write_port_register(cell_info_152,0)"
      write_port_register(cell_info_152,0)
      $ 1586 "write_port_register(weld_req_153,0)"
      write_port_register(weld_req_153,0)
      $ 1587 "write_port_register(touch_cell_155,0)"
      write_port_register(touch_cell_155,0)
      $ 1588 "write_port_register(touch_num_156,0)"
      write_port_register(touch_num_156,0)
      $ 1589 "write_port_register(touch_done_157,0)"
      write_port_register(touch_done_157,0)
      $ 1590 "write_port_register(weld_done_137,0)"
      write_port_register(weld_done_137,0)
      $ 1591 "write_port_register(135,0)"
      write_port_register(135,0)
      $ 1592 "write_port_register(136,0)"
      write_port_register(136,0)
      $ 1593 "write_port_register(165,0)"
      write_port_register(165,0)
      $ 1594 "write_port_register(166,0)"
      write_port_register(166,0)
      $ 1595 "write_port_register(167,0)"
      write_port_register(167,0)
      $ 1596 "write_port_register(169,0)"
      write_port_register(169,0)
      $ 1597 "write_port_register(170,0)"
      write_port_register(170,0)
      $ 1598 "write_port_register(221,0)"
      write_port_register(221,0)
      $ 1599 "write_port_register(222,0)"
      write_port_register(222,0)
      $ 1600 "write_port_register(223,0)"
      write_port_register(223,0)
      $ 1601 "write_port_register(224,0)"
      write_port_register(224,0)
      $ 1602 "write_port_register(225,0)"
      write_port_register(225,0)
      $ 1603 "write_port_register(226,0)"
      write_port_register(226,0)
      $ 1604 "write_port_register(227,0)"
      write_port_register(227,0)
      $ 1605 "write_port_register(228,0)"
      write_port_register(228,0)
      $ 1606 "write_port_register(240,0)"
      write_port_register(240,0)
      $ 1607 "write_port_register(176,0)"
      write_port_register(176,0)
      $ 1608 "write_port_register(177,0)"
      write_port_register(177,0)
      $ 1609 "write_port_register(154,0)"
      write_port_register(154,0)
    end
    $ 1610 "sync()"
    sync()
  end
  def reset_multi_record():
    $ 1611 "reset_multi_record" "noBreak"
    $ 1612 "step_2f≔0"
    global step_2f=0
    $ 1613 "x_offset_1≔[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    global x_offset_1=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    $ 1614 "x_offset_2≔[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    global x_offset_2=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    $ 1615 "x_offset_3≔[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    global x_offset_3=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    $ 1616 "z_offset_1≔[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    global z_offset_1=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    $ 1617 "z_offset_2≔[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    global z_offset_2=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    $ 1618 "z_offset_3≔[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
    global z_offset_3=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  end
  def welding_parameter_init():
    $ 1619 "welding_parameter_init" "noBreak"
    $ 1620 "init"
    $ 1621 "If A_sel_v≟A_VL1 or A_sel_v≟A_VL2 or A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL1  or  A_sel_v == A_VL2  or  A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1622 "position_3f2f≔position_3F"
      global position_3f2f=position_3F
      $ 1623 "write_port_register(cell_3f_2f_151,A_sel_v)"
      write_port_register(cell_3f_2f_151,A_sel_v)
      $ 1624 "b8_wv_2f≔ False "
      global b8_wv_2f=  False  
      $ 1625 "d_lean_degree≔0"
      global d_lean_degree=0
    else:
      $ 1626 "Else" "noBreak"
      $ 1627 "position_3f2f≔position_2F"
      global position_3f2f=position_2F
      $ 1628 "b8_wv_2f≔ True "
      global b8_wv_2f=  True  
      $ 1629 "d_lean_degree≔30"
      global d_lean_degree=30
      $ 1630 "write_port_register(cell_3f_2f_151,A_HOR)"
      write_port_register(cell_3f_2f_151,A_HOR)
    end
    $ 1631 "If current_path≥2"
    if (current_path >= 2):
      $ 1632 "write_port_register(cell_info_152,current_path)"
      write_port_register(cell_info_152,current_path)
    else:
      $ 1633 "Else" "noBreak"
      $ 1634 "write_port_register(cell_info_152,1)"
      write_port_register(cell_info_152,1)
    end
    $ 1635 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 1636 "Wait: 0.3"
    sleep(0.3)
    $ 1637 "write_port_register(weld_req_153,1)"
    write_port_register(weld_req_153,1)
    $ 1638 "Wait read_port_register(return_done_240)≟1"
    while (not( read_port_register (return_done_240) == 1)):
      sync()
    end
    $ 1639 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 1640 "touch_m_check≔0"
    global touch_m_check=0
    $ 1641 "start_end_from_pendant"
    $ 1642 "d_start_current≔read_port_register(244)/10"
    global d_start_current= read_port_register (244)/10
    $ 1643 "d_start_voltage≔read_port_register(245)/10"
    global d_start_voltage= read_port_register (245)/10
    $ 1644 "d_start_time≔read_port_register(241)/10"
    global d_start_time= read_port_register (241)/10
    $ 1645 "d_end_current≔read_port_register(249)/10"
    global d_end_current= read_port_register (249)/10
    $ 1646 "d_end_voltage≔read_port_register(250)/10"
    global d_end_voltage= read_port_register (250)/10
    $ 1647 "d_end_time≔read_port_register(246)/10"
    global d_end_time= read_port_register (246)/10
    $ 1648 "d_end_current_2≔read_port_register(254)/10"
    global d_end_current_2= read_port_register (254)/10
    $ 1649 "d_end_voltage_2≔read_port_register(255)/10"
    global d_end_voltage_2= read_port_register (255)/10
    $ 1650 "d_end_time_2≔read_port_register(251)/10"
    global d_end_time_2= read_port_register (251)/10
    $ 1651 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]"
    global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]
    $ 1652 "a0_volt_ref≔read_port_register(231)/10"
    global a0_volt_ref= read_port_register (231)/10
    $ 1653 "a1_amp_ref≔read_port_register(232)/10"
    global a1_amp_ref= read_port_register (232)/10
    $ 1654 "a2_speed_cpm≔read_port_register(233)/10"
    global a2_speed_cpm= read_port_register (233)/10
    $ 1655 "a3_wv_amplitude≔read_port_register(234)/10"
    global a3_wv_amplitude= read_port_register (234)/10
    $ 1656 "a4_wv_frequency≔read_port_register(225)/10"
    global a4_wv_frequency= read_port_register (225)/10
    $ 1657 "b1_appro_param≔0"
    global b1_appro_param=0
    $ 1658 "b4_wv_delay2≔read_port_register(226)/10"
    global b4_wv_delay2= read_port_register (226)/10
    $ 1659 "b6_wv_delay4≔read_port_register(227)/10"
    global b6_wv_delay4= read_port_register (227)/10
    $ 1660 "'down'"
    # 'down'
    $ 1662 "'up'"
    # 'up'
    $ 1666 "b3_wv_delay1≔0"
    global b3_wv_delay1=0
    $ 1667 "b5_wv_delay3≔0"
    global b5_wv_delay3=0
    $ 1668 "b3_dealy_all≔[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]"
    global b3_dealy_all=[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]
    $ 1669 "get_width_182≔read_port_register(182)"
    global get_width_182= read_port_register (182)
    $ 1670 "b9_touch_sens≔20"
    global b9_touch_sens=20
    $ 1671 "task_angle≔register_read(228)/10"
    global task_angle=register_read(228)/10
    $ 1672 "Circle_Speed≔a2_speed_cpm"
    global Circle_Speed=a2_speed_cpm
    $ 1673 "CELL_BOTTOM≔a7_cell_bottom"
    global CELL_BOTTOM=a7_cell_bottom
    $ 1674 "a6_scallup_left≔read_port_register(176)"
    global a6_scallup_left= read_port_register (176)
    $ 1675 "a6_scallup_righ≔read_port_register(177)"
    global a6_scallup_righ= read_port_register (177)
    $ 1676 "a5_f_hole≔[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]"
    global a5_f_hole=[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]
    $ 1677 "c8_arc_cur_offs≔read_port_register(239)"
    global c8_arc_cur_offs= read_port_register (239)
    $ 1711 "폴더"
    $ 1712 "offset_2f_x≔7"
    global offset_2f_x=7
    $ 1713 "offset_3f_z≔-5"
    global offset_3f_z=-5
    $ 1714 "If A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1715 "'3F'"
      # '3F'
      $ 1716 "b2_left_par≔ False "
      global b2_left_par=  False  
      $ 1717 "b8_wv_type≔1"
      global b8_wv_type=1
      $ 1718 "If A_sel_v≟A_VR2 and (b1_cell_info_R≟c or b1_cell_info_R≟d)"
      if (A_sel_v == A_VR2  and  (b1_cell_info_R == c  or  b1_cell_info_R == d)):
        $ 1719 "b7_tilt_degree≔[0,0,0]"
        global b7_tilt_degree=[0,0,0]
      else:
        $ 1720 "Else" "noBreak"
        $ 1721 "b7_tilt_degree≔[task_angle,-27,0]"
        global b7_tilt_degree=[task_angle,-27,0]
      end
      $ 1722 "c3_arc_enable≔1"
      global c3_arc_enable=1
    else:
      $ 1723 "ElseIf A_sel_v≟A_VL1 or A_sel_v≟A_VL2"
      if (A_sel_v == A_VL1  or  A_sel_v == A_VL2):
        $ 1724 "'3F'"
        # '3F'
        $ 1725 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1726 "b8_wv_type≔1"
        global b8_wv_type=1
        $ 1727 "If A_sel_v≟A_VL2 and (b1_cell_info_L≟c or b1_cell_info_L≟d)"
        if (A_sel_v == A_VL2  and  (b1_cell_info_L == c  or  b1_cell_info_L == d)):
          $ 1728 "b7_tilt_degree≔[0,0,0]"
          global b7_tilt_degree=[0,0,0]
        else:
          $ 1729 "Else" "noBreak"
          $ 1730 "b7_tilt_degree≔[task_angle,-27,0]"
          global b7_tilt_degree=[task_angle,-27,0]
        end
        $ 1731 "c3_arc_enable≔1"
        global c3_arc_enable=1
      else:
        $ 1732 "Else" "noBreak"
        $ 1733 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1734 "b8_wv_type≔2"
        global b8_wv_type=2
        $ 1735 "If A_sel_v≟A_HOR"
        if (A_sel_v == A_HOR):
          $ 1736 "b7_tilt_degree≔[30,-1*task_angle,0]"
          global b7_tilt_degree=[30,-1*task_angle,0]
        else:
          $ 1737 "Else" "noBreak"
          $ 1739 "b7_tilt_degree≔[30,-1*task_angle,0]"
          global b7_tilt_degree=[30,-1*task_angle,0]
        end
        $ 1741 "c3_arc_enable≔1"
        global c3_arc_enable=1
      end
    end
    $ 1742 "If A_sel_v≟A_VL2 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL2  or  A_sel_v == A_VR2):
      $ 1743 "If b1_cell_info_L≟E or b1_cell_info_L≟e or b1_cell_info_R≟E or b1_cell_info_R≟e"
      if (b1_cell_info_L == E  or  b1_cell_info_L == e  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
        $ 1744 "a8_wv_distance≔read_port_register(182)-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance= read_port_register (182)-a5_f_hole[1]-offset_3f_begin
      else:
        $ 1745 "Else" "noBreak"
        $ 1746 "a8_wv_distance≔read_port_register(182)-offset_3f_begin"
        global a8_wv_distance= read_port_register (182)-offset_3f_begin
      end
    else:
      $ 1751 "Else" "noBreak"
      $ 1752 "If b2_left_par"
      if (b2_left_par):
        $ 1753 "Comment"
        # Comment
        $ 1754 "a8_wv_distance≔a6_f_height_l-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance=a6_f_height_l-a5_f_hole[1]-offset_3f_begin
        $ 1755 "Comment"
        # Comment
      else:
        $ 1756 "Else" "noBreak"
        $ 1757 "a8_wv_distance≔a6_f_height_r-a5_f_hole[1]-offset_3f_begin"
        global a8_wv_distance=a6_f_height_r-a5_f_hole[1]-offset_3f_begin
      end
    end
    $ 1758 "Ext fun & Squash"
    $ 1759 "If (A_sel_v≟A_VL1 or A_sel_v≟A_VL2) and (b1_cell_info_L≟B or b1_cell_info_L≟D)"
    if ((A_sel_v == A_VL1  or  A_sel_v == A_VL2)  and  (b1_cell_info_L == B  or  b1_cell_info_L == D)):
      $ 1760 "Scallup_check≔ True "
      global Scallup_check=  True  
    else:
      $ 1761 "ElseIf (A_sel_v≟A_VR1 or A_sel_v≟A_VR2) and (b1_cell_info_R≟B or b1_cell_info_R≟D)"
      if ((A_sel_v == A_VR1  or  A_sel_v == A_VR2)  and  (b1_cell_info_R == B  or  b1_cell_info_R == D)):
        $ 1762 "Scallup_check≔ True "
        global Scallup_check=  True  
      else:
        $ 1763 "Else" "noBreak"
        $ 1764 "Scallup_check≔ False "
        global Scallup_check=  False  
      end
    end
    $ 1765 "'squash'"
    # 'squash'
    $ 1766 "If (EXT_flag1[7]≟ True ) and (A_sel_v≠A_HOR) and (A_sel_v≠A_VL2) and (A_sel_v≠A_VR2) and (Scallup_check≟ False ) and (A_sel_v≟A_VL1 and b1_cell_info_L≠E and b1_cell_info_L≠e) and (A_sel_v≟A_VR1 and b1_cell_info_R≠E and b1_cell_info_R≠e)"
    if ((EXT_flag1[7] ==   True  )  and  (A_sel_v != A_HOR)  and  (A_sel_v != A_VL2)  and  (A_sel_v != A_VR2)  and  (Scallup_check ==   False  )  and  (A_sel_v == A_VL1  and  b1_cell_info_L != E  and  b1_cell_info_L != e)  and  (A_sel_v == A_VR1  and  b1_cell_info_R != E  and  b1_cell_info_R != e)):
      $ 1767 "squash"
      $ 1768 "squash_enable≔1"
      global squash_enable=1
      $ 1769 "squash_voltage≔24.5"
      global squash_voltage=24.5
      $ 1770 "squash_current≔190"
      global squash_current=190
      $ 1771 "squash_amp≔7"
      global squash_amp=7
      $ 1772 "squash_speed≔10"
      global squash_speed=10
      $ 1773 "squash_cycle≔8"
      global squash_cycle=8
    else:
      $ 1774 "Else" "noBreak"
      $ 1775 "squash"
      $ 1776 "squash_enable≔0"
      global squash_enable=0
      $ 1777 "squash_voltage≔0"
      global squash_voltage=0
      $ 1778 "squash_current≔0"
      global squash_current=0
      $ 1779 "squash_amp≔0"
      global squash_amp=0
      $ 1780 "squash_speed≔0"
      global squash_speed=0
      $ 1781 "squash_cycle≔0"
      global squash_cycle=0
    end
    $ 1782 "'sladge'"
    # 'sladge'
    $ 1783 "If EXT_flag1[8]≟ True  and EXT_flag1[9]≟ False "
    if (EXT_flag1[8] ==   True    and  EXT_flag1[9] ==   False  ):
      $ 1784 "sludge≔1"
      global sludge=1
    else:
      $ 1785 "ElseIf EXT_flag1[8]≟ False  and EXT_flag1[9]≟ True "
      if (EXT_flag1[8] ==   False    and  EXT_flag1[9] ==   True  ):
        $ 1786 "sludge≔2"
        global sludge=2
      else:
        $ 1787 "Else" "noBreak"
        $ 1788 "sludge≔0"
        global sludge=0
      end
    end
    $ 1789 "waste_cycle≔1"
    global waste_cycle=1
    $ 1790 "c0_offset_x≔read_port_register(229)/10"
    global c0_offset_x= read_port_register (229)/10
    $ 1791 "c0_offset_z≔read_port_register(230)/10"
    global c0_offset_z= read_port_register (230)/10
    $ 1792 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
    global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
    $ 1793 "WV_gap"
    $ 1794 "c5_wv_gap_y≔read_port_register(236)/10"
    global c5_wv_gap_y= read_port_register (236)/10
    $ 1795 "c6_wv_gap_cpm≔read_port_register(235)/10"
    global c6_wv_gap_cpm= read_port_register (235)/10
    $ 1796 "c9_wv_gap_freq≔a4_wv_frequency"
    global c9_wv_gap_freq=a4_wv_frequency
    $ 1797 "If c6_wv_gap_cpm≟a2_speed_cpm and a3_wv_amplitude≟c5_wv_gap_y"
    if (c6_wv_gap_cpm == a2_speed_cpm  and  a3_wv_amplitude == c5_wv_gap_y):
      $ 1798 "c4_gap_enable≔0"
      global c4_gap_enable=0
    else:
      $ 1799 "Else" "noBreak"
      $ 1800 "c4_gap_enable≔1"
      global c4_gap_enable=1
    end
    $ 1801 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
    global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
    $ 1802 "arc_sen"
    $ 1803 "c3_X_p_gain≔read_port_register(186)/10"
    global c3_X_p_gain= read_port_register (186)/10
    $ 1804 "c3_X_i_gain≔read_port_register(187)/10"
    global c3_X_i_gain= read_port_register (187)/10
    $ 1805 "c3_Z_p_gain≔read_port_register(184)/10"
    global c3_Z_p_gain= read_port_register (184)/10
    $ 1806 "c3_Z_i_gain≔read_port_register(185)/10"
    global c3_Z_i_gain= read_port_register (185)/10
    $ 1807 "c3_wv_arc_fix≔0"
    global c3_wv_arc_fix=0
    $ 1808 "c3_wv_arc≔[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]"
    global c3_wv_arc=[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]
    $ 1809 "volt and current"
    $ 1810 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
    set_current_voltage(a1_amp_ref,a0_volt_ref)
    $ 1811 "write_port_register(154,1)"
    write_port_register(154,1)
    $ 1812 "Wait read_port_register(return_done_240)≟0"
    while (not( read_port_register (return_done_240) == 0)):
      sync()
    end
    $ 1813 "write_port_register(154,0)"
    write_port_register(154,0)
  end
  def welding_parameter_sim():
    $ 1814 "welding_parameter_sim" "noBreak"
    $ 1815 "init"
    $ 1816 "If A_sel_v≟A_VL1 or A_sel_v≟A_VL2 or A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL1  or  A_sel_v == A_VL2  or  A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1817 "position_3f2f≔position_3F"
      global position_3f2f=position_3F
      $ 1818 "write_port_register(cell_3f_2f_151,A_sel_v)"
      write_port_register(cell_3f_2f_151,A_sel_v)
      $ 1819 "b8_wv_2f≔ False "
      global b8_wv_2f=  False  
      $ 1820 "d_lean_degree≔0"
      global d_lean_degree=0
    else:
      $ 1821 "Else" "noBreak"
      $ 1822 "position_3f2f≔position_2F"
      global position_3f2f=position_2F
      $ 1823 "b8_wv_2f≔ True "
      global b8_wv_2f=  True  
      $ 1824 "d_lean_degree≔30"
      global d_lean_degree=30
      $ 1825 "write_port_register(cell_3f_2f_151,A_HOR)"
      write_port_register(cell_3f_2f_151,A_HOR)
    end
    $ 1826 "If current_path≥2"
    if (current_path >= 2):
      $ 1827 "write_port_register(cell_info_152,current_path)"
      write_port_register(cell_info_152,current_path)
    else:
      $ 1828 "Else" "noBreak"
      $ 1829 "write_port_register(cell_info_152,1)"
      write_port_register(cell_info_152,1)
    end
    $ 1830 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 1831 "Wait: 0.3"
    sleep(0.3)
    $ 1832 "write_port_register(weld_req_153,1)"
    write_port_register(weld_req_153,1)
    $ 1834 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 1835 "touch_m_check≔0"
    global touch_m_check=0
    $ 1836 "start_end_from_pendant"
    $ 1837 "d_start_current≔read_port_register(244)/10"
    global d_start_current= read_port_register (244)/10
    $ 1838 "d_start_voltage≔read_port_register(245)/10"
    global d_start_voltage= read_port_register (245)/10
    $ 1839 "d_start_time≔read_port_register(241)/10"
    global d_start_time= read_port_register (241)/10
    $ 1840 "d_end_current≔read_port_register(249)/10"
    global d_end_current= read_port_register (249)/10
    $ 1841 "d_end_voltage≔read_port_register(250)/10"
    global d_end_voltage= read_port_register (250)/10
    $ 1842 "d_end_time≔read_port_register(246)/10"
    global d_end_time= read_port_register (246)/10
    $ 1843 "d_end_current_2≔read_port_register(254)/10"
    global d_end_current_2= read_port_register (254)/10
    $ 1844 "d_end_voltage_2≔read_port_register(255)/10"
    global d_end_voltage_2= read_port_register (255)/10
    $ 1845 "d_end_time_2≔read_port_register(251)/10"
    global d_end_time_2= read_port_register (251)/10
    $ 1846 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]"
    global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current,d_end_voltage,d_end_time,d_lean_degree]
    $ 1847 "a0_volt_ref≔read_port_register(231)/10"
    global a0_volt_ref= read_port_register (231)/10
    $ 1848 "a1_amp_ref≔read_port_register(232)/10"
    global a1_amp_ref= read_port_register (232)/10
    $ 1849 "b1_appro_param≔0"
    global b1_appro_param=0
    $ 1850 "Folder"
    $ 1851 "a2_speed_cpm≔17"
    global a2_speed_cpm=17
    $ 1852 "a3_wv_amplitude≔5"
    global a3_wv_amplitude=5
    $ 1853 "a4_wv_frequency≔1.4"
    global a4_wv_frequency=1.4
    $ 1854 "b4_wv_delay2≔0.3"
    global b4_wv_delay2=0.3
    $ 1855 "b6_wv_delay4≔0.3"
    global b6_wv_delay4=0.3
    $ 1856 "b9_touch_sens≔10"
    global b9_touch_sens=10
    $ 1857 "task_angle≔0"
    global task_angle=0
    $ 1858 "a6_scallup_left≔0"
    global a6_scallup_left=0
    $ 1859 "a6_scallup_righ≔0"
    global a6_scallup_righ=0
    $ 1860 "b3_wv_delay1≔0"
    global b3_wv_delay1=0
    $ 1861 "b5_wv_delay3≔0"
    global b5_wv_delay3=0
    $ 1862 "b3_dealy_all≔[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]"
    global b3_dealy_all=[b3_wv_delay1,b4_wv_delay2,b5_wv_delay3,b6_wv_delay4]
    $ 1863 "get_width_182≔a6_callar_vert"
    global get_width_182=a6_callar_vert
    $ 1864 "task_angle≔register_read(228)/10"
    global task_angle=register_read(228)/10
    $ 1865 "Circle_Speed≔a2_speed_cpm"
    global Circle_Speed=a2_speed_cpm
    $ 1866 "CELL_BOTTOM≔a7_cell_bottom"
    global CELL_BOTTOM=a7_cell_bottom
    $ 1867 "a5_f_hole≔[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]"
    global a5_f_hole=[a7_cell_bottom,a6_scallup_left,a6_scallup_righ]
    $ 1868 "폴더"
    $ 1869 "offset_2f_x≔7"
    global offset_2f_x=7
    $ 1870 "offset_3f_z≔-5"
    global offset_3f_z=-5
    $ 1871 "If A_sel_v≟A_VR1 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VR1  or  A_sel_v == A_VR2):
      $ 1872 "'3F'"
      # '3F'
      $ 1873 "b2_left_par≔ False "
      global b2_left_par=  False  
      $ 1874 "b8_wv_type≔1"
      global b8_wv_type=1
      $ 1875 "b7_tilt_degree≔[task_angle,-27,0]"
      global b7_tilt_degree=[task_angle,-27,0]
      $ 1876 "c3_arc_enable≔1"
      global c3_arc_enable=1
    else:
      $ 1877 "ElseIf A_sel_v≟A_VL1 or A_sel_v≟A_VL2"
      if (A_sel_v == A_VL1  or  A_sel_v == A_VL2):
        $ 1878 "'3F'"
        # '3F'
        $ 1879 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1880 "b8_wv_type≔1"
        global b8_wv_type=1
        $ 1881 "b7_tilt_degree≔[task_angle,-27,0]"
        global b7_tilt_degree=[task_angle,-27,0]
        $ 1882 "c3_arc_enable≔1"
        global c3_arc_enable=1
      else:
        $ 1883 "Else" "noBreak"
        $ 1884 "b2_left_par≔ True "
        global b2_left_par=  True  
        $ 1885 "b8_wv_type≔2"
        global b8_wv_type=2
        $ 1886 "b7_tilt_degree≔[30,-1*task_angle,0]"
        global b7_tilt_degree=[30,-1*task_angle,0]
        $ 1888 "c3_arc_enable≔0"
        global c3_arc_enable=0
      end
    end
    $ 1889 "If A_sel_v≟A_VL2 or A_sel_v≟A_VR2"
    if (A_sel_v == A_VL2  or  A_sel_v == A_VR2):
      $ 1890 "a8_wv_distance≔read_port_register(182)"
      global a8_wv_distance= read_port_register (182)
    else:
      $ 1895 "Else" "noBreak"
      $ 1896 "If b2_left_par"
      if (b2_left_par):
        $ 1897 "Comment"
        # Comment
        $ 1898 "a8_wv_distance≔a6_f_height_l-a5_f_hole[1]"
        global a8_wv_distance=a6_f_height_l-a5_f_hole[1]
        $ 1899 "Comment"
        # Comment
      else:
        $ 1900 "Else" "noBreak"
        $ 1901 "a8_wv_distance≔a6_f_height_r-a5_f_hole[1]"
        global a8_wv_distance=a6_f_height_r-a5_f_hole[1]
      end
    end
    $ 1902 "Ext fun & Squash"
    $ 1903 "If (A_sel_v≟A_VL1 or A_sel_v≟A_VL2) and (b1_cell_info_L≟B or b1_cell_info_L≟D)"
    if ((A_sel_v == A_VL1  or  A_sel_v == A_VL2)  and  (b1_cell_info_L == B  or  b1_cell_info_L == D)):
      $ 1904 "Scallup_check≔ True "
      global Scallup_check=  True  
    else:
      $ 1905 "ElseIf (A_sel_v≟A_VR1 or A_sel_v≟A_VR2) and (b1_cell_info_R≟B or b1_cell_info_R≟D)"
      if ((A_sel_v == A_VR1  or  A_sel_v == A_VR2)  and  (b1_cell_info_R == B  or  b1_cell_info_R == D)):
        $ 1906 "Scallup_check≔ True "
        global Scallup_check=  True  
      else:
        $ 1907 "Else" "noBreak"
        $ 1908 "Scallup_check≔ False "
        global Scallup_check=  False  
      end
    end
    $ 1909 "If (EXT_flag1[7]≟ True ) and (A_sel_v≠A_HOR) and (A_sel_v≠A_VL2) and (A_sel_v≠A_VR2) and (Scallup_check≟ False )"
    if ((EXT_flag1[7] ==   True  )  and  (A_sel_v != A_HOR)  and  (A_sel_v != A_VL2)  and  (A_sel_v != A_VR2)  and  (Scallup_check ==   False  )):
      $ 1910 "squash"
      $ 1911 "squash_enable≔1"
      global squash_enable=1
      $ 1912 "squash_voltage≔24.5"
      global squash_voltage=24.5
      $ 1913 "squash_current≔190"
      global squash_current=190
      $ 1914 "squash_amp≔7"
      global squash_amp=7
      $ 1915 "squash_speed≔10"
      global squash_speed=10
      $ 1916 "squash_cycle≔8"
      global squash_cycle=8
    else:
      $ 1917 "Else" "noBreak"
      $ 1918 "squash"
      $ 1919 "squash_enable≔0"
      global squash_enable=0
      $ 1920 "squash_voltage≔0"
      global squash_voltage=0
      $ 1921 "squash_current≔0"
      global squash_current=0
      $ 1922 "squash_amp≔0"
      global squash_amp=0
      $ 1923 "squash_speed≔0"
      global squash_speed=0
      $ 1924 "squash_cycle≔0"
      global squash_cycle=0
    end
    $ 1925 "waste_cycle≔2"
    global waste_cycle=2
    $ 1926 "c0_offset_x≔read_port_register(229)/10"
    global c0_offset_x= read_port_register (229)/10
    $ 1927 "c0_offset_z≔read_port_register(230)/10"
    global c0_offset_z= read_port_register (230)/10
    $ 1928 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
    global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
    $ 1929 "WV_gap"
    $ 1930 "c5_wv_gap_y≔a3_wv_amplitude"
    global c5_wv_gap_y=a3_wv_amplitude
    $ 1931 "c6_wv_gap_cpm≔a2_speed_cpm"
    global c6_wv_gap_cpm=a2_speed_cpm
    $ 1932 "c9_wv_gap_freq≔a4_wv_frequency"
    global c9_wv_gap_freq=a4_wv_frequency
    $ 1933 "If c6_wv_gap_cpm≟a2_speed_cpm and a3_wv_amplitude≟c5_wv_gap_y"
    if (c6_wv_gap_cpm == a2_speed_cpm  and  a3_wv_amplitude == c5_wv_gap_y):
      $ 1934 "c4_gap_enable≔0"
      global c4_gap_enable=0
    else:
      $ 1935 "Else" "noBreak"
      $ 1936 "c4_gap_enable≔1"
      global c4_gap_enable=1
    end
    $ 1937 "c4_gap_enable≔0"
    global c4_gap_enable=0
    $ 1938 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
    global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
    $ 1939 "arc_sen"
    $ 1940 "c3_X_p_gain≔read_port_register(186)/10"
    global c3_X_p_gain= read_port_register (186)/10
    $ 1941 "c3_X_i_gain≔read_port_register(187)/10"
    global c3_X_i_gain= read_port_register (187)/10
    $ 1942 "c3_Z_p_gain≔read_port_register(184)/10"
    global c3_Z_p_gain= read_port_register (184)/10
    $ 1943 "c3_Z_i_gain≔read_port_register(185)/10"
    global c3_Z_i_gain= read_port_register (185)/10
    $ 1944 "c3_wv_arc_fix≔0"
    global c3_wv_arc_fix=0
    $ 1945 "c3_wv_arc≔[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]"
    global c3_wv_arc=[c3_arc_enable,c3_X_p_gain,c3_X_i_gain,c3_Z_p_gain,c3_Z_i_gain,c3_wv_arc_fix]
    $ 1946 "volt and current"
    $ 1947 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
    set_current_voltage(a1_amp_ref,a0_volt_ref)
    $ 1948 "write_port_register(154,1)"
    write_port_register(154,1)
    $ 1950 "write_port_register(154,0)"
    write_port_register(154,0)
  end
  def Move_done():
    $ 1951 "Move_done" "noBreak"
    $ 1952 "write_port_register(robot_move_163,0)"
    write_port_register(robot_move_163,0)
    $ 1953 "write_port_register(robot_pose_164,0)"
    write_port_register(robot_pose_164,0)
    $ 1954 "write_port_register(robot_ready_141,1)"
    write_port_register(robot_ready_141,1)
  end
  def MoveFun():
    $ 1955 "MoveFun" "noBreak"
    $ 1956 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1957 "MoveL"
    $ 1958 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
  end
  def MoveFun_cd():
    $ 1959 "MoveFun_cd" "noBreak"
    $ 1960 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1961 "If A_sel_v≟A_VR2 and (b1_cell_info_R≟c or b1_cell_info_R≟d)"
    if (A_sel_v == A_VR2  and  (b1_cell_info_R == c  or  b1_cell_info_R == d)):
      $ 1962 "tilt_deg≔27"
      global tilt_deg=27
      $ 1963 "tilt_deg_ry≔19"
      global tilt_deg_ry=19
      $ 1964 "tilt_deg_rz≔0"
      global tilt_deg_rz=0
    else:
      $ 1965 "Else" "noBreak"
      $ 1966 "tilt_deg≔10"
      global tilt_deg=10
      $ 1967 "tilt_deg_ry≔5"
      global tilt_deg_ry=5
      $ 1968 "tilt_deg_rz≔0"
      global tilt_deg_rz=0
    end
    $ 1969 "If b2_left_par"
    if (b2_left_par):
      $ 1970 "b_touch_pos≔pose_add(b_touch_pos, p[0,18/1000,0,0,0,0])"
      global b_touch_pos= pose_add (b_touch_pos, p[0,18/1000,0,0,0,0])
      $ 1971 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0,0,d2r(-tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0,0,d2r(-tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 1972 "Else" "noBreak"
      $ 1973 "b_touch_pos≔pose_add(b_touch_pos, p[0,-18/1000,0,0,0,0])"
      global b_touch_pos= pose_add (b_touch_pos, p[0,-18/1000,0,0,0,0])
      $ 1974 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
    end
    $ 1975 "MoveL"
    $ 1976 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
  end
  def MoveandTouchFun_2f():
    $ 1977 "MoveandTouchFun_2f" "noBreak"
    $ 1978 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 1979 "tilt_deg≔3"
    global tilt_deg=3
    $ 1980 "tilt_deg_ry≔3"
    global tilt_deg_ry=3
    $ 1981 "tilt_deg_rz≔0"
    global tilt_deg_rz=0
    $ 1982 "If  False "
    if (  False  ):
      $ 1983 "Wait: 0.01"
      sleep(0.01)
    else:
      $ 1984 "ElseIf A_sel_v≟A_HOR and b1_cell_info_L≟E"
      if (A_sel_v == A_HOR  and  b1_cell_info_L == E):
        $ 1985 "tilt_deg≔6"
        global tilt_deg=6
        $ 1986 "tilt_deg_ry≔-5"
        global tilt_deg_ry=-5
        $ 1987 "tilt_deg_rz≔0"
        global tilt_deg_rz=0
        $ 1988 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
        global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
      else:
        $ 1989 "ElseIf A_sel_v≟A_HOR_R and b1_cell_info_R≟E"
        if (A_sel_v == A_HOR_R  and  b1_cell_info_R == E):
          $ 1990 "tilt_deg≔6"
          global tilt_deg=6
          $ 1991 "tilt_deg_ry≔-5"
          global tilt_deg_ry=-5
          $ 1992 "tilt_deg_rz≔0"
          global tilt_deg_rz=0
          $ 1993 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
          global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
        else:
          $ 1994 "ElseIf b2_left_par"
          if (b2_left_par):
            $ 1995 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
            global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
          else:
            $ 1996 "Else" "noBreak"
            $ 1997 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
            global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
          end
        end
      end
    end
    $ 1998 "MoveL"
    $ 1999 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
    $ 2000 "Touch_2f"
    $ 2001 "If  False "
    if (  False  ):
      $ 2002 "Wait: 0.01"
      sleep(0.01)
    else:
      $ 2003 "ElseIf A_sel_v≟A_HOR and b1_cell_info_L≟E"
      if (A_sel_v == A_HOR  and  b1_cell_info_L == E):
        $ 2004 "tilt_deg≔3"
        global tilt_deg=3
        $ 2005 "tilt_deg_ry≔3"
        global tilt_deg_ry=3
        $ 2006 "tilt_deg_rz≔0"
        global tilt_deg_rz=0
        $ 2007 "b_touch_pos2≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])"
        global b_touch_pos2= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(tilt_deg_rz)])
        $ 2008 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)"
        global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)
      else:
        $ 2009 "ElseIf A_sel_v≟A_HOR_R and b1_cell_info_R≟E"
        if (A_sel_v == A_HOR_R  and  b1_cell_info_R == E):
          $ 2010 "tilt_deg≔3"
          global tilt_deg=3
          $ 2011 "tilt_deg_ry≔3"
          global tilt_deg_ry=3
          $ 2012 "tilt_deg_rz≔0"
          global tilt_deg_rz=0
          $ 2013 "b_touch_pos2≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])"
          global b_touch_pos2= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(-tilt_deg_ry),d2r(-tilt_deg_rz)])
          $ 2014 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)"
          global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos2,b2_left_par,b9_touch_sens)
        else:
          $ 2015 "Else" "noBreak"
          $ 2016 "touch_result≔touch_fun_2f(b_touch_pos,b_touch_pos,b2_left_par,b9_touch_sens)"
          global touch_result=touch_fun_2f(b_touch_pos,b_touch_pos,b2_left_par,b9_touch_sens)
        end
      end
    end
    $ 2018 "If b2_left_par"
    if (b2_left_par):
      $ 2019 "touch_result≔feature_offset(touch_result,p[0,(Touch_dis)/1000,0,0,0,0],center_line)"
      global touch_result=feature_offset(touch_result,p[0,(Touch_dis)/1000,0,0,0,0],center_line)
    else:
      $ 2021 "Else" "noBreak"
      $ 2022 "touch_result≔feature_offset(touch_result,p[0,(-Touch_dis)/1000,0,0,0,0],center_line)"
      global touch_result=feature_offset(touch_result,p[0,(-Touch_dis)/1000,0,0,0,0],center_line)
    end
    $ 2024 "A_Touch_p[A_sel_v]=touch_result"
    A_Touch_p[A_sel_v]=touch_result
    $ 2025 "If EXT_flag1[3]≟ True "
    if (EXT_flag1[3] ==   True  ):
      $ 2026 "MoveL"
      $ 2027 "manual_tp≔tilt_2f_fun(touch_result,basic_tilt_2f,wv_direction)"
      global manual_tp=tilt_2f_fun(touch_result,basic_tilt_2f,wv_direction)
      $ 2028 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
      global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
      $ 2029 "manual_tp" "breakAfter"
      movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
      $ 2030 "Wait: 1.5"
      sleep(1.5)
    end
  end
  def MoveandTouchFun_3f():
    $ 2031 "MoveandTouchFun_3f" "noBreak"
    $ 2032 "b_touch_pos≔A_Prepos_l[A_sel_v]"
    global b_touch_pos=A_Prepos_l[A_sel_v]
    $ 2033 "tilt_deg_ry≔0"
    global tilt_deg_ry=0
    $ 2034 "tilt_deg_rz≔0"
    global tilt_deg_rz=0
    $ 2035 "If b2_left_par"
    if (b2_left_par):
      $ 2036 "tilt_deg≔6"
      global tilt_deg=6
      $ 2037 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])
    else:
      $ 2038 "Else" "noBreak"
      $ 2039 "tilt_deg≔0.5"
      global tilt_deg=0.5
      $ 2040 "b_touch_pos≔pose_trans(b_touch_pos, p[0,0/1000,0,d2r(-tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])"
      global b_touch_pos= pose_trans (b_touch_pos, p[0,0/1000,0,d2r(-tilt_deg),d2r(tilt_deg_ry),d2r(tilt_deg_rz)])
    end
    $ 2051 "move_pre"
    $ 2052 "If (b2_left_par≟ True  and point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032) or (b2_left_par≟ False  and point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)"
    if ((b2_left_par ==   True    and  point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032)  or  (b2_left_par ==   False    and  point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)):
      $ 2053 "if move from home"
      $ 2054 "j_cp≔get_actual_joint_positions()"
      global j_cp= get_actual_joint_positions ()
      $ 2055 "If b2_left_par"
      if (b2_left_par):
        $ 2056 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 2057 "inner_p≔p[-15/1000,-35/1000,0,0,0,0]"
          global inner_p=p[-15/1000,-35/1000,0,0,0,0]
        else:
          $ 2058 "Else" "noBreak"
          $ 2059 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 2060 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=left_j)"
        global j_tp= get_inverse_kin (pose_add(b_touch_pos,inner_p),qnear=left_j)
      else:
        $ 2061 "Else" "noBreak"
        $ 2062 "If norm(b_touch_pos[1]*1000)>300"
        if (norm(b_touch_pos[1]*1000)>300):
          $ 2063 "inner_p≔p[-15/1000,35/1000,0,0,0,0]"
          global inner_p=p[-15/1000,35/1000,0,0,0,0]
        else:
          $ 2064 "Else" "noBreak"
          $ 2065 "inner_p≔p[0,0,0,0,0,0]"
          global inner_p=p[0,0,0,0,0,0]
        end
        $ 2066 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=right_j)"
        global j_tp= get_inverse_kin ( pose_add (b_touch_pos,inner_p),qnear=right_j)
      end
      $ 2067 "j_cp[0]=j_tp[0]"
      j_cp[0]=j_tp[0]
      $ 2068 "j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2"
      j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2
      $ 2069 "j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5"
      j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5
      $ 2070 "j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5"
      j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5
      $ 2071 "j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3"
      j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3
      $ 2072 "j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1"
      j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1
      $ 2073 "MoveJ"
      $ 2074 "j_cp" "breakAfter"
      movej(j_cp, a=1.3962634015954636, v=1.0471975511965976)
      $ 2075 "j_tp≔[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]"
      global j_tp=[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]
    end
    $ 2078 "MoveL"
    $ 2079 "b_touch_pos" "breakAfter"
    movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
    $ 2082 "touch_3f_down"
    $ 2084 "touch_result≔touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens,b2_par_cd)"
    global touch_result=touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens,b2_par_cd)
    $ 2085 "If Scallup_check≟ False "
    if (Scallup_check ==   False  ):
      $ 2086 "touch_result≔pose_trans(touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])"
      global touch_result= pose_trans (touch_result,p[-(Touch_dis)/1000,0,0,0,0,0])
    else:
      $ 2087 "Else" "noBreak"
      $ 2088 "Scallup_check≔ False "
      global Scallup_check=  False  
    end
    $ 2091 "A_Touch_p[A_sel_v]=touch_result"
    A_Touch_p[A_sel_v]=touch_result
    $ 2092 "If EXT_flag1[3]≟ True "
    if (EXT_flag1[3] ==   True  ):
      $ 2093 "MoveL"
      $ 2094 "manual_tp≔tilt_3f_fun(A_Touch_p[A_sel_v],basic_tilt_3f,0)"
      global manual_tp=tilt_3f_fun(A_Touch_p[A_sel_v],basic_tilt_3f,0)
      $ 2095 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
      global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
      $ 2096 "manual_tp" "breakAfter"
      movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
      $ 2097 "Wait: 1.5"
      sleep(1.5)
    end
  end
  def weav_welding_3f():
    $ 2117 "weav_welding_3f" "noBreak"
    $ 2118 "If running_trig≟ True "
    global thread_flag_2118=0
    thread Thread_if_2118():
      $ 2119 "inv_inching(inv_inch_time)"
      inv_inching(inv_inch_time)
      $ 2120 "b_touch_pos≔A_Prepos_l[A_sel_v]"
      global b_touch_pos=A_Prepos_l[A_sel_v]
      $ 2121 "move_pre"
      $ 2122 "If (b2_left_par≟ True  and point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032) or (b2_left_par≟ False  and point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)"
      if ((b2_left_par ==   True    and  point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032)  or  (b2_left_par ==   False    and  point_dist(A_Prepos_l[A_HOR_R],A_Prepos_l[A_VR1])>0.032)):
        $ 2123 "if move from home"
        $ 2124 "j_cp≔get_actual_joint_positions()"
        global j_cp= get_actual_joint_positions ()
        $ 2125 "If b2_left_par"
        if (b2_left_par):
          $ 2126 "If norm(b_touch_pos[1]*1000)>300"
          if (norm(b_touch_pos[1]*1000)>300):
            $ 2127 "inner_p≔p[-15/1000,-35/1000,0,0,0,0]"
            global inner_p=p[-15/1000,-35/1000,0,0,0,0]
          else:
            $ 2128 "Else" "noBreak"
            $ 2129 "inner_p≔p[0,0,0,0,0,0]"
            global inner_p=p[0,0,0,0,0,0]
          end
          $ 2130 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=left_j)"
          global j_tp= get_inverse_kin (pose_add(b_touch_pos,inner_p),qnear=left_j)
        else:
          $ 2131 "Else" "noBreak"
          $ 2132 "If norm(b_touch_pos[1]*1000)>300"
          if (norm(b_touch_pos[1]*1000)>300):
            $ 2133 "inner_p≔p[-15/1000,35/1000,0,0,0,0]"
            global inner_p=p[-15/1000,35/1000,0,0,0,0]
          else:
            $ 2134 "Else" "noBreak"
            $ 2135 "inner_p≔p[0,0,0,0,0,0]"
            global inner_p=p[0,0,0,0,0,0]
          end
          $ 2136 "j_tp≔get_inverse_kin(pose_add(b_touch_pos,inner_p),qnear=right_j)"
          global j_tp= get_inverse_kin ( pose_add (b_touch_pos,inner_p),qnear=right_j)
        end
        $ 2137 "j_cp[0]=j_tp[0]"
        j_cp[0]=j_tp[0]
        $ 2138 "j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2"
        j_cp[1]=j_cp[1]+(j_tp[1]-j_cp[1])/2
        $ 2139 "j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5"
        j_cp[2]=j_cp[2]+(j_tp[2]-j_cp[2])/2.5
        $ 2140 "j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5"
        j_cp[3]=j_cp[3]+(j_tp[3]-j_cp[3])/2.5
        $ 2141 "j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3"
        j_cp[4]=j_cp[4]+(j_tp[4]-j_cp[4])/3
        $ 2142 "j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1"
        j_cp[5]=j_cp[5]+(j_tp[5]-j_cp[5])/1
        $ 2143 "MoveJ"
        $ 2144 "j_cp" "breakAfter"
        movej(j_cp, a=1.3962634015954636, v=1.0471975511965976)
        $ 2145 "j_tp≔[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]"
        global j_tp=[j_cp[0],j_cp[1],j_cp[2],j_cp[3],j_tp[4],j_tp[5]]
      end
      $ 2148 "If (b2_left_par≟ True ) and (b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c) and (A_sel_v≠A_VL2)"
      if ((b2_left_par ==   True  )  and  (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c)  and  (A_sel_v != A_VL2)):
        $ 2149 "begin_3f_p≔pose_trans(A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])"
        global begin_3f_p= pose_trans (A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])
      else:
        $ 2150 "ElseIf (b2_left_par≟ False ) and (b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c) and (A_sel_v≠A_VR2)"
        if ((b2_left_par ==   False  )  and  (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c)  and  (A_sel_v != A_VR2)):
          $ 2151 "begin_3f_p≔pose_trans(A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])"
          global begin_3f_p= pose_trans (A_Touch_p[A_sel_v],p[(multi_offset_z*(multi_path-1))/1000,0,0,0,0,0])
        else:
          $ 2152 "Else" "noBreak"
          $ 2153 "begin_3f_p≔A_Touch_p[A_sel_v]"
          global begin_3f_p=A_Touch_p[A_sel_v]
        end
      end
      $ 2154 "If b2_left_par≟ False "
      if (b2_left_par ==   False  ):
        $ 2155 "If (b1_cell_info_R≟c or b1_cell_info_R≟d) and A_sel_v≟A_VR2"
        if ((b1_cell_info_R == c  or  b1_cell_info_R == d)  and  A_sel_v == A_VR2):
          $ 2157 "b7_tilt_degree≔[-72,-20,15]"
          global b7_tilt_degree=[-72,-20,15]
          $ 2158 "begin_3f_p=pose_add(begin_3f_p,p[-6/1000,-1.5/1000,0,0,0,0])"
          begin_3f_p= pose_add (begin_3f_p,p[-6/1000,-1.5/1000,0,0,0,0])
          $ 2159 "a2_speed_cpm≔a2_speed_cpm*1"
          global a2_speed_cpm=a2_speed_cpm*1
          $ 2160 "a3_wv_amplitude≔a3_wv_amplitude*1"
          global a3_wv_amplitude=a3_wv_amplitude*1
          $ 2161 "a4_wv_frequency≔a4_wv_frequency*1"
          global a4_wv_frequency=a4_wv_frequency*1
          $ 2162 "b3_dealy_all≔[0,b4_wv_delay2*1,0,b6_wv_delay4*1]"
          global b3_dealy_all=[0,b4_wv_delay2*1,0,b6_wv_delay4*1]
          $ 2163 "a0_volt_ref≔a0_volt_ref*1"
          global a0_volt_ref=a0_volt_ref*1
          $ 2164 "a1_amp_ref≔a1_amp_ref*1"
          global a1_amp_ref=a1_amp_ref*1
          $ 2165 "volt and current"
          $ 2166 "squash_l≔[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]"
          global squash_l=[a0_volt_ref,a1_amp_ref,squash_enable,squash_voltage,squash_current,squash_amp,squash_speed,squash_cycle,waste_cycle,c0_offset_x,c0_offset_z]
          $ 2167 "set_current_voltage(a1_amp_ref,a0_volt_ref)"
          set_current_voltage(a1_amp_ref,a0_volt_ref)
        end
      end
      $ 2176 "welding_result = line_weaving_tp(begin_3f_p,A_Touch_p[A_sel_v_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
      welding_result = line_weaving_tp(begin_3f_p,A_Touch_p[A_sel_v_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
      thread_flag_2118 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2118=run Thread_if_2118()
      while (thread_flag_2118 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2118
          thread_flag_2118 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2118 = 2
    end
    $ 2177 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2178 "homeing()"
    homeing()
    $ 2179 "If sludge≟1"
    if (sludge == 1):
      $ 2180 "pause_trig≔ True "
      global pause_trig=  True  
    end
  end
  def weav_welding_2f():
    $ 2181 "weav_welding_2f" "noBreak"
    $ 2182 "If running_trig≟ True "
    global thread_flag_2182=0
    thread Thread_if_2182():
      $ 2183 "Calculation"
      $ 2184 "If Auto_W_num[Auto_cur_cell]≟31 or Auto_W_num[Auto_cur_cell]≟32 or Auto_W_num[Auto_cur_cell]≟30"
      if (Auto_W_num[Auto_cur_cell] == 31  or  Auto_W_num[Auto_cur_cell] == 32  or  Auto_W_num[Auto_cur_cell] == 30):
        $ 2185 "cal_single"
        $ 2186 "pos_m_path≔A_Touch_p[A_HOR]"
        global pos_m_path=A_Touch_p[A_HOR]
        $ 2187 "pos_m_path_end≔A_Touch_p[A_HOR_R]"
        global pos_m_path_end=A_Touch_p[A_HOR_R]
        $ 2188 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2189 "A_middle_weld[2]=A_touch_bottom[2]"
        A_middle_weld[2]=A_touch_bottom[2]
        $ 2190 "A_middle_weld≔p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]"
        global A_middle_weld=p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]
      else:
        $ 2191 "Else" "noBreak"
        $ 2193 "side_offset≔0"
        global side_offset=0
        $ 2194 "If current_path≟2 or current_path≟4"
        if (current_path == 2  or  current_path == 4):
          $ 2196 "center_offset≔0"
          global center_offset=0
        else:
          $ 2197 "Else" "noBreak"
          $ 2198 "center_offset≔0"
          global center_offset=0
        end
        $ 2199 "cal_multi"
        $ 2200 "pos_m_path≔A_Touch_p[A_HOR]"
        global pos_m_path=A_Touch_p[A_HOR]
        $ 2202 "pos_m_path_end≔A_Touch_p[A_HOR_R]"
        global pos_m_path_end=A_Touch_p[A_HOR_R]
        $ 2204 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2205 "A_middle_weld[2]=A_touch_bottom[2]"
        A_middle_weld[2]=A_touch_bottom[2]
        $ 2207 "A_middle_weld≔p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]"
        global A_middle_weld=p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]
      end
      $ 2208 "gap_half"
      $ 2209 "gap_amp_bak≔c5_wv_gap_y"
      global gap_amp_bak=c5_wv_gap_y
      $ 2210 "gap_speed_bak≔c6_wv_gap_cpm"
      global gap_speed_bak=c6_wv_gap_cpm
      $ 2211 "gap_freq_bak≔c9_wv_gap_freq"
      global gap_freq_bak=c9_wv_gap_freq
      $ 2212 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
      global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
      $ 2213 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
      global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
      $ 2214 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
      global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
      $ 2215 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
      global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
      $ 2216 "Weaving"
      $ 2217 "If EXT_flag1[6]"
      if (EXT_flag1[6]):
        $ 2218 "If Auto_W_num[Auto_cur_cell]%10≟1"
        if (Auto_W_num[Auto_cur_cell]%10 == 1):
          $ 2219 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2220 "wv_direction≔1"
          global wv_direction=1
          $ 2222 "step_2f≔1"
          global step_2f=1
          $ 2223 "welding_result = line_weaving_tp(A_middle_weld,pos_m_path,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(A_middle_weld,pos_m_path,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          $ 2225 "Wait: 0.5"
          sleep(0.5)
        end
        $ 2226 "If Auto_W_num[Auto_cur_cell]%10≟2"
        if (Auto_W_num[Auto_cur_cell]%10 == 2):
          $ 2227 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2228 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
          global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
          $ 2229 "gap_half_right"
          $ 2230 "a3_wv_amplitude≔gap_amp_bak"
          global a3_wv_amplitude=gap_amp_bak
          $ 2231 "a2_speed_cpm≔gap_speed_bak"
          global a2_speed_cpm=gap_speed_bak
          $ 2232 "a4_wv_frequency≔gap_freq_bak"
          global a4_wv_frequency=gap_freq_bak
          $ 2233 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
          global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
          $ 2234 "wv_direction≔-1"
          global wv_direction=-1
          $ 2236 "step_2f≔2"
          global step_2f=2
          $ 2238 "welding_result = line_weaving_tp(A_middle_weld,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(A_middle_weld,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
        end
      else:
        $ 2240 "Else" "noBreak"
        $ 2241 "If Auto_W_num[Auto_cur_cell]%10≟0"
        if (Auto_W_num[Auto_cur_cell]%10 == 0):
          $ 2242 "inv_inching(inv_inch_time)"
          inv_inching(inv_inch_time)
          $ 2243 "wv_direction≔1"
          global wv_direction=1
          $ 2244 "step_2f≔1"
          global step_2f=1
          $ 2245 "welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
          welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
        else:
          $ 2246 "Else" "noBreak"
          $ 2247 "write_port_register(142,142)"
          write_port_register(142,142)
          $ 2248 "Halt"
          halt
        end
      end
      thread_flag_2182 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2182=run Thread_if_2182()
      while (thread_flag_2182 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2182
          thread_flag_2182 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2182 = 2
    end
    $ 2249 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2250 "MoveL"
    $ 2251 "Direction: Tool Z-"
    global move_thread_flag_2251=0
    thread move_thread_2251():
      enter_critical
      move_thread_flag_2251 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.03)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_2251 = 2
      exit_critical
    end
    move_thread_flag_2251 = 0
    move_thread_han_2251 = run move_thread_2251()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_2251 > 1):
        join move_thread_han_2251
        $ 2252 "Until (distance)"
        break
      end
      sync()
    end
    $ 2253 "homeing()"
    homeing()
    $ 2254 "If sludge≟1 or (sludge≟2 and current_path>1)"
    if (sludge == 1  or  (sludge == 2  and  current_path>1)):
      $ 2255 "If  not (Auto_W_num[Auto_cur_cell]%10≟1)"
      if (  not  (Auto_W_num[Auto_cur_cell]%10 == 1)):
        $ 2256 "pause_trig≔ True "
        global pause_trig=  True  
      end
    end
  end
  def weav_welding_2f_CD():
    $ 2257 "weav_welding_2f_CD" "noBreak"
    $ 2258 "If running_trig≟ True "
    global thread_flag_2258=0
    thread Thread_if_2258():
      $ 2259 "CD_calculation"
      $ 2260 "If (Auto_W_num[Auto_cur_cell]≥100 and Auto_W_num[Auto_cur_cell]<106)  or (Auto_W_num[Auto_cur_cell]≥150 and Auto_W_num[Auto_cur_cell]<156)"
      if ((Auto_W_num[Auto_cur_cell] >= 100  and  Auto_W_num[Auto_cur_cell]<106)   or  (Auto_W_num[Auto_cur_cell] >= 150  and  Auto_W_num[Auto_cur_cell]<156)):
        $ 2261 "cal single"
        $ 2262 "cal_1"
        $ 2263 "pos_m_path_cd≔A_Touch_p[A_sel_v]"
        global pos_m_path_cd=A_Touch_p[A_sel_v]
        $ 2264 "pos_m_p_end_cd≔A_Touch_p[A_sel_v_end]"
        global pos_m_p_end_cd=A_Touch_p[A_sel_v_end]
        $ 2265 "cal_2"
        $ 2266 "pos_m_path≔A_Touch_p[A_sel_v2]"
        global pos_m_path=A_Touch_p[A_sel_v2]
        $ 2267 "pos_m_path_end≔A_Touch_p[A_sel_v_end2]"
        global pos_m_path_end=A_Touch_p[A_sel_v_end2]
        $ 2268 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2269 "A_middle_weld[2]=A_touch_bottom[2]"
        A_middle_weld[2]=A_touch_bottom[2]
        $ 2270 "A_middle_weld≔p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]"
        global A_middle_weld=p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]
      else:
        $ 2271 "Else" "noBreak"
        $ 2272 "cal multi"
        $ 2273 "side_offset≔0"
        global side_offset=0
        $ 2274 "If current_path≟2 or current_path≟4"
        if (current_path == 2  or  current_path == 4):
          $ 2276 "center_offset≔0"
          global center_offset=0
        else:
          $ 2277 "Else" "noBreak"
          $ 2278 "center_offset≔0"
          global center_offset=0
        end
        $ 2279 "cal_1_multi"
        $ 2280 "pos_m_path_cd≔A_Touch_p[A_sel_v]"
        global pos_m_path_cd=A_Touch_p[A_sel_v]
        $ 2282 "pos_m_p_end_cd≔A_Touch_p[A_sel_v_end]"
        global pos_m_p_end_cd=A_Touch_p[A_sel_v_end]
        $ 2284 "cal_2_multi"
        $ 2285 "pos_m_path≔A_Touch_p[A_sel_v2]"
        global pos_m_path=A_Touch_p[A_sel_v2]
        $ 2287 "pos_m_path_end≔A_Touch_p[A_sel_v_end2]"
        global pos_m_path_end=A_Touch_p[A_sel_v_end2]
        $ 2289 "A_middle_weld≔interpolate_pose(pos_m_path, pos_m_path_end,0.5)"
        global A_middle_weld= interpolate_pose (pos_m_path, pos_m_path_end,0.5)
        $ 2290 "A_middle_weld[2]=A_touch_bottom[2]"
        A_middle_weld[2]=A_touch_bottom[2]
        $ 2292 "A_middle_weld≔p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]"
        global A_middle_weld=p[A_middle_weld[0],A_middle_weld[1],A_middle_weld[2],pos_m_path[3],pos_m_path[4],pos_m_path[5]]
      end
      $ 2293 "gap_half"
      $ 2294 "gap_amp_bak≔c5_wv_gap_y"
      global gap_amp_bak=c5_wv_gap_y
      $ 2295 "gap_speed_bak≔c6_wv_gap_cpm"
      global gap_speed_bak=c6_wv_gap_cpm
      $ 2296 "gap_freq_bak≔c9_wv_gap_freq"
      global gap_freq_bak=c9_wv_gap_freq
      $ 2297 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
      global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
      $ 2298 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
      global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
      $ 2299 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
      global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
      $ 2300 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
      global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
      $ 2301 "If EXT_flag1[4]≟ True  and (b1_cell_info_L≠c and b1_cell_info_L≠d and b1_cell_info_R≠c and b1_cell_info_R≠d)"
      if (EXT_flag1[4] ==   True    and  (b1_cell_info_L != c  and  b1_cell_info_L != d  and  b1_cell_info_R != c  and  b1_cell_info_R != d)):
        $ 2302 "If EXT_flag1[6]"
        if (EXT_flag1[6]):
          $ 2303 "If Auto_W_num[Auto_cur_cell]%10≟1"
          if (Auto_W_num[Auto_cur_cell]%10 == 1):
            $ 2304 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2305 "step_2f≔1"
            global step_2f=1
            $ 2306 "welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,A_middle_weld],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,A_middle_weld],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
          $ 2307 "If Auto_W_num[Auto_cur_cell]%10≟4"
          if (Auto_W_num[Auto_cur_cell]%10 == 4):
            $ 2308 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2309 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
            global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
            $ 2310 "gap_half"
            $ 2311 "a3_wv_amplitude≔gap_amp_bak"
            global a3_wv_amplitude=gap_amp_bak
            $ 2312 "a2_speed_cpm≔gap_speed_bak"
            global a2_speed_cpm=gap_speed_bak
            $ 2313 "a4_wv_frequency≔gap_freq_bak"
            global a4_wv_frequency=gap_freq_bak
            $ 2314 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2315 "step_2f≔2"
            global step_2f=2
            $ 2316 "wv_direction≔-1*wv_direction"
            global wv_direction=-1*wv_direction
            $ 2318 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
        else:
          $ 2319 "Else" "noBreak"
          $ 2320 "If Auto_W_num[Auto_cur_cell]%10≟0"
          if (Auto_W_num[Auto_cur_cell]%10 == 0):
            $ 2321 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2322 "step_2f≔1"
            global step_2f=1
            $ 2323 "welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,pos_m_path_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp_l(pos_m_path_cd,[pos_m_p_end_cd,pos_m_path,pos_m_path_end],[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          else:
            $ 2324 "Else" "noBreak"
            $ 2325 "write_port_register(142,142)"
            write_port_register(142,142)
            $ 2326 "Halt"
            halt
          end
        end
      else:
        $ 2327 "Else" "noBreak"
        $ 2328 "If EXT_flag1[6]"
        if (EXT_flag1[6]):
          $ 2329 "If Auto_W_num[Auto_cur_cell]%10≟2"
          if (Auto_W_num[Auto_cur_cell]%10 == 2):
            $ 2330 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2331 "step_2f≔1"
            global step_2f=1
            $ 2332 "gap_half"
            $ 2333 "gap_amp_bak≔c5_wv_gap_y"
            global gap_amp_bak=c5_wv_gap_y
            $ 2334 "gap_speed_bak≔c6_wv_gap_cpm"
            global gap_speed_bak=c6_wv_gap_cpm
            $ 2335 "gap_freq_bak≔c9_wv_gap_freq"
            global gap_freq_bak=c9_wv_gap_freq
            $ 2336 "c5_wv_gap_y≔(a3_wv_amplitude+c5_wv_gap_y)/2"
            global c5_wv_gap_y=(a3_wv_amplitude+c5_wv_gap_y)/2
            $ 2337 "c6_wv_gap_cpm≔(a2_speed_cpm+c6_wv_gap_cpm)/2"
            global c6_wv_gap_cpm=(a2_speed_cpm+c6_wv_gap_cpm)/2
            $ 2338 "c9_wv_gap_freq≔(a4_wv_frequency+c9_wv_gap_freq)/2"
            global c9_wv_gap_freq=(a4_wv_frequency+c9_wv_gap_freq)/2
            $ 2339 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2340 "welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2341 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2342 "If Auto_W_num[Auto_cur_cell]%10≟3"
          if (Auto_W_num[Auto_cur_cell]%10 == 3):
            $ 2343 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2344 "step_2f≔2"
            global step_2f=2
            $ 2345 "welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2346 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2347 "If Auto_W_num[Auto_cur_cell]%10≟4"
          if (Auto_W_num[Auto_cur_cell]%10 == 4):
            $ 2348 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2349 "a7_weld_crater≔[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]"
            global a7_weld_crater=[d_start_current,d_start_voltage,d_start_time,d_end_current_2,d_end_voltage_2,d_end_time_2,d_lean_degree]
            $ 2350 "step_2f≔3"
            global step_2f=3
            $ 2351 "gap_half"
            $ 2352 "a3_wv_amplitude≔gap_amp_bak"
            global a3_wv_amplitude=gap_amp_bak
            $ 2353 "a2_speed_cpm≔gap_speed_bak"
            global a2_speed_cpm=gap_speed_bak
            $ 2354 "a4_wv_frequency≔gap_freq_bak"
            global a4_wv_frequency=gap_freq_bak
            $ 2355 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2356 "wv_direction≔-1*wv_direction"
            global wv_direction=-1*wv_direction
            $ 2358 "welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_end,A_middle_weld,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
          end
        else:
          $ 2359 "Else" "noBreak"
          $ 2360 "If Auto_W_num[Auto_cur_cell]%10≟2"
          if (Auto_W_num[Auto_cur_cell]%10 == 2):
            $ 2361 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2362 "step_2f≔1"
            global step_2f=1
            $ 2363 "c7_wv_gap≔[0,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[0,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2364 "welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path_cd,pos_m_p_end_cd,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2365 "Wait: 0.5"
            sleep(0.5)
          end
          $ 2366 "If Auto_W_num[Auto_cur_cell]%10≟5"
          if (Auto_W_num[Auto_cur_cell]%10 == 5):
            $ 2367 "inv_inching(inv_inch_time)"
            inv_inching(inv_inch_time)
            $ 2368 "step_2f≔2"
            global step_2f=2
            $ 2369 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
            global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
            $ 2370 "welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)"
            welding_result = line_weaving_tp(pos_m_path,pos_m_path_end,[a8_wv_distance,Circle_Speed,b1_appro_param,a4_wv_frequency,a3_wv_amplitude,b8_wv_type,wv_direction,current_path,c8_arc_cur_offs],b7_tilt_degree,b3_dealy_all,a9_wv_weldingon,c3_wv_arc,c7_wv_gap,a5_f_hole,b8_wv_2f,a7_weld_crater,squash_l)
            $ 2371 "Wait: 0.5"
            sleep(0.5)
          end
        end
      end
      thread_flag_2258 = 1
    end
    if (running_trig ==   True  ):
      global thread_handler_2258=run Thread_if_2258()
      while (thread_flag_2258 == 0):
        if not(running_trig ==   True  ):
          kill thread_handler_2258
          thread_flag_2258 = 2
        else:
          sync()
        end
      end
    else:
      thread_flag_2258 = 2
    end
    $ 2372 "write_port_register(weld_done_137,1)"
    write_port_register(weld_done_137,1)
    $ 2376 "wv_direction≔1"
    global wv_direction=1
    $ 2377 "If Auto_W_num[Auto_cur_cell]≥150"
    if (Auto_W_num[Auto_cur_cell] >= 150):
      $ 2378 "MoveL"
      $ 2379 "Direction: Base"
      global move_thread_flag_2379=0
      thread move_thread_2379():
        enter_critical
        move_thread_flag_2379 = 1
        local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,1,0.0], 0.03)
        movel(towardsPos, a=0.2, v=0.05)
        move_thread_flag_2379 = 2
        exit_critical
      end
      move_thread_flag_2379 = 0
      move_thread_han_2379 = run move_thread_2379()
      while (True):
        sleep(1.0E-10)
        if (move_thread_flag_2379 > 1):
          join move_thread_han_2379
          $ 2380 "Until (distance)"
          break
        end
        sync()
      end
    else:
      $ 2381 "ElseIf Auto_W_num[Auto_cur_cell]≥100"
      if (Auto_W_num[Auto_cur_cell] >= 100):
        $ 2382 "MoveL"
        $ 2383 "Direction: Base"
        global move_thread_flag_2383=0
        thread move_thread_2383():
          enter_critical
          move_thread_flag_2383 = 1
          local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1,0.0], 0.03)
          movel(towardsPos, a=0.2, v=0.05)
          move_thread_flag_2383 = 2
          exit_critical
        end
        move_thread_flag_2383 = 0
        move_thread_han_2383 = run move_thread_2383()
        while (True):
          sleep(1.0E-10)
          if (move_thread_flag_2383 > 1):
            join move_thread_han_2383
            $ 2384 "Until (distance)"
            break
          end
          sync()
        end
      end
    end
    $ 2385 "MoveL"
    $ 2386 "Direction: Tool Z-"
    global move_thread_flag_2386=0
    thread move_thread_2386():
      enter_critical
      move_thread_flag_2386 = 1
      local towardsPos=calculate_point_to_move_towards(get_forward_kin(), [0.0,0.0,-1.0], 0.03)
      movel(towardsPos, a=1.2, v=0.25)
      move_thread_flag_2386 = 2
      exit_critical
    end
    move_thread_flag_2386 = 0
    move_thread_han_2386 = run move_thread_2386()
    while (True):
      sleep(1.0E-10)
      if (move_thread_flag_2386 > 1):
        join move_thread_han_2386
        $ 2387 "Until (distance)"
        break
      end
      sync()
    end
    $ 2388 "homeing()"
    homeing()
    $ 2389 "If sludge≟1 or (sludge≟2 and current_path>1)"
    if (sludge == 1  or  (sludge == 2  and  current_path>1)):
      $ 2390 "If  not (Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2 or Auto_W_num[Auto_cur_cell]%10≟3)"
      if (  not  (Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2  or  Auto_W_num[Auto_cur_cell]%10 == 3)):
        $ 2391 "pause_trig≔ True "
        global pause_trig=  True  
      end
    end
  end
  def reset_weld_param():
    $ 2392 "reset_weld_param" "noBreak"
    $ 2393 "start_num≔225"
    global start_num=225
    $ 2394 "Loop start_num<237"
    while (start_num<237):
      $ 2395 "write_port_register(start_num,0)"
      write_port_register(start_num,0)
      $ 2396 "start_num≔start_num+1"
      global start_num=start_num+1
    end
    $ 2397 "start_num≔240"
    global start_num=240
    $ 2398 "Loop start_num<256"
    while (start_num<256):
      $ 2399 "write_port_register(start_num,0)"
      write_port_register(start_num,0)
      $ 2400 "start_num≔start_num+1"
      global start_num=start_num+1
    end
  end
  def touch_sub():
    $ 2401 "touch_sub" "noBreak"
    $ 2402 "freedrive"
    $ 2403 "save_timer: Start"
    save_timer_is_counting = True
    $ 2404 "Loop save_tool≟ False  and save_timer≤0.5"
    while (get_tool_digital_in(0) ==   False    and  save_timer <= 0.5):
      $ 2405 "If save_tool≟ False "
      if (get_tool_digital_in(0) ==   False  ):
        $ 2406 "save_timer≔0"
        global save_timer=0
      end
      $ 2407 "If freedrive≟ True  and freedrive_trg≟ False "
      if (get_tool_digital_in(1) ==   True    and  freedrive_trg ==   False  ):
        $ 2408 "'Manual - Freedrive'"
        # 'Manual - Freedrive'
        $ 2409 "freedrive_mode()"
        freedrive_mode()
        $ 2410 "freedrive_trg≔ True "
        global freedrive_trg=  True  
      else:
        $ 2411 "ElseIf freedrive≟ False  and freedrive_trg≟ True "
        if (get_tool_digital_in(1) ==   False    and  freedrive_trg ==   True  ):
          $ 2412 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 2413 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
      end
      $ 2414 "If lamp_trig≟ False "
      if (lamp_trig ==   False  ):
        $ 2415 "lamp_trig≔ True "
        global lamp_trig=  True  
      end
      $ 2416 "sync()"
      sync()
    end
    $ 2417 "save_timer: Stop"
    save_timer_is_counting = False
    $ 2418 "save_timer: Reset"
    save_timer = 0
    $ 2419 "write_port_register(touch_done_157,1)"
    write_port_register(touch_done_157,1)
    $ 2420 "Wait read_port_register(touch_done_157)≟0"
    while (not( read_port_register (touch_done_157) == 0)):
      sync()
    end
    $ 2421 "Wait save_tool=LO"
    while (get_tool_digital_in(0) == True):
      sync()
    end
  end
  $ 2 "BeforeStart"
  $ 3 "'RobotVersion'"
  # 'RobotVersion'
  $ 4 "write_port_register(160,104)"
  write_port_register(160,104)
  $ 5 "Teaching for Touch"
  $ 6 "g_current_p≔get_actual_tcp_pose()"
  global g_current_p= get_actual_tcp_pose ()
  $ 7 "MoveJ"
  $ 8 "g_current_p" "breakAfter"
  movej(g_current_p, a=1.3962634015954636, v=1.0471975511965976, r=0.05)
  $ 9 "If  False "
  if (  False  ):
    $ 10 "MoveJ"
    $ 11 "'Home'"
    # 'Home'
    $ 12 "first_p" "breakAfter"
    movej([0.6572912931442261, -1.1853707472430628, -1.1612256209002894, -2.29183799425234, 1.5053011178970337, 2.249363422393799], a=1.3962634015954636, v=1.0471975511965976)
    $ 13 "'3F Left Right'"
    # '3F Left Right'
    $ 14 "left" "breakAfter"
    movej([1.0434843552115187, -1.5100991608390455, -1.7306758129700324, -1.1948061631169296, 1.4628666284450171, 1.848321797880608], a=1.3962634015954636, v=1.0471975511965976)
    $ 15 "right" "breakAfter"
    movej([-0.10351455753530914, -1.3302576856500608, -2.115934992292752, -0.862193753976749, 1.3219395896157813, 2.4264792168573246], a=1.3962634015954636, v=1.0471975511965976)
    $ 16 "'2F Left Right'"
    # '2F Left Right'
    $ 17 "up_left" "breakAfter"
    movej([1.1752926889699076, -1.8019900427886952, -1.320977727654376, -1.5255442863405975, 1.3476341406937622, 2.041365262351603], a=1.3962634015954636, v=1.0471975511965976)
    $ 18 "up_right" "breakAfter"
    movej([-0.490858516659304, -1.5854285429454542, -1.6450882962874376, -1.2830655228732084, 1.6157391701919699, 1.9100727821897805], a=1.3962634015954636, v=1.0471975511965976)
    $ 19 "Packing_pos" "breakAfter"
    movej([1.5877798795700073, -0.0173419157611292, -2.4983108679400843, -1.4065726439105433, 1.626846194267273, 3.0169763565063477], a=1.3962634015954636, v=1.0471975511965976)
    $ 20 "pre_position" "breakAfter"
    movej([1.2637099027633667, -0.695505444203512, -2.0481718222247522, -1.9413569609271448, 2.573765277862549, 1.3775802850723267], a=1.3962634015954636, v=1.0471975511965976)
    $ 21 "middle_pos" "breakAfter"
    movej([-1.8762093791333925, -1.0408674059020342, -1.3551139327963426, -1.843592441478755, 1.9056326083560464, 0.7075109167810423], a=1.3962634015954636, v=1.0471975511965976)
    $ 22 "Mounting_pos" "breakAfter"
    movej([0.6231353085164267, -0.6300961531972575, -0.9034285948871803, -1.770059340221131, 1.417516049558281, 1.7792033261567348], a=1.3962634015954636, v=1.0471975511965976)
    $ 23 "pre_mounting" "breakAfter"
    movej([1.2356762886047363, -0.8703244368182581, -0.942230526600973, -2.3905327955829065, 1.3216267824172974, 2.6514604091644287], a=1.3962634015954636, v=1.0471975511965976)
    $ 24 "'firstly touch center and side, side_L is side touch pose'"
    # 'firstly touch center and side, side_L is side touch pose'
    $ 25 "side_p_L" "breakAfter"
    movej([0.7063748268745771, -1.3604975314992132, -1.990433834727808, -1.0668367667667118, 1.6921872781537495, 1.2509236145111355], a=1.3962634015954636, v=1.0471975511965976)
    $ 26 "side_p_R" "breakAfter"
    movej([0.05431400611996651, -1.4896310011493128, -1.8839471975909632, -1.079590145741598, 1.21127450466156, 2.729013204574585], a=1.3962634015954636, v=1.0471975511965976)
    $ 27 "left_prep_p" "breakAfter"
    movej([0.7465318441390991, -0.9293935934649866, -1.54653245607485, -2.120742146168844, 1.6612900495529175, 1.4639835357666016], a=1.3962634015954636, v=1.0471975511965976)
    $ 28 "right_prep_p" "breakAfter"
    movej([0.07502574473619461, -0.9044721762286585, -1.5771153608905237, -1.9135711828814905, 1.726387619972229, 2.67875337600708], a=1.3962634015954636, v=1.0471975511965976)
    $ 29 "top_right" "breakAfter"
    movej([-0.02242371234582219, -0.9682979219978707, -1.1486403794481532, -1.814672356578109, 1.0564512116488283, 1.9516847799391646], a=1.3962634015954636, v=1.0471975511965976)
    $ 30 "down_right" "breakAfter"
    movej([-0.10387097169690396, -0.8634965401570085, -1.6224404602167288, -1.9527388322769834, 1.2604034373302166, 1.9362943911099855], a=1.3962634015954636, v=1.0471975511965976)
    $ 31 "way_600_3F_VL1" "breakAfter"
    movej([1.4495428629911409, -0.8691188832486789, -1.6280015865128723, -1.109862842185814, 0.958613460846621, 1.8600136596738885], a=1.3962634015954636, v=1.0471975511965976)
    $ 32 "way_3F_42" "breakAfter"
    movej([0.36805654405146704, -0.7862968504575107, -2.173257016154224, -1.4479178800416523, 0.8821879504915225, 2.8855763836420314], a=1.3962634015954636, v=1.0471975511965976)
    $ 33 "Waypoint_3" "breakAfter"
    movej([1.1380372507706311, -0.9407851141189099, -1.233329099346161, -2.2390373632318763, 1.2601061328687342, 1.8320151492624872], a=1.3962634015954636, v=1.0471975511965976)
  end
  $ 34 "waypoint"
  $ 35 "first_p_wp≔first_p"
  global first_p_wp=p[.431245807847, -.007259877891, .087796870964, 2.814824648791, -.024151220978, 1.380109909682]
  $ 36 "home_pos_j≔get_inverse_kin(first_p,qnear=[0.788235068321228, -1.101443115864889, -1.2219904104815882, -2.3243168036090296, 1.506469488143921, 2.3651483058929443])"
  global home_pos_j= get_inverse_kin (p[.431245807847, -.007259877891, .087796870964, 2.814824648791, -.024151220978, 1.380109909682],qnear=[0.788235068321228, -1.101443115864889, -1.2219904104815882, -2.3243168036090296, 1.506469488143921, 2.3651483058929443])
  $ 37 "left_j≔get_inverse_kin(left,qnear=[1.0260889556530308, -1.5106289215345097, -1.741216762689402, -1.178962336228949, 1.4987324920877318, 1.8103628938054515])"
  global left_j= get_inverse_kin (p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605],qnear=[1.0260889556530308, -1.5106289215345097, -1.741216762689402, -1.178962336228949, 1.4987324920877318, 1.8103628938054515])
  $ 38 "right_j≔get_inverse_kin(right,qnear=[-0.04005625546610858, -1.5553040811514833, -1.9086689348599588, -0.877043115030812, 1.298887151057777, 2.511237649551841])"
  global right_j= get_inverse_kin (p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292],qnear=[-0.04005625546610858, -1.5553040811514833, -1.9086689348599588, -0.877043115030812, 1.298887151057777, 2.511237649551841])
  $ 39 "left_prep_p_v≔left_prep_p"
  global left_prep_p_v=p[.305384281395, .209992212444, .052849493181, -2.261254200610, -.979668861910, -1.115042887278]
  $ 40 "right_prep_p_v≔right_prep_p"
  global right_prep_p_v=p[.351918991358, -.200990531927, .062804013870, 2.289356494782, -1.513598216236, 1.281039242610]
  $ 41 "Packing_pos_wp≔Packing_pos"
  global Packing_pos_wp=p[.278714911898, .357008020042, .025408199530, -2.146966801259, .195978635494, -.919933898512]
  $ 42 "pre_position_wp≔pre_position"
  global pre_position_wp=p[-.206981089246, .377817475970, .184983176991, -1.570600793609, -.863923490888, -.089005332274]
  $ 43 "pre_mounting_wp≔pre_mounting"
  global pre_mounting_wp=p[.460443249232, .114922015113, .277198878359, -2.240057458299, .067416497001, -1.614091004704]
  $ 44 "mounting_wp≔Mounting_pos"
  global mounting_wp=p[.365658114054, -.003207132620, .718667154922, -1.220752075696, -.066673751622, -2.363385143972]
  $ 45 "Setting"
  $ 46 "inv_inch_time≔0.4"
  global inv_inch_time=0.4
  $ 47 "a7_cell_bottom≔-50.2"
  global a7_cell_bottom=-50.2
  $ 48 "get_center≔470"
  global get_center=470
  $ 49 "work_touch_dis≔70"
  global work_touch_dis=70
  $ 50 "cd_extra_dis≔6"
  global cd_extra_dis=6
  $ 51 "side_pos_x≔-10"
  global side_pos_x=-10
  $ 52 "sec_touch_dis≔35"
  global sec_touch_dis=35
  $ 53 "Touch_dis≔0"
  global Touch_dis=0
  $ 54 "offset_2f_begin≔5"
  global offset_2f_begin=5
  $ 55 "offset_3f_begin≔5"
  global offset_3f_begin=5
  $ 56 "multi_offset_z≔3"
  global multi_offset_z=3
  $ 57 "simulation_mode≔ False "
  global simulation_mode=  False  
  $ 58 "tilt_deg_man≔7"
  global tilt_deg_man=7
  $ 59 "top_touch_3f≔ False "
  global top_touch_3f=  False  
  $ 60 "Initialization"
  $ 61 "reset_revolution_counter()"
  reset_revolution_counter()
  $ 62 "get_center_bak≔get_center"
  global get_center_bak=get_center
  $ 63 "welding_program≔ False "
  global welding_program=  False  
  $ 64 "vr2_p1≔p[0,0,0,0,0,0]"
  global vr2_p1=p[0,0,0,0,0,0]
  $ 65 "running_trig≔ False "
  global running_trig=  False  
  $ 66 "pb_comm_count≔0"
  global pb_comm_count=0
  $ 67 "pendant_hb≔read_port_register(161)"
  global pendant_hb= read_port_register (161)
  $ 68 "pause_trig≔ False "
  global pause_trig=  False  
  $ 69 "multi_path≔1"
  global multi_path=1
  $ 70 "reset_trig≔ False "
  global reset_trig=  False  
  $ 71 "heartbeat≔0"
  global heartbeat=0
  $ 72 "back_2f≔ False "
  global back_2f=  False  
  $ 73 "t_time≔0"
  global t_time=0
  $ 74 "cd_offset≔35"
  global cd_offset=35
  $ 75 "write_port_register(144,0)"
  write_port_register(144,0)
  $ 76 "time_cal_trig≔ False "
  global time_cal_trig=  False  
  $ 77 "current_2f≔0"
  global current_2f=0
  $ 78 "A_cur_2f≔0"
  global A_cur_2f=0
  $ 79 "CD_MLR≔ True "
  global CD_MLR=  True  
  $ 80 "auto_on≔ False "
  global auto_on=  False  
  $ 81 "event_cal_on≔ False "
  global event_cal_on=  False  
  $ 82 "event_side_on≔ False "
  global event_side_on=  False  
  $ 83 "Auto_trig≔ False "
  global Auto_trig=  False  
  $ 84 "lamp_trig≔ False "
  global lamp_trig=  False  
  $ 85 "calcu_trig≔ False "
  global calcu_trig=  False  
  $ 86 "current_path≔1"
  global current_path=1
  $ 87 "freedrive_trg≔ False "
  global freedrive_trg=  False  
  $ 88 "Inch_trg≔ False "
  global Inch_trg=  False  
  $ 89 "wv_direction≔1"
  global wv_direction=1
  $ 90 "Move_trig≔ False "
  global Move_trig=  False  
  $ 91 "CELL_ROBOT_DIST≔500"
  global CELL_ROBOT_DIST=500
  $ 92 "CELL_WIDTH≔700"
  global CELL_WIDTH=700
  $ 93 "CELL_BOTTOM≔a7_cell_bottom"
  global CELL_BOTTOM=a7_cell_bottom
  $ 94 "scallop_info≔ False "
  global scallop_info=  False  
  $ 95 "Carl_info≔ False "
  global Carl_info=  False  
  $ 96 "touch_done_2f≔ False "
  global touch_done_2f=  False  
  $ 97 "get_pose_side≔0"
  global get_pose_side=0
  $ 98 "get_pose_side_t≔0"
  global get_pose_side_t=0
  $ 99 "ba_trig≔ False "
  global ba_trig=  False  
  $ 100 "touch_m_check≔0"
  global touch_m_check=0
  $ 101 "basic_tilt_2f≔[30,5,0]"
  global basic_tilt_2f=[30,5,0]
  $ 103 "basic_tilt_3f≔[0,-27,0]"
  global basic_tilt_3f=[0,-27,0]
  $ 105 "modbus_name"
  $ 106 "weld_done_137≔137"
  global weld_done_137=137
  $ 107 "robot_ready_141≔141"
  global robot_ready_141=141
  $ 108 "cell_3f_2f_151≔151"
  global cell_3f_2f_151=151
  $ 109 "cell_info_152≔152"
  global cell_info_152=152
  $ 110 "weld_req_153≔153"
  global weld_req_153=153
  $ 111 "touch_cell_155≔155"
  global touch_cell_155=155
  $ 112 "touch_num_156≔156"
  global touch_num_156=156
  $ 113 "touch_done_157≔157"
  global touch_done_157=157
  $ 114 "robot_move_163≔163"
  global robot_move_163=163
  $ 115 "robot_pose_164≔164"
  global robot_pose_164=164
  $ 116 "work_type_165≔165"
  global work_type_165=165
  $ 117 "arc_onoff_168≔168"
  global arc_onoff_168=168
  $ 118 "beforeafter_170≔170"
  global beforeafter_170=170
  $ 119 "return_done_240≔240"
  global return_done_240=240
  $ 120 "a0_Job_Mode≔0"
  global a0_Job_Mode=0
  $ 121 "position_3F≔1"
  global position_3F=1
  $ 122 "position_2F≔2"
  global position_2F=2
  $ 123 "cell_par"
  $ 124 "A≔1"
  global A=1
  $ 125 "B≔2"
  global B=2
  $ 126 "C≔3"
  global C=3
  $ 127 "c≔4"
  global c=4
  $ 128 "D≔5"
  global D=5
  $ 129 "d≔6"
  global d=6
  $ 130 "E≔7"
  global E=7
  $ 131 "e≔8"
  global e=8
  $ 132 "A_VL1≔1"
  global A_VL1=1
  $ 133 "A_VL2≔2"
  global A_VL2=2
  $ 134 "A_VR1≔3"
  global A_VR1=3
  $ 135 "A_VR2≔4"
  global A_VR2=4
  $ 136 "A_HOR≔5"
  global A_HOR=5
  $ 137 "A_HOR_R≔7"
  global A_HOR_R=7
  $ 138 "A_HOR_ML≔6"
  global A_HOR_ML=6
  $ 139 "A_HOR_MR≔8"
  global A_HOR_MR=8
  $ 140 "A_HOR_M≔9"
  global A_HOR_M=9
  $ 141 "A_VL1_END≔10"
  global A_VL1_END=10
  $ 142 "A_VL2_END≔11"
  global A_VL2_END=11
  $ 143 "A_VR1_END≔12"
  global A_VR1_END=12
  $ 144 "A_VR2_END≔13"
  global A_VR2_END=13
  $ 145 "A_HOR_2path≔14"
  global A_HOR_2path=14
  $ 146 "A_HOR_3path≔15"
  global A_HOR_3path=15
  $ 147 "A_HOR_4path≔16"
  global A_HOR_4path=16
  $ 148 "A_HOR_2path_CD≔17"
  global A_HOR_2path_CD=17
  $ 149 "A_HOR_3path_CD≔18"
  global A_HOR_3path_CD=18
  $ 150 "A_HOR_4path_CD≔19"
  global A_HOR_4path_CD=19
  $ 151 "Script: UR_samho_weaving_V10.6_CB.script"
  wv_wp1 = p[0,0,0,0,0,0]
  dumy_p = p[0,0,0,0,0,0]
  global background_cal = 0
  global background_pose = [dumy_p,dumy_p,dumy_p,dumy_p]
  global background_ready = 0
  global timer_counter = 0
  global timer_counting = False
  global dist_enable = False
  global wcr_counter = 0
  global wcr_counting = False
  global get_wcr = False
  global arc_sens_onoff = 0
  global welding_off_t = 55
  global weld_onoff = False
  global isHicomm = True
  global isTouchWCR = True
  global welding_program = False
  global arc_sens_2F = False
  global first_half = False
  
  thread thread_timer():
    error_time = 5
    start_gas_time = 2
    while (True):
      if (timer_counting):
        timer_counter = timer_counter + get_steptime()
        write_output_float_register(0,timer_counter)
  
        get_wcr = read_welder(5)
        weld_onoff = read_welder_control(0)
  
        welding_off_t = read_port_register(168)
        if(get_wcr):
          global arc_sens_onoff = 1
        else:
          global arc_sens_onoff = 0
        end
        if(get_wcr and welding_off_t == 2 and weld_onoff == True):
          wcr_counter=0
        elif(wcr_counter>(error_time+start_gas_time) and welding_off_t == 2 and weld_onoff == True):
          write_port_register(202,0)
          write_port_register(149,0)
          write_welder(0,False)
          set_standard_digital_out(0,False)
          write_port_register(142,131)
          sleep(0.5)
          halt
        elif(get_wcr == False and welding_off_t == 2 and weld_onoff == True):
          wcr_counter = wcr_counter + get_steptime()
        end
      end
      sync()
    end
  end
  
  
  thread thread_dist_rec():
    global every_four = 0
    global every_four_bak = 0
    while (True):
      if (dist_enable):
        global cur_p = get_feature_pose(get_actual_tcp_pose(),wv_Line_Feature2)
        record_dis = 4
        global every_four = floor(norm(cur_p[0]*1000)/record_dis)
        if(every_four >= 278):
          every_four = 278
        end
        write_output_float_register(26,every_four)
        if(every_four != every_four_bak):
          if(record_multi):
            if(step_2f==1 and x_offset_1[every_four] != 0):
              global plus_alpha_x = x_offset_1[every_four]
              global plus_alpha_z = z_offset_1[every_four]
            elif(step_2f==2 and x_offset_2[every_four] != 0):
              global plus_alpha_x = x_offset_2[every_four]
              global plus_alpha_z = z_offset_2[every_four]
            elif(step_2f==3 and x_offset_3[every_four] != 0):
              global plus_alpha_x = x_offset_3[every_four]
              global plus_alpha_z = z_offset_3[every_four]
            end
            write_output_float_register(24,plus_alpha_x)
            write_output_float_register(25,plus_alpha_z)
          else:
            if(step_2f==1 and x_offset_1[every_four] == 0):
              x_offset_1[every_four] = arc_x_off
              z_offset_1[every_four] = arc_z_off
            elif(step_2f==2 and x_offset_2[every_four] == 0):
              x_offset_2[every_four] = arc_x_off
              z_offset_2[every_four] = arc_z_off
            elif(step_2f==3 and x_offset_3[every_four] == 0):
              x_offset_3[every_four] = arc_x_off
              z_offset_3[every_four] = arc_z_off
            end
            write_output_float_register(24,arc_x_off)
            write_output_float_register(25,arc_z_off)
          end
          every_four_bak = every_four
          write_output_float_register(23,every_four_bak)
        end
      end
      sync()
    end
  end
  
  def RTDE_init():
    # timer
    write_output_float_register(0,0)
    # WCR IN
    write_output_float_register(1,0)
    # Welding Current
    write_output_float_register(2,0)
    # Welding Voltage
    write_output_float_register(3,0)
    # X offset
    write_output_float_register(4,0)
    # Z offset
    write_output_float_register(5,0)
    # PLUS Integral
    write_output_float_register(6,0)
    # MINUS Integral
    write_output_float_register(7,0)
    # Standard_Arc_Current
    write_output_float_register(8,0)
    # ALL Integral
    write_output_float_register(9,0)
    # x up
    write_output_float_register(10,0)
    # x ui
    write_output_float_register(11,0)
    # z up
    write_output_float_register(12,0)
    # z ui
    write_output_float_register(13,0)
    # x
    write_output_float_register(14,0)
    # y
    write_output_float_register(15,0)
    # z
    write_output_float_register(16,0)
    # welding on/off polyscope
    write_output_float_register(17,0)
    # touch on/off polyscope
    write_output_float_register(18,0)
    # ratio_t
    write_output_float_register(19,0)
    # get_wcr polyscope
    write_output_float_register(20,0)
    # get_touch polyscope
    write_output_float_register(21,0)
    # write_welder
    write_output_float_register(22,0)
    # MIDDLE_Integral_org
    write_output_float_register(23,0)
    # PLUS Integral_org
    write_output_float_register(24,0)
    # MINUS Integral_org
    write_output_float_register(25,0)
  
    #init
    global cycle_number = 0
    global cycle_done = False
    global cycle1_plus = 0
    global cycle1_minus = 0
    global cycle1_middle = 0
    global current_to_welding_m = read_port_register(133)
    global voltage_to_welding_m = read_port_register(134)/10
    global c_maxcut = current_to_welding_m*1.2
    global c_mincut = current_to_welding_m*0.8
    global v_maxcut = voltage_to_welding_m*1.2
    global v_mincut = voltage_to_welding_m*0.8
    global Standard_Arc_Current = current_to_welding_m
    global Standard_Arc_voltage = voltage_to_welding_m
    global FB_CURRENT_UR = 0
    global FB_VOLTAGE_UR = 0
    global FB_CURRENT_UR_org = 0
    global FB_VOLTAGE_UR_org = 0
    global one_cycle_p_count = 0
    global one_cycle_m_count = 0
    global one_cycle_p_accum = 0
    global one_cycle_m_accum = 0
  
  
    global one_cycle_p_count2 = 0
    global one_cycle_m_count2 = 0
    global one_cycle_p_accum2 = 0
    global one_cycle_m_accum2 = 0
  
    global one_cycle_p_accum_org = 0
    global one_cycle_m_accum_org = 0
    global cal_off_ang_rx = 0
    global cal_off_ang_ry = 0
    global Up = 0
    global Ui = 0
    global Pi_sum = 0
    global Up_z = 0
    global Ui_z = 0
    global Pi_sum_z = 0
    global peak_value = 0
    global peak_value2 = 0
    global ratio_t = 0
    global welding_off_t = 55
    global program_weld_on = False
    global next_path_c = False
    global move_p = [dumy_p,dumy_p,dumy_p,dumy_p]
    global hicomm = True
    global current_on = False
    global arc_x_off=0
    global arc_z_off=0
    global ARC_T_ONOFF = False
    global ARC_T_s_pose = p[0,0,0,0,0,0]
    global ARC_T_e_pose = p[0,0,0,0,0,0]
    global ARC_T_percent_m = 50
    global ARC_T_percent_p = 50
    global ARC_T_ratio = 0
    global ARC_T_Plus = 1
    global T1 = p[0,0,0,0,0,0]
    global plus_alpha_x = 0
    global plus_alpha_z = 0
    global move_dis = 0
    global every_four = 0
    timer_counter = 0
    sync()
  end
  
  # get line distance without caring orientation
  def get_line_dist(get_wp1,get_wp2):
    return sqrt((get_wp2[0]-get_wp1[0])*(get_wp2[0]-get_wp1[0])+(get_wp2[1]-get_wp1[1])*(get_wp2[1]-get_wp1[1])+(get_wp2[2]-get_wp1[2])*(get_wp2[2]-get_wp1[2]))
  end
  
  def plus_minus(num):
    if(num<0):
      return -1
    else:
      return 1
    end
  end
  
  def get_feature_plane_xz(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dy = cross_product(d13, d12)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dy)
    uy = [ dy[0]/temp, dy[1]/temp, dy[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uz = cross_product(ux, uy)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def get_feature_plane_yz(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dx = cross_product(d12, d13)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    uy = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dx)
    ux = [ dx[0]/temp, dx[1]/temp, dx[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uz = cross_product(ux, uy)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def get_feature_plane_xy(p1, p2, p3):
  
    # Step 1. Get the direction vectors
    d12 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    d13 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
  
    # Step 2. Get the direction vector of Z axis by cross product of d12 and d13
    dz = cross_product(d12, d13)
  
    # Step 3. Get the X and Z unit direction vectors by normalizing d12 and dz
    temp = norm(d12)
    ux = [ d12[0]/temp, d12[1]/temp, d12[2]/temp ]
    temp = norm(dz)
    uz = [ dz[0]/temp, dz[1]/temp, dz[2]/temp ]
  
    # Step 4. Get Y unit direction vector by cross product of uz and ux
    uy = cross_product(uz, ux)
  
    # Step 5. Get the rotation matrix from the unit direction vectors
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
  
    # Step 6. Get the rotation vector from the rotation matrix
    rotvec = rotmat2rotvec(rotmat)
  
    # Step 7. Get the feature plane with the origin at p1 and the frame achieved at step 6
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  #### ur_weaving_rev1 by Henry
  #  x_feature = pose_trans(N_Pose,pose_inv(p[0,0,x,0,0,0])
  def feature_offset(fun_pose,fun_offset,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    fun_offrot = rotvec2rpy([fun_p_feature[3],fun_p_feature[4],fun_p_feature[5]])
    fun_offset = p[fun_offset[0],fun_offset[1],fun_offset[2],fun_offrot[0]+fun_offset[3],fun_offrot[1]+fun_offset[4],fun_offrot[2]+fun_offset[5]]
    fun_offset_p = p[fun_offset[0],fun_offset[1],fun_offset[2],0,0,0]
    fun_offrpy_rot = rpy2rotvec([fun_offset[3],fun_offset[4],fun_offset[5]])
    fun_offset_rot = p[0,0,0,fun_offrpy_rot[0],fun_offrpy_rot[1],fun_offrpy_rot[2]]
    fun_cal_p = pose_trans(fun_plane,pose_trans(fun_offset_p,fun_p_feature))
    fun_cal_rot = pose_trans(fun_plane,fun_offset_rot)
    result_cal = p[fun_cal_p[0],fun_cal_p[1],fun_cal_p[2],fun_cal_rot[3],fun_cal_rot[4],fun_cal_rot[5]]
    return result_cal
  end
  
  ## same as changing feature in Move command
  ## Set offset into Plane and move position by it
  def plane_offset(fun_pose,p_offset,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    fun_plane = pose_trans(fun_plane,p[p_offset[0],p_offset[1],p_offset[2],0,0,0])
    fun_p_result = pose_trans(pose_trans(fun_plane,p[0,0,0,p_offset[3],p_offset[4],p_offset[5]]),fun_p_feature)
    return fun_p_result
  end
  
  #  convert from rotation matrix to rotation vector
  ####
  def rotmat2rotvec(rotmat):
  
    # array to matrix
    r11 = rotmat[0]
    r21 = rotmat[1]
    r31 = rotmat[2]
    r12 = rotmat[3]
    r22 = rotmat[4]
    r32 = rotmat[5]
    r13 = rotmat[6]
    r23 = rotmat[7]
    r33 = rotmat[8]
  
    # rotation matrix to rotation vector
    theta = acos((r11+r22+r33-1)/2)
    sth = sin(theta)
  
    if ( (theta > d2r(179.99)) or (theta < d2r(-179.99)) ):
      theta = d2r(180)
      if (r21 < 0):
        if (r31 < 0):
          ux = sqrt((r11+1)/2)
          uy = -sqrt((r22+1)/2)
          uz = -sqrt((r33+1)/2)
        else:
          ux = sqrt((r11+1)/2)
          uy = -sqrt((r22+1)/2)
          uz = sqrt((r33+1)/2)
        end
      else:
        if (r31 < 0):
          ux = sqrt((r11+1)/2)
          uy = sqrt((r22+1)/2)
          uz = -sqrt((r33+1)/2)
        else:
          ux = sqrt((r11+1)/2)
          uy = sqrt((r22+1)/2)
          uz = sqrt((r33+1)/2)
        end
      end
    else:
      ux = (r32-r23)/(2*sth)
      uy = (r13-r31)/(2*sth)
      uz = (r21-r12)/(2*sth)
    end
  
    rotvec = [(theta*ux),(theta*uy),(theta*uz)]
  
    return rotvec
  end
  
  # cross product of two vectors u and v
  ####
  def cross_product(u, v):
  
    u1 = u[0]
    u2 = u[1]
    u3 = u[2]
    v1 = v[0]
    v2 = v[1]
    v3 = v[2]
  
    s = [ (u2*v3-u3*v2), (u3*v1-u1*v3), (u1*v2-u2*v1) ]
  
    return s
  end
  ####
  def get_feature_Line(p1, p2):
    p3 = pose_trans(p1,p[0,0,0.01,0,0,0])
    d1 = [ p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2] ]
    d2 = [ p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2] ]
    dx = cross_product(d1, d2)
    temp = norm(d2)
    uy = [ d2[0]/temp, d2[1]/temp, d2[2]/temp ]
    temp = norm(dx)
    ux = [ dx[0]/temp, dx[1]/temp, dx[2]/temp ]
    uz = cross_product(ux, uy)
    rotmat = [ ux[0], ux[1], ux[2], uy[0], uy[1], uy[2], uz[0], uz[1], uz[2] ]
    rotvec = rotmat2rotvec(rotmat)
    feature_plane = p[ p1[0], p1[1], p1[2], rotvec[0], rotvec[1], rotvec[2] ]
  
    return feature_plane
  end
  
  def calculate_p(feature, direction, position_distance):
    local posDir=[direction[0], direction[1], direction[2]]
    if (norm(posDir) < 1e-6):
      return get_target_waypoint()
    end
    local direction_vector_normalized=posDir
    local displacement_pose=p[direction_vector_normalized[0] * position_distance,direction_vector_normalized[1] * position_distance,direction_vector_normalized[2] * position_distance,0,0,0]
    local wanted_displacement_in_base_frame=pose_sub(pose_trans(feature, displacement_pose), feature)
    return pose_add(get_target_waypoint(), wanted_displacement_in_base_frame)
  end
  
  def direction(feature, direction, position_distance,fun_speed=50,fun_acc=100):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
  
    thread fun_thread_direction():
      enter_critical
  
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    move_thread_dirr2 = run fun_thread_direction()
    while (True):
      sleep(1.0E-10)
      if (move_flag > 1):
        kill move_thread_dirr2
        break
      end
      sync()
    end
  end
  
  def movej_elbwrist(j_p,fun_height=-0.02,fun_speed=0.5,fun_acc=0.5):
    global g_jp = j_p
    global g_ac = fun_speed
    global g_sp = fun_acc
    global move_flag = 0
    g_cp = get_actual_tcp_pose()
    if(g_cp[2]<fun_height):
      move_flag = 1
      return True
    end
    thread fun_thread_elbwirst():
      enter_critical
      move_flag = 1
      movej(g_jp, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    move_thread_direlb = run fun_thread_elbwirst()
    while(True):
      g_cp = get_actual_tcp_pose()
      sync()
      if (move_flag > 1 or g_cp[2]<fun_height):
        kill move_thread_direlb
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def movel_singu(t_p,fun_speed=0.2,fun_acc=0.4,hard_mode=False):
    global g_pp = t_p
    global g_ac = fun_speed
    global g_sp = fun_acc
    move_flag = 0
    singu_var = singularity(t_p,hard_mode)
    if(singu_var==True):
      move_flag = 1
      return True
    end
    thread fun_thread_movelsingu():
      enter_critical
      move_flag = 1
      movel(g_pp, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    move_thread_dirr = run fun_thread_movelsingu()
    while(True):
      sleep(1.0E-10)
      if (move_flag > 1 or singularity(get_actual_tcp_pose(),hard_mode)):
        kill move_thread_dirr
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def direction_singu(feature, direction, position_distance,fun_speed=50,fun_acc=100,hard_mode=False):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global stepsToRetract = 0
    singu_var = singularity(get_actual_tcp_pose(),hard_mode)
    if(singu_var==True):
      move_flag = 1
      return True
    end
    thread fun_thread_sing():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    thread_han_sing = run fun_thread_sing()
    while (True):
      sleep(1.0E-10)
      if (move_flag > 1 or singularity(get_actual_tcp_pose(),hard_mode)):
        kill thread_han_sing
        break
      end
      sync()
    end
    if(move_flag!=2):
      stopj(3)
      move_flag = 0
      return True
    else:
      return False
    end
  end
  
  def motion_num(m_num = [0,0,0,0,0,0]):
    VL1_r = 1
    VL2_r = 2
    VR1_r = 4
    VR2_r = 8
    HOR_r = 16
    var_i = 0
    r_val = 0
    while(var_i<5):
      if(m_num[var_i] == 1):
        r_val = r_val + VL1_r
      elif(m_num[var_i] == 2):
        r_val = r_val + VL2_r
      elif(m_num[var_i] == 3):
        r_val = r_val + VR1_r
      elif(m_num[var_i] == 4):
        r_val = r_val + VR2_r
      elif(m_num[var_i] == 5):
        r_val = r_val + HOR_r
      end
      var_i = var_i + 1
    end
    return r_val
  end
  
  def touch_cal(Num_L,Num_R,Cell_Sel):
    #VL1:1, VL2:2, VR1:3, VR2:4, HOR:5, HOR_ML:6, HOR_R:7, HOR_MR:8, HOR_M:9 VL1_END:10, VL2_END:11, VR1_END:12, VR2_END:13, HOR_2path:14, HOR_3path:15, HOR_4path:16, HOR_2path_CD:17, HOR_3path_CD:18, HOR_4path_CD:19
    #A : 1, B : 2, C : 3, c : 4, D : 5, d :6, E : 7
    touch_check = [False,False,False,False,False,False,False,False,False,False,False]
    #touch_left, touch_left2
    global Cell_t = integer_to_binary_list(Cell_Sel)
    if(Cell_t[0]==True):
      #touch_left
      touch_check[1] = True
    end
    if(Cell_t[1]==True):
      #touch_left2
      touch_check[2] = True
    end
    if(Cell_t[2]==True):
      #touch_right
      touch_check[3] = True
    end
    if(Cell_t[3]==True):
      #touch_right2
      touch_check[4] = True
    end
  
    if(Cell_t[4]==True):
      #touch_hor is needed for checking
      #left A or B
      touch_check[5] = True
    end
  
    if(Cell_t[4]==True):
      #HOR_R:7
      #right
      touch_check[7] = True
    end
  
    if(Cell_t[4]==True and (Num_L == 3 or Num_L == 4 or Num_L == 5 or Num_L == 6)):
      #HOR_ML:6
      #left c,C,D,d
      touch_check[6] = True
    elif(Cell_t[4]==True and (Num_R == 3 or Num_R == 4 or Num_R == 5 or Num_R == 6)):
      #HOR_MR:8
      #right c,C,D,d
      touch_check[8] = True
    end
    return touch_check
  end
  
  def cpm2mms(cpm_speed):
    return cpm_speed / 6
  end
  
  def time_diff(until_num):
    global get_143 = read_port_register(143)
    get_144 = read_port_register(144)
    global get_time = time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,until_num)
    time_diff = get_143 - get_time
    get_144 = get_144 + time_diff
    # write_port_register(144,get_144)
    return get_144
  end
  
  def time_cal(scenario_l,t_num,speed_l,distance_l,touch_l,until_num=0):
    VL1 = 1
    VL2 = 2
    VR1 = 3
    VR2 = 4
    HOR = 5
    HOR_ML = 6
    HOR_R = 7
    HOR_MR = 8
    HOR_M = 9
    w_time = 0
    t_count = 0
  
    if(until_num == 0):
      f_num = t_num
    else:
      f_num = until_num
    end
  
    while(t_count<f_num):
      c_scenario = scenario_l[t_count]
      if(c_scenario==VL1 or c_scenario==VL2 or c_scenario==VR1 or c_scenario==VR2):
        if(touch_l[c_scenario+9]==p[0,0,0,0,0,0]):
          w_time = w_time + distance_l[c_scenario]/cpm2mms(speed_l[c_scenario])
          w_time = w_time + 1.5
          # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
        else:
          w_time = w_time + point_dist(touch_l[c_scenario],touch_l[c_scenario+9])*1000/cpm2mms(speed_l[c_scenario])
          w_time = w_time + 1.5
          # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
        end
      else:
        w_time = w_time + point_dist(touch_l[HOR],touch_l[HOR_R])*1000/cpm2mms(speed_l[HOR])
        w_time = w_time + 1.5
        # w_time = w_time + point_dist(touch_l[c_scenario],first_p_wp)*1000/130*2
      end
      t_count = t_count+1
    end
    return floor(w_time)
  end
  
  # 각 셀의 터치 위치를 바탕으로 내가 이번에 실행할 셀을 순서에 맞게 반환한다.
  # 예시 : value =[1,3] -> VL1, VR1 순서로 실행한다.
  def cell_motion(Touch_Sel,thickness_2f,ext_flag_pend,cell_info_l,cell_info_r):
    ex = 0
    num_2f = 0
    global return_pose = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    val_sum = 0
    VL1 = 1
    VL2 = 2
    VR1 = 3
    VR2 = 4
    HOR = 5
    HOR_ML = 6
    HOR_R = 7
    HOR_MR = 8
    HOR_M = 9
    HOR_2path = 14
    HOR_3path = 15
    HOR_4path = 16
    HOR_2path_CD = 17
    HOR_3path_CD = 18
    HOR_4path_CD = 19
    CD_check = 0
    Cell_l = Touch_Sel
    cell_c = 4
    cell_d = 6
  
    # 분할 X
    HOR_1 = 30
    # 분할 Left
    HOR_2_L = 31
    # 분할 Right
    HOR_2_R = 32
  
    # 분할 X, 2 Path
    HOR_1_2P = 40
    HOR_2_L_2P = 41
    HOR_2_R_2P = 42
  
    # 분할 X, 3 Path
    HOR_1_3P = 50
    HOR_2_R_3P = 52
    HOR_2_L_3P = 51
  
    # 분할 X, 3 Path
    HOR_1_4P = 60
    HOR_2_L_4P = 61
    HOR_2_R_4P = 62
    # EXT 4 이음, EXT 6 분할
    # 이음 O , 분할 X
    HOR_1_CD = 100
    # 이음 O, 분할 O (101 + 104)
    HOR_2_CD_connect = 101
    # 이음 X/O, 분할 O
    HOR_3_CD_left = 102
    # 이음 X, 분할 O (102 + 103 + 104)
    HOR_3_CD_middle = 103
    # 이음 X/O, 분할 O
    HOR_23_CD_right = 104
    # 이음 X, 분할 X (102 + 105)
    HOR_2_CD_midr = 105
  
    HOR_1_CD_2P = 110
    HOR_2_CD_connect_2P = 111
    HOR_3_CD_left_2P = 112
    HOR_3_CD_middle_2P = 113
    HOR_23_CD_right_2P = 114
    HOR_2_CD_midr_2P = 115
  
    HOR_1_CD_3P = 120
    HOR_2_CD_connect_3P = 121
    HOR_3_CD_left_3P = 122
    HOR_3_CD_middle_3P = 123
    HOR_23_CD_right_3P = 124
    HOR_2_CD_midr_3P = 125
  
    HOR_1_CD_4P = 130
    HOR_2_CD_connect_4P = 131
    HOR_3_CD_left_4P = 132
    HOR_3_CD_middle_4P = 133
    HOR_23_CD_right_4P = 134
    HOR_2_CD_midr_4P = 135
  
    RHOR_1_CD = 150
    RHOR_2_CD_connect = 151
    RHOR_3_CD_left = 152
    RHOR_3_CD_middle = 153
    RHOR_23_CD_right = 154
    RHOR_2_CD_midr = 155
  
    RHOR_1_CD_2P = 160
    RHOR_2_CD_connect_2P = 161
    RHOR_3_CD_left_2P = 162
    RHOR_3_CD_middle_2P = 163
    RHOR_23_CD_right_2P = 164
    RHOR_2_CD_midr_2P = 165
  
    RHOR_1_CD_3P = 170
    RHOR_2_CD_connect_3P = 171
    RHOR_3_CD_left_3P = 172
    RHOR_3_CD_middle_3P = 173
    RHOR_23_CD_right_3P = 174
    RHOR_2_CD_midr_3P = 175
  
    RHOR_1_CD_4P = 180
    RHOR_2_CD_connect_4P = 181
    RHOR_3_CD_left_4P = 182
    RHOR_3_CD_middle_4P = 183
    RHOR_23_CD_right_4P = 184
    RHOR_2_CD_midr_4P = 185
  
    l_var = 0
    l_counter=1
    multi_path_n = 10
    if(thickness_2f >=11):
      l_counter = 4
    elif(thickness_2f >=9):
      l_counter = 3
    elif(thickness_2f >=7):
      l_counter = 2
    end
  
    if(Cell_l[VL2]==True):
      return_pose[ex] = VL2
      ex = ex + 1
    end
    if(Cell_l[VR2]==True):
      return_pose[ex] = VR2
      ex = ex + 1
    end
  
    if(Cell_l[HOR_ML]==True or Cell_l[HOR_MR]==True ):
      if(Cell_l[HOR_MR]==True):
        MLMR = 50
      else:
        MLMR = 0
      end
      # ext 4 => 이음, ext 6 = > 분할
      while(l_var<l_counter):
        if(ext_flag_pend[4]==True and (cell_info_l!=cell_c and cell_info_l !=cell_d and cell_info_r!=cell_c and cell_info_r !=cell_d)):
          if(ext_flag_pend[6]==True):
            return_pose[ex] = HOR_2_CD_connect + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_23_CD_right + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          else:
            return_pose[ex] = HOR_1_CD + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          end
        else:
          if(ext_flag_pend[6]==True):
            return_pose[ex] = HOR_3_CD_left + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_3_CD_middle + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_23_CD_right + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          else:
            return_pose[ex] = HOR_3_CD_left + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
            return_pose[ex] = HOR_2_CD_midr + MLMR + (multi_path_n * l_var)
            ex = ex + 1
            num_2f = num_2f + 1
          end
        end
        l_var = l_var + 1
      end
    elif(Cell_l[HOR]==True):
      while(l_var<l_counter):
        if(ext_flag_pend[6]==True):
          return_pose[ex] = HOR_2_L + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
          return_pose[ex] = HOR_2_R + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
        else:
          return_pose[ex] = HOR_1 + (multi_path_n * l_var)
          ex = ex + 1
          num_2f = num_2f + 1
        end
        l_var = l_var + 1
      end
    end
    write_port_register(140,num_2f)
  
    if(Cell_l[VL1]==True):
      return_pose[ex] = VL1
      ex = ex + 1
    end
    if(Cell_l[VR1]==True):
      return_pose[ex] = VR1
      ex = ex + 1
    end
    return return_pose
  end
  
  def cell_num(Num):
    var_i = 0
    while(var_i<14):
      if(Num[var_i] == 0):
        return var_i
      else:
        var_i = var_i+1
      end
    end
    return var_i
  end
  
  def singularity_inner(target_pose):
    global angle_margin=4
    global inner_UR3e=0.18
    global outer_UR3e=0.45
    global cj= get_actual_joint_positions()
    global cp=get_actual_tool_flange_pose()
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1])
    if (distance_tool<inner_UR3e):
      global msg="inner singularity"
      return True
    end
    return False
  end
  #singularity check
  
  def singularity(target_pose,hard_mode=False):
    if(hard_mode):
      global angle_margin=15
      global inner_UR3e=0.215
      global outer_UR3e=0.5
    else:
      global angle_margin=8
      global inner_UR3e=0.18
      global outer_UR3e=0.56
    end
    global cj= get_actual_joint_positions()
    global cp=get_actual_tool_flange_pose()
    if (r2d(cj[4])>-angle_margin  and  r2d(cj[4]) <= angle_margin):
      global msg="wirst singularity"
      return True
    else:
      if (r2d(cj[4])>-angle_margin+180  and  r2d(cj[4])<angle_margin+180):
        global msg="wirst singularity"
        return True
      end
    end
  
    if (r2d(cj[2])>-angle_margin  and  r2d(cj[2]) <= angle_margin):
      global msg="wirst singularity2"
      return True
    end
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1])
    if (distance_tool<inner_UR3e):
      global msg="inner singularity"
      return True
    end
    global distance_tool=sqrt(cp[0]*cp[0]+cp[1]*cp[1]+cp[2]*cp[2])
    if (distance_tool>outer_UR3e):
      global msg="outer singularity"
      return True
    end
    return False
  end
  #
  
  def contact_fun(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    if(isTouchWCR):
      get_contact_p = contact_fun_wcr(feature,direction,position_distance,fun_speed,fun_acc,back_trig,back_dis,sens)
    else:
      get_contact_p = contact_fun_sens(feature,direction,position_distance,fun_speed,fun_acc,back_trig,back_dis,sens)
    end
    return get_contact_p
  end
  
  def check_speed():
    global act_speed = get_actual_tcp_speed()
    var_i = 0
    while(var_i <5):
      if(act_speed[var_i] >= 2.5):
        write_port_register(142,113)
        halt
      end
      var_i = var_i + 1
    end
  end
  
  def home_ym(limit_p):
    get_po = pose_trans(get_actual_tcp_pose(),p[0,0,0,0,d2r(-10),0])
    global get_sing6 = singularity(get_po,hard_mode=True)
    if(get_sing6==False):
      current_tcp = get_tcp_offset()
      set_tcp(p[0,0,0,current_tcp[3],current_tcp[4],current_tcp[5]])
      get_po = pose_trans(get_actual_tcp_pose(),p[0,0,0,0,d2r(-10),0])
      ta_j = get_inverse_kin(get_po)
      home_movej2(ta_j,limit_p)
      set_tcp(current_tcp)
    end
  end
  
  def home_movej2(target_j,limit_p,speed_j=0):
    current_j = get_actual_joint_positions()
    global diff_po_x = [0,0,0,0,0,0]
    global diff_po_y = [0,0,0,0,0,0]
    global alimit_p2 = limit_p
    if(alimit_p2[0]>0.40):
      alimit_p2[0] = alimit_p2[0] + 0.003
      global spd_j = 65
    else:
      alimit_p2[0]=0.40
      global spd_j = 80
    end
    if(speed_j>0):
      global spd_j=speed_j
    end
  
    while(not(is_steady())):
      sync()
    end
    alimit_p2[1] = norm(alimit_p2[1]) + 0.003
    alimit_p2[2] = alimit_p2[2] + 0.003
  
    global dist_j = pose_dist(get_forward_kin(target_j),get_actual_tcp_pose())
    global time_j = (dist_j*1000) / spd_j
  
    if(dist_j*1000<100):
      time_j = time_j+1
    end
    global delta_t = time_j*1000/20
    global delta_a = 0
    global t_c = [r2d(current_j[0]),r2d(current_j[1]),r2d(current_j[2]),r2d(current_j[3]),r2d(current_j[4]),r2d(current_j[5])]
    global t_c_org = t_c
    global t_j = [(r2d(target_j[0])-t_c[0]),(r2d(target_j[1])-t_c[1]),(r2d(target_j[2])-t_c[2]),(r2d(target_j[3])-t_c[3]),(r2d(target_j[4])-t_c[4]),(r2d(target_j[5])-t_c[5])]
    arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
    global arrive_p = get_forward_kin(arrive_j)
    global l_j = [1,1,1,1,1,1]
    second_t = True
  
    while(delta_a<delta_t and l_j != [0,0,0,0,0,0] ):
      l_j = [1,1,1,1,1,1]
      var_i = 0
      # if(delta_a%15==0):
      #   global g_cp = get_actual_tcp_pose()
      #   if(alimit_p2[0]>g_cp[0]):
      #     alimit_p2[0]=g_cp[0] + 0.001
      #   end
      #   if(norm(alimit_p2[1])>norm(g_cp[1])):
      #     alimit_p2[1]=norm(g_cp[1]) + 0.001
      #   end
      # end
      if(delta_a==100 and second_t == True):
        current_j = get_actual_joint_positions()
        dist_j = pose_dist(get_forward_kin(target_j),get_actual_tcp_pose())
        time_j = (dist_j*1000) / spd_j
        delta_t = time_j*1000/20
        delta_a = 0
        t_c = [r2d(current_j[0]),r2d(current_j[1]),r2d(current_j[2]),r2d(current_j[3]),r2d(current_j[4]),r2d(current_j[5])]
        t_j = [(r2d(target_j[0])-t_c[0]),(r2d(target_j[1])-t_c[1]),(r2d(target_j[2])-t_c[2]),(r2d(target_j[3])-t_c[3]),(r2d(target_j[4])-t_c[4]),(r2d(target_j[5])-t_c[5])]
        second_t = False
        global g_cp = get_actual_tcp_pose()
        if(alimit_p2[0]>g_cp[0]):
          alimit_p2[0]=g_cp[0] + 0.003
        end
      end
      while(var_i<6):
        b_p = arrive_p
        t_c[var_i] = t_c[var_i] + (t_j[var_i] * 1/delta_t) * l_j[var_i]
        arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
        arrive_p = get_forward_kin(arrive_j)
        diff_po = pose_sub (arrive_p,b_p)
        diff_po_x[var_i] = diff_po[0]
        diff_po_y[var_i] = diff_po[1]
        if(alimit_p2[0]<arrive_p[0] or alimit_p2[1]<norm(arrive_p[1]) or alimit_p2[2]<arrive_p[2] or 0/1000>arrive_p[2] or (second_t == True and delta_a<100 and diff_po[0]>0.0005)):
          t_c[var_i] = t_c[var_i] - (t_j[var_i] * 1/delta_t) * l_j[var_i]
          l_j[var_i] = 0
        elif(delta_t>100 and arrive_p[0]<0.38 and norm(arrive_p[1])<0.3):
          t_c[var_i] = t_c[var_i] + (t_j[var_i] * 1/(delta_t*3)) * l_j[var_i]
        end
        if(t_j[var_i]<0 and t_c[var_i]<r2d(target_j[var_i])):
          t_c[var_i] = t_j[var_i]
        elif(t_j[var_i]>0 and t_c[var_i]>r2d(target_j[var_i])):
          t_c[var_i] = t_j[var_i]
        end
        var_i = var_i+1
      end
      arrive_j = [d2r(t_c[0]),d2r(t_c[1]),d2r(t_c[2]),d2r(t_c[3]),d2r(t_c[4]),d2r(t_c[5])]
  
  
      if(l_j!=[0,0,0,0,0,0]):
        servoj(arrive_j,0,0,0.02,0.12,250)
      end
      delta_a = delta_a + 1
  
      sync()
    end
    stopj(2)
    if(l_j==[0,0,0,0,0,0]):
      return False
    else:
      return True
    end
  end
  
  
  def home_tilt_move():
    global g_cp = get_actual_tcp_pose()
    global g_tp = g_cp
    spd_j = 20
    g_tp[0] = g_tp[0] - 0.02
    if(g_tp[1]>0):
      g_tp[1] = g_tp[1] - 0.02
    else:
      g_tp[1] = g_tp[1] + 0.02
    end
    g_tp[2] = 0.1
    c_p = g_cp
    global dist_j = pose_dist(g_tp,g_cp)
    global time_j = (dist_j*1000) / spd_j
    global delta_t = time_j*1000/100
    global delta_a = 0
    global alpha_home = 0
  
    global get_angle_ry = welding_angle_cal_3f(g_tp[2],last_tilt_deg,last_z_bottom,1)
    T_angle = feature_offset(last_wv_wp1,p[0,0,0,d2r(last_tilt_deg[0]),d2r(last_tilt_deg[1] + get_angle_ry),d2r(last_tilt_deg[2])],last_wv_line)
    target_p = p[g_tp[0],g_tp[1],g_tp[2],T_angle[3],T_angle[4],T_angle[5]]
    movel(target_p,a=0.3,v=0.3)
    # while(delta_a<delta_t and c_p[2]>0.1):
    #   c_p = interpolate_pose(g_cp,g_tp,delta_a)
    #   global get_angle_ry = welding_angle_cal_3f(c_p[2],last_tilt_deg,last_z_bottom,1)
    #   T_angle = feature_offset(last_wv_wp1,p[0,0,0,d2r(last_tilt_deg[0]),d2r(last_tilt_deg[1] + get_angle_ry),d2r(last_tilt_deg[2])],last_wv_line)
    #   target_p = p[c_p[0],c_p[1],c_p[2],T_angle[3],T_angle[4],T_angle[5]]
    #   movel(target_p,a=0.3,v=0.3,t=0,r=0.01)
    #   delta_a = delta_a+1/delta_t
    # end
  end
  
  right_prep_p_j = [0.2742413878440857, -0.8092182318316858, -1.5809415022479456, -2.0764687697040003, 1.7196621894836426, 2.770606517791748]
  left_prep_p_j = [0.7465318441390991, -0.9293935934649866, -1.54653245607485, -2.120742146168844, 1.6612900495529175, 1.4639835357666016]
  
  right_pre_up = [-0.16877919832338506, -0.9831331411944788, -0.8493865172015589, -2.161825958882467, 1.3512022495269775, 1.6723911762237549]
  left_pre_up = [1.1051501035690308, -1.1542351881610315, -0.8232358137713831, -2.0545104185687464, 1.5833461284637451, 1.8991502523422241]
  
  def homeing(home_pos = get_inverse_kin(first_p_wp,qnear = home_pos_j),robot_dist=CELL_ROBOT_DIST,robot_width = CELL_WIDTH,robot_height=-50):
    current_jp = get_actual_joint_positions()
    global current_cp = get_actual_tcp_pose()
    global limit_p = current_cp
  
    global home_step = 0
  
    # X - FRONT, BACK
    if(current_cp[0]>0.05):
      #FRONT
      pos_dir_x=-1
    elif(current_cp[0]<-0.05):
      #BACK
      pos_dir_x=1
    else:
      pos_dir_x=0
    end
  
    if(current_cp[1]>0.05):
      #LEFT
      global pos_dir=-1
    elif(current_cp[1]<-0.05):
      #RIGHT
      global pos_dir=1
    else:
      global pos_dir=0
    end
  
    if ( pose_dist ( current_cp, Packing_pos_wp)<0.07):
      home_step = 1
      movej(home_pos,a=0.3,v=0.3)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
    if ( pose_dist ( current_cp, first_p_wp)<0.06):
      home_step = 2
      movej(home_pos,a=0.45,v=0.45)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
    if ( pose_dist ( current_cp, mounting_wp)<0.02):
      home_step = 3
      movej(pre_mounting_wp, a=0.45, v=0.45)
      movej(home_pos,a=0.45,v=0.45)
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
      return True
    end
  
  
    global dist_lastcp = point_dist(current_cp,last_pose)
    if ( current_cp[2] > 150/1000 and dist_lastcp<0.025 and last_tilt_deg != [0,0,0] and last_wv_wp1 != p[0,0,0,0,0,0] and last_wv_line != p[0,0,0,0,0,0] and last_z_bottom != 0):
      home_step=4
      home_tilt_move()
      if (pos_dir == 1 and current_cp[1]<-0.17):
          home_step=5
          movej(get_inverse_kin(right_prep_p_v,qnear=right_prep_p_j), a=1.3,v=1.3)
          movej(home_pos,a=1.3,v=1.3)
          return True
      elif (pos_dir == -1 and current_cp[1]>0.17):
          home_step=6
          movej(get_inverse_kin(left_prep_p_v,qnear=left_prep_p_j), a=1.3,v=1.3)
          movej(home_pos,a=1.3,v=1.3)
          return True
      end
      current_jp = get_actual_joint_positions()
      current_cp = get_actual_tcp_pose()
    end
  
    if ( norm(current_cp[0]) > 300/1000):
      home_step = 15
      global m_dis = 20
      if ((norm(current_cp[0])>(280)/1000) and (norm(current_cp[1])>(280)/1000)):
        global m_dis = m_dis + 20
      end
      global get_sing = singularity(get_actual_tcp_pose(),hard_mode=True)
      if(pos_dir==-1 and get_sing==False):
        # write_output_float_register(23,home_step)
        global home_step_check = True
        sing_dir = direction_singu(p[0,0,0,0,0,0],[-1,-0.5,0],m_dis,45,45,hard_mode=True)
        current_cp = get_actual_tcp_pose()
        current_jp = get_actual_joint_positions()
        limit_p[0] = current_cp[0]
        limit_p[1] = current_cp[1]
      elif(pos_dir==1 and get_sing==False):
        global home_step_check = True
        global sing_dir = direction_singu(p[0,0,0,0,0,0],[-1,0.5,0],m_dis,45,45,hard_mode=True)
        current_cp = get_actual_tcp_pose()
        current_jp = get_actual_joint_positions()
        limit_p[0] = current_cp[0]
        limit_p[1] = current_cp[1]
      end
    end
  
    if (pos_dir == 1):
      home_step=7
      if(current_cp[2]>0.364):
        movej(right_pre_up, a=1.3,v=1.3)
        current_cp = get_actual_tcp_pose()
      end
      if (current_cp[1]<-0.17):
        home_step=8
        movej(get_inverse_kin(right_prep_p_v,qnear=right_prep_p_j), a=1.3,v=1.3)
        movej(home_pos,a=1.3,v=1.3)
        return True
      end
    elif (pos_dir == -1):
      home_step=9
      if(current_cp[2]>0.311):
        movej(left_pre_up, a=1.3,v=1.3)
        current_cp = get_actual_tcp_pose()
      end
      if (current_cp[1]>0.17):
        home_step=10
        movej(get_inverse_kin(left_prep_p_v,qnear=left_prep_p_j), a=1.3,v=1.3)
        movej(home_pos,a=1.3,v=1.3)
        return True
      end
    end
  
    home_step=11
    movej(home_pos, a=1.3,v=1.3)
    home_step=0
  
    last_pose = p[0,0,0,0,0,0]
    last_wv_wp1 = p[0,0,0,0,0,0]
    last_wv_line = p[0,0,0,0,0,0]
    last_tilt_deg = [0,0,0]
  end
  
  def contact_fun_sens(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global force_T = p[0,0,0,0,0,0]
    global force_T_all = force()
    global contact_back_p = p[0,0,0,0,0,0]
    global touch_begin = get_actual_tcp_pose()
    global contact_trig = False
  
    thread fun_thread_contact():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
  
    thread tool_contact_thread():
      while(True):
        global force_torque = get_tcp_force()
        force_B = p[ force_torque[0], force_torque[1], force_torque[2], 0, 0, 0 ]
        torque_B = p[ force_torque[3], force_torque[4], force_torque[5], 0, 0, 0 ]
        tcp = get_actual_tcp_pose()
        rotation_BT = p[ 0, 0, 0, tcp[3], tcp[4], tcp[5] ]
        if(norm(force_T[2])>4):
          global contact_back_p = get_actual_tcp_pose()
          contact_trig = True
        else:
          contact_trig = False
        end
        force_T = pose_trans( pose_inv(rotation_BT), force_B )
        torque_T = pose_trans( pose_inv(rotation_BT), torque_B )
        force_torque_T = p[ force_T[0], force_T[1], force_T[2], torque_T[0], torque_T[1], torque_T[2] ]
        sync()
      end
    end
    while(is_steady()==False):
      sync()
    end
    zero_ftsensor()
    move_thread_han5 = run fun_thread_contact()
    contact_thread_han5 = run tool_contact_thread()
  
    while (True):
      if (norm(force_T[2]) > sens and contact_back_p != p[0,0,0,0,0,0]):
        kill move_thread_han5
        kill contact_thread_han5
        global get_contact_p = get_actual_tcp_pose()
        stopl(3.0)
        if (back_trig==True):
          contact_back_p = feature_offset(contact_back_p,p[g_d[0]*back_dis/1000,g_d[1]*back_dis/1000,g_d[2]*back_dis/1000,0,0,0],feature)
          movel(contact_back_p, a=3, v=0.1)
        end
        break
      end
      # if (point_dist(touch_begin,contact_back_p)>0.15 and contact_back_p != p[0,0,0,0,0,0]):
      #   write_port_register(142,121)
      #   halt
      # end
      sync()
    end
    return contact_back_p
  end
  
  def contact_fun_wcr(feature, direction, position_distance,fun_speed=50,fun_acc=100,back_trig=False,back_dis=0,sens = 2):
    global move_flag=0
    global g_f = feature
    global g_d= direction
    global g_pd = position_distance/1000
    global g_ac = fun_speed/1000
    global g_sp = fun_acc/1000
    global contact_back_p = p[0,0,0,0,0,0]
    global contact_trig = False
    global touch_begin = get_actual_tcp_pose()
  
    thread fun_thread_contactw():
      enter_critical
      move_flag = 1
      local towardsPos=calculate_p(g_f, g_d, g_pd)
      global tp = towardsPos
      movel(towardsPos, a=g_ac, v=g_sp)
      move_flag = 2
      exit_critical
    end
    write_welder(4,True)
    write_port_register(211,0)
    sleep(0.05)
    get_stick = read_welder(4)
    sleep(0.05)
    move_thread_hanw = run fun_thread_contactw()
    while (True):
      global contact_back_p = get_actual_tcp_pose()
      global get_stick = read_welder(4)
      global get_stick_out = read_welder_control(4)
      if(get_stick_out==False):
        write_welder(4,True)
      end
      if(isHicomm):
        touch_onoff=read_welder(4)
      else:
        touch_onoff = get_standard_digital_in(1)
      end
      if (touch_onoff):
        kill move_thread_hanw
        stopj(8.0)
        if (back_trig==True):
          back_p = feature_offset(get_actual_tcp_pose(),p[g_d[0]*back_dis/1000,g_d[1]*back_dis/1000,g_d[2]*back_dis/1000,0,0,0],feature)
          movel(back_p, a=0.05, v=0.02)
        end
        break
      end
      # if (point_dist(touch_begin,contact_back_p)>0.15 and contact_back_p != p[0,0,0,0,0,0]):
      #   write_port_register(142,121)
      #   halt
      # end
      sync()
    end
    return contact_back_p
  end
  
  def get_lr_old(get_pose,get_width,get_cell,get_distance=600,left_par2=True,par_2f=False,touch_dis=30,margin_z=30,side_touch=0,callar=0,par_cell=0,cent_line=p[0,0,0,0,0,0],angle_c=False):
    #A : 1, B : 2, C : 3, c : 4, D : 5, d :6, E : 7, e : 8
    #marzin_z : 터치높이
    margin_dis_3f = 30
    margin_dis_y = 30
    margin_dis_z = 55
    get_distance = get_distance
  
  
    if((par_cell==4 or par_cell==6) and callar > 1):
      margin_dis_3f = -50
    else:
      margin_dis_3f = 20
    end
  
    if((par_cell==1 or par_cell==3 or par_cell==4) and par_2f==False):
      touch_dis = 0
    elif((par_cell==2 or par_cell==5 or par_cell==6 or par_cell==7 or par_cell==8) and par_2f==False and callar == 0):
      #B, D, d, E
      margin_z = 0
    elif(par_cell==7 or par_cell==8 and par_2f):
      #2F e,E는 터치 높이 25 고정
      margin_z = 25
    end
  
    if(par_cell==3 or par_cell==5 or par_cell==7 or par_cell==8):
      margin_cal = 40
    else:
      margin_cal = 0
    end
    if((par_cell==5 or par_cell==6) and callar > 1):
      get_cell[1] = 0
      get_cell[2] = 0
    end
  
    if(par_2f==False):
      #3F
      if(left_par2):
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,(get_width/2-margin_dis_3f-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      else:
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,-(get_width/2-margin_dis_3f-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      end
      if(angle_c==False):
        return_v = feature_offset(return_v,p[0,0,0,0,d2r((((return_v[2]-30/1000)*1000) / 600) * 5),0],return_v)
      end
      return return_v
    else:
      #2F
      if(left_par2):## margin_dis_z -> get_width[1] up, down margin_dis_z -> get_width[2]
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,(-get_cell[1]+(get_width/2)-touch_dis-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,0,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,(-get_cell[1]+(get_width/2)-touch_dis-callar)/1000,0,0,0,0],cent_line)
        end
      else:
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,-(-get_cell[2]+(get_width/2)-touch_dis-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,0,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,-(-get_cell[2]+(get_width/2)-touch_dis-callar)/1000,0,0,0,0],cent_line)
        end
      end
      if(angle_c==False):
        r_v = pose_trans(return_v,p[0,0,0,0,0,d2r(-90)])
        return_v = feature_offset(return_v,p[0,0,0,d2r((return_v[1]*1000 / 500)*0.25) * 25,0,0],r_v)
      end
      return return_v
    end
  end
  
  
  def get_lr(get_pose,get_width,get_cell,get_distance=600,left_par2=True,par_2f=False,touch_dis=30,margin_z=30,side_touch=p[0,0,0,0,0,0],callar=0,par_cell=0,cent_line=p[0,0,0,0,0,0],angle_c=False):
    #A : 1, B : 2, C : 3, c : 4, D : 5, d :6, E : 7, e : 8
    #marzin_z : 터치높이
    margin_dis_3f = 30
    margin_dis_y = 30
    margin_dis_z = 55
    get_distance = get_distance
  
    if(side_touch[1]>=0):
      get_width_L = 0
      get_width_R = get_width
    else:
      get_width_L = get_width
      get_width_R = 0
    end
  
    if((par_cell==4 or par_cell==6) and callar > 1):
      margin_dis_3f = -50
    else:
      margin_dis_3f = 20
    end
  
    if((par_cell==1 or par_cell==3 or par_cell==4) and par_2f==False):
      touch_dis = 0
    elif((par_cell==2 or par_cell==5 or par_cell==6 or par_cell==7 or par_cell==8) and par_2f==False and callar == 0):
      #B, D, d, E
      margin_z = 0
    elif(par_cell==7 or par_cell==8 and par_2f):
      #2F e,E는 터치 높이 25 고정
      margin_z = 25
    end
  
    if(par_cell==3 or par_cell==5 or par_cell==7 or par_cell==8):
      margin_cal = 40
    else:
      margin_cal = 0
    end
    if((par_cell==5 or par_cell==6) and callar > 1):
      get_cell[1] = 0
      get_cell[2] = 0
    end
  
  
  #기존은 센터 기준 좌우면
  #이제는 사이드(왼쪽 터치 하면 왼쪽은 거기서 부터 가고 오른쪽만 신경 쓰면 되겠네)
  #사이드 터치 <-> 사이드 위치로 변경 필요
    if(par_2f==False):
      #3F
      if(left_par2):
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,side_touch[1]+(get_width_L-margin_dis_3f-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      else:
        return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,side_touch[1]-(get_width_R-margin_dis_3f-callar)/1000,(touch_dis+get_cell[1] + get_cell[0] + margin_z)/1000,get_pose[3],get_pose[4],get_pose[5]]
      end
      if(angle_c==False):
        return_v = feature_offset(return_v,p[0,0,0,0,d2r((((return_v[2]-30/1000)*1000) / 600) * 5),0],return_v)
      end
      return return_v
    else:
      #2F
      if(left_par2):## margin_dis_z -> get_width[1] up, down margin_dis_z -> get_width[2]
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,side_touch[1]+(-get_cell[1]+(get_width_L)-touch_dis-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,side_touch[1],(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,(-get_cell[1]+(get_width_L)-touch_dis-callar)/1000,0,0,0,0],cent_line)
        end
      else:
        if(cent_line==p[0,0,0,0,0,0]):
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,side_touch[1]-(-get_cell[2]+(get_width_R)-touch_dis-callar)/1000,(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
        else:
          return_v = p[(get_distance-margin_dis_y-margin_cal)/1000,side_touch[1],(margin_z + get_cell[0])/1000,get_pose[3],get_pose[4],get_pose[5]]
          return_v = feature_offset(return_v,p[0,-(-get_cell[2]+(get_width_R)-touch_dis-callar)/1000,0,0,0,0],cent_line)
        end
      end
      if(angle_c==False):
        r_v = pose_trans(return_v,p[0,0,0,0,0,d2r(-90)])
        return_v = feature_offset(return_v,p[0,0,0,d2r((return_v[1]*1000 / 500)*0.25) * 25,0,0],r_v)
      end
      return return_v
    end
  end
  
  def side_apply(apply_p,cent_line,side_t):
    offset_v = p[0,side_t/1000,0,0,0,0]
    if(cent_line==p[0,0,0,0,0,0]):
      return_v = pose_add(apply_p,offset_v)
    else:
      return_v = feature_offset(apply_p,offset_v,cent_line)
    end
    return return_v
  end
  
  def touch_angle_2f(left_dir = True,angle_get_up = [0,0,0],angle_get_down = [0,0,0]):
    if(left_dir):
      if(angle_get_up == [0,0,0]):
        touch_angle_rpy_2f_up = [-180,-55,30]
        touch_angle_rpy_2f_down = [-180,-50,30]
      else:
        touch_angle_rpy_2f_up = angle_get_up
        touch_angle_rpy_2f_down = angle_get_down
      end
      touch_angle_rot_2f_up = rpy2rotvec([d2r(touch_angle_rpy_2f_up[0]),d2r(touch_angle_rpy_2f_up[1]),d2r(touch_angle_rpy_2f_up[2])])
      touch_angle_rot_2f_down = rpy2rotvec([d2r(touch_angle_rpy_2f_down[0]),d2r(touch_angle_rpy_2f_down[1]),d2r(touch_angle_rpy_2f_down[2])])
    else:
      if(angle_get_down == [0,0,0]):
        touch_angle_rpy_2f_up = [-180,-55,-30]
        touch_angle_rpy_2f_down = [-180,-50,-30]
      else:
        touch_angle_rpy_2f_up = angle_get_up
        touch_angle_rpy_2f_down = angle_get_down
      end
      touch_angle_rot_2f_up = rpy2rotvec([d2r(touch_angle_rpy_2f_up[0]),d2r(touch_angle_rpy_2f_up[1]),d2r(touch_angle_rpy_2f_up[2])])
      touch_angle_rot_2f_down = rpy2rotvec([d2r(touch_angle_rpy_2f_down[0]),d2r(touch_angle_rpy_2f_down[1]),d2r(touch_angle_rpy_2f_down[2])])
    end
  
    touch_angle_rot = [touch_angle_rot_2f_up[0],touch_angle_rot_2f_up[1],touch_angle_rot_2f_up[2],touch_angle_rot_2f_down[0],touch_angle_rot_2f_down[1],touch_angle_rot_2f_down[2]]
    return touch_angle_rot
  end
  
  #degree ,modify
  def touch_fun_2f(start_pose,start_pose_2,left_dir = True,touch_sens=2,bottom_pose=p[0,0,0,0,0,0]):
    x_dis = 10
    next_distance = 20
  
    get_touch_angle = touch_angle_2f(left_dir)
    # start_pose_2 = p[start_pose[0],start_pose[1],start_pose[2],start_pose[3],start_pose[4],start_pose[5]]
  
    if(left_dir):
      l_dir = -1
    else:
      l_dir = +1
    end
    while(not(is_steady())):
      sync()
    end
    write_port_register(211,0)
    get_stick = read_welder(4)
    if(get_stick==False):
      write_welder(4,True)
    end
    sleep(0.1)
    global get_y_1=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-0.5,0,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[0,0,-1],x_dis,180,200)
    global get_y_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-1,0,0],next_distance,180,200)
  
    g_cp = get_actual_tcp_pose()
    g_cp = p[g_cp[0],g_cp[1],g_cp[2],start_pose_2[3],start_pose_2[4],start_pose_2[5]]
    movel(g_cp,a= 0.8,v=0.4)
  
    global get_z_2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0,0.5],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[-1,0,0],x_dis,180,200)
    global get_z_1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0,1],30,180,200)
    write_welder(4,False)
  
    result_p = touch_4p_get_middle(get_z_1,get_z_2,get_y_1,get_y_2,left_dir,bottom_pose,True)
  
    return result_p
  end
  
  def touch_fun2(start_pose,left_dir = True,touch_sens=2,par_CD=0,bottom_pose=p[0,0,0,0,0,0]):
    for_cd = 1
    if(par_CD==1):
      x_dis = 2.2
      next_distance = 5.5
      for_cd = 4
    else:
      x_dis = 20
      next_distance = 20
    end
    if(left_dir):
      l_dir = -1
    else:
      l_dir = +1
    end
    while(not(is_steady())):
      sync()
    end
    write_port_register(211,0)
    get_stick = read_welder(4)
    if(get_stick==False):
      write_welder(4,True)
    end
    sleep(0.1)
    get_y_1=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-0.5*for_cd,0,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[0,1 * l_dir*for_cd,0],x_dis,180,200)
    get_y_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[-1,0,0],next_distance,180,200)
  
    get_z_2=contact_fun(p[0,0,0,0,0,0],[0,-1 * l_dir,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,0.5 * l_dir*for_cd,0],x_dis,180,200)
    direction(p[0,0,0,0,0,0],[-1,0,0],x_dis,180,200)
    get_z_1=contact_fun(p[0,0,0,0,0,0],[0,-1 * l_dir,0],10000,15,15,  False  ,0,touch_sens)
    direction(p[0,0,0,0,0,0],[0,1 * l_dir,0],x_dis,180,200)
    write_welder(4,False)
  
    if(left_dir):
      result_p = touch_4p_get_middle(get_y_2,get_y_1,get_z_1,get_z_2,left_dir,bottom_pose)
    else:
      result_p = touch_4p_get_middle(get_z_1,get_z_2,get_y_2,get_y_1,left_dir,bottom_pose)
    end
  
    return result_p
  end
  
  def touch_4point(get_wpx1,get_wpx2,get_wpy1):
    get_wpx2[2] = get_wpx1[2]
    get_wpy1[2] = get_wpx1[2]
    global feature_right2left = get_feature_Line(get_wpx1,get_wpx2)
  
    a_p1 = get_wpx1
    a_p2 = feature_offset(get_wpx1,p[0,0.02,0,0,0,0],feature_right2left)
    a_p3 = pose_add(get_wpx1,p[0,0,0.02,0,0,0])
    global plane_p = get_feature_plane_xz(a_p1,a_p2,a_p3)
  
    global get_r1 = get_feature_pose(get_wpy1,plane_p)
    global cent_p = feature_offset(plane_p,p[get_r1[0],0,0,0,0,0] ,plane_p)
  
    return cent_p
  end
  
  def touch_xyz_get_middle(get_wpx1,get_wpx2,get_wpy1,get_wpz1):
    get_wpx1[2] = get_wpz1[2]
    get_wpx2[2] = get_wpz1[2]
    get_wpy1[2] = get_wpz1[2]
  
    global feature_right2left = get_feature_Line(get_wpx1,get_wpx2)
  
    a_p1 = get_wpx1
    a_p2 = feature_offset(get_wpx1,p[0,0.02,0,0,0,0],feature_right2left)
    a_p3 = pose_add(get_wpx1,p[0,0,0.02,0,0,0])
    global plane_p = get_feature_plane_xz(a_p1,a_p2,a_p3)
  
    get_r1 = get_feature_pose(get_wpy1,plane_p)
    cent_p = feature_offset(plane_p,p[get_r1[0],0,0,0,0,0] ,plane_p)
  
    get_r_o = feature_offset(cent_p,p[-0.02,0,0,0,0,0],plane_p)
    get_l_o = feature_offset(cent_p,p[0,0.02,0,0,0,0],plane_p)
  
    middle_lr = interpolate_pose(get_r_o,get_l_o,0.2)
    cent_p[2] = middle_lr[2]
  
    plane_test = get_feature_plane_yz(middle_lr,get_l_o,cent_p)
    # global yy_dir = get_feature_Line(middle_lr,get_l_o)
    global zz_dir = get_feature_Line(cent_p,middle_lr)
  
    g_x_dir = pose_add(middle_lr,p[0,0,0.02,0,0,0])
    # g_y_dir = feature_offset(middle_lr,p[0,0.02,0,0,0,0],plane_test)
    # g_y_dir = feature_offset(middle_lr,p[0,-0.02,0,0,0,0],yy_dir)
  
    # g_z_dir = feature_offset(middle_lr,p[0,0,0.02,0,0,0],plane_test)
    g_z_dir = feature_offset(middle_lr,p[0,-0.02,0,0,0,0],zz_dir)
  
    g_z_dir = p[g_z_dir[0],g_z_dir[1],g_z_dir[2],get_wpx1[3],get_wpx1[4],get_wpx1[5]]
  
    # global final_feature = get_feature_plane_yz(middle_lr,g_y_dir,g_z_dir)
    global final_feature = get_feature_plane_xz(middle_lr,g_x_dir,g_z_dir)
  
    get_result = p[cent_p[0],cent_p[1],cent_p[2],final_feature[3],final_feature[4],final_feature[5]]
  
    # wp_test = p[cent_p[0],cent_p[1],cent_p[2],get_wpx1[3],get_wpx1[4],get_wpx1[5]]
    # get_result = feature_offset(get_result,p[0,0,0,d2r(-15),d2r(-45),0],get_result)
    # movel(get_result)
    return get_result
  end
  
  def touch_4p_get_middle(get_wpy1,get_wpy2,get_wpz1,get_wpz2,left_dir,bottom_pose=p[0,0,0,0,0,0],f2_par=False):
    feature_right = get_feature_Line(get_wpy1,get_wpy2)
    feature_left = get_feature_Line(get_wpz1,get_wpz2)
  
    f_gap1 = feature_offset(get_wpz1,p[0,1/1000,0,0,0,0],feature_left)
    f_gap2 = feature_offset(get_wpz1,p[0,2/1000,0,0,0,0],feature_left)
    gap_r1 = get_feature_pose(f_gap1, feature_right)
    gap_r2 = get_feature_pose(f_gap2, feature_right)
    test13 = gap_r1[0]/(gap_r1[0] - gap_r2[0])
  
    cent_p = feature_offset(get_wpz1,p[0,(1+test13)/1000,0,0,0,0],feature_left)
    cent_p = p[cent_p[0],cent_p[1],cent_p[2],get_wpy1[3],get_wpy1[4],get_wpy1[5]]
  
    get_r_o = feature_offset(cent_p,p[0,-0.02,0,0,0,0],feature_right)
    get_l_o = feature_offset(cent_p,p[0,-0.02,0,0,0,0],feature_left)
  
    middle_lr = interpolate_pose(get_r_o,get_l_o,0.5)
  
    yy_dir = get_feature_Line(middle_lr,get_l_o)
    zz_dir = get_feature_Line(cent_p,middle_lr)
  
    g_y_dir = feature_offset(middle_lr,p[0,-point_dist(middle_lr,cent_p),0,0,0,0],yy_dir)
    g_z_dir = feature_offset(middle_lr,p[0,-point_dist(middle_lr,cent_p),0,0,0,0],zz_dir)
  
    final_feature = get_feature_plane_yz(middle_lr,g_y_dir,g_z_dir)
    if(False):
      cent_p[2] = bottom_pose[2]
    end
    get_result = p[cent_p[0],cent_p[1],cent_p[2],final_feature[3],final_feature[4],final_feature[5]]
  
    #movel(get_result)
  
    return get_result
  end
  
  def get_feature_pose(fun_pose,fun_plane=p[0,0,0,0,0,0]):
    fun_p_feature = pose_trans ( pose_inv (fun_plane), fun_pose)
    return fun_p_feature
  end
  
  
  def get_base_pose(fun_p_feature,fun_plane=p[0,0,0,0,0,0]):
    fun_pose = pose_trans ( fun_plane, fun_p_feature)
    return fun_pose
  end
  
  def set_pos_xyz(get_pos_h=p[0,0,0,0,0,0],set_pos_h=[0,0,0]):
    if(set_pos_h[0] != 0):
      get_pos_h[0] = set_pos_h[0]
    end
    if(set_pos_h[1] != 0):
      get_pos_h[1] = set_pos_h[1]
    end
    if(set_pos_h[2] != 0):
      get_pos_h[2] = set_pos_h[2]
    end
    return get_pos_h
  end
  
  def set_rot_rpy_deg(get_pos_h=p[0,0,0,0,0,0],set_rot_h=[0,0,0]):
    cal_p_rpy = rotvec2rpy([get_pos_h[3],get_pos_h[4],get_pos_h[5]])
    if(set_rot_h[0] != 0):
      cal_p_rpy[0] = d2r(set_rot_h[0])
    end
    if(set_rot_h[1] != 0):
      cal_p_rpy[1] = d2r(set_rot_h[1])
    end
    if(set_rot_h[2] != 0):
      cal_p_rpy[2] = d2r(set_rot_h[2])
    end
    cal_p = rpy2rotvec(cal_p_rpy)
    get_pos_h[3] = cal_p[0]
    get_pos_h[4] = cal_p[1]
    get_pos_h[5] = cal_p[2]
    return get_pos_h
  end
  thread Arc_Thread():
    while(True):
      if(ARC_T_ONOFF):
        #현재 이동할 거리
        Arc_moving_dis = point_dist(ARC_T_s_pose,ARC_T_e_pose)
        #
        Arc_current_dis = point_dist(ARC_T_s_pose,get_actual_tcp_pose())
        Arc_percent = Arc_current_dis/Arc_moving_dis*100
  
        center_p_c = get_feature_pose(get_actual_tcp_pose(),wv_Line_Feature2)
        center_p_m = get_feature_pose(T1,wv_Line_Feature2)
        if(center_p_c[1] > center_p_m[1]):
          ARC_T_Plus = 1
        else: ARC_T_Plus
          ARC_T_Plus = -1
        end
  
        ############### ARC SENSING ##############################
        ARC_T_percent_m=15
        ARC_T_percent_p=15
        if(Arc_percent < 50 and ARC_T_percent_m >= Arc_percent):
          peak_value2=100
        elif(Arc_percent >= 50 and (50-ARC_T_percent_p) <= (Arc_percent-50)):
          peak_value2=100
        else:
          peak_value2=0
        end
  
        ARC_T_percent_m2=15
        ARC_T_percent_p2=15
        #현재 적용
        if(Arc_percent < 50 and ARC_T_percent_m2 > Arc_percent):
          peak_value=50
        elif(Arc_percent >= 50 and (50-ARC_T_percent_p2) < (Arc_percent-50)):
          peak_value=50
        else:
          peak_value=0
        end
        # write_output_float_register(23,peak_value2)
        # write_output_float_register(24,Arc_percent)
        # write_output_float_register(25,ARC_T_Plus)
        sync()
      end
      sleep(0.01)
    end
  end
  
  
  thread CalThread():
    while (True):
      FB_CURRENT_UR = get_standard_analog_in(1)*100
      #FB_CURRENT_UR = get_standard_analog_in(1)*125
      FB_VOLTAGE_UR = get_standard_analog_in(0)*8
      FB_CURRENT_mod = read_port_register(212)
      FB_VOLTAGE_mod = read_port_register(213)
  
      # FB_CURRENT_UR = read_port_register(212)
      # #FB_CURRENT_UR = get_standard_analog_in(1)*125
      # FB_VOLTAGE_UR = read_port_register(212)
      # FB_CURRENT_mod = get_standard_analog_in(1)*100
      # FB_VOLTAGE_mod = get_standard_analog_in(0)*8
  
  
      FB_CURRENT_UR_org = FB_CURRENT_UR
      FB_VOLTAGE_UR_org = FB_VOLTAGE_UR
  
      write_output_float_register(2,FB_CURRENT_UR)
      write_output_float_register(3,FB_VOLTAGE_UR)
      write_port_register(131,FB_CURRENT_UR)
      write_port_register(132,FB_VOLTAGE_UR*10)
  
      if(FB_CURRENT_UR>=c_maxcut and FB_CURRENT_UR>50):
        FB_CURRENT_UR = c_maxcut
      elif(FB_CURRENT_UR<=c_mincut and FB_CURRENT_UR>50):
        FB_CURRENT_UR = c_mincut
      end
  
      if(FB_CURRENT_UR>50):
        if(current_on==False):
          current_on=True
        end
        if(ARC_T_Plus==1):
          if(peak_value==50):
            # write_output_float_register(23,5)
            one_cycle_p_count = one_cycle_p_count + 1
            one_cycle_p_accum = one_cycle_p_accum + FB_CURRENT_UR
            one_cycle_p_accum_org = one_cycle_p_accum_org + FB_CURRENT_UR_org
          end
          if(peak_value2==100):
            one_cycle_p_count2 = one_cycle_p_count2 + 1
            one_cycle_p_accum2 = one_cycle_p_accum2 + FB_CURRENT_mod
          end
        else:
          if(peak_value==50):
            # write_output_float_register(23,10)
            one_cycle_m_count = one_cycle_m_count + 1
            one_cycle_m_accum = one_cycle_m_accum + FB_CURRENT_UR
            one_cycle_m_accum_org = one_cycle_m_accum_org + FB_CURRENT_UR_org
          end
          if(peak_value2==100):
            one_cycle_m_count2 = one_cycle_m_count2 + 1
            one_cycle_m_accum2 = one_cycle_m_accum2 + FB_CURRENT_mod
          end
        end
      end
  
      GCP_b = get_actual_tcp_pose()
      GCP = get_feature_pose(get_actual_tcp_pose(),wv_Line_Feature2)
      write_output_float_register(14,GCP[0]*1000)
      write_output_float_register(15,GCP[1]*1000)
      write_output_float_register(16,GCP[2]*1000)
  
      GJP = get_actual_joint_positions()
  
      # if(get_wcr):
      #   write_output_float_register(20,1)
      # else:
      #   write_output_float_register(20,0)
      # end
  
      # write_output_float_register(21,read_port_register(201))
      sleep(0.004)
    end
  end
  
  thread diff_Thread():
    while (True):
      if(background_cal==1):
        background_cal = 0
        if(th_arc_sen[0]==1 and weld_onoff == True ):
          if(counter_average_num == squash_cycle * counter_average*2 and squash_cycle!=0):
            counter_average_num = 0
            if(th_ext_fun[2]==1):
              #squash
              squash_cycle = 0
              w_voltage = th_ext_fun[0] #org vol
              w_current = th_ext_fun[1] #org cur
              set_current_voltage(w_current,w_voltage)
              th_wv_weldpar[4] = wving_amplitude_bak
              th_wv_weldpar[1] = cir_speed_org_bak
              if(th_par_2f):
                 global wv_system_speed = calculate_2f(th_wv_weldpar[4],th_wv_wp1,th_wv_wp2,th_wv_weldpar[1],th_wv_weldpar[3],th_wving_delay,th_wving_crater,th_wv_weldpar[6])
              else:
                global wv_system_speed = calculate_3f(th_wv_weldpar[4],th_wv_wp1,th_wv_wp2,th_wv_weldpar[1],th_wv_weldpar[3],th_wving_delay)
                x_radius = x_radius / 1000
              end
              global y_radius = y_radius / 1000
              global y_radius_bak = y_radius
            end
          end
          if(counter_average_num == (waste_cycle + squash_cycle)*counter_average*2 and waste_cycle != 0):
            write_output_float_register(19,100)
            counter_average_num = counter_average_num - waste_cycle
            waste_cycle = 0
            squash_cycle = 0
            one_cycle_p_count = 0
            one_cycle_m_count = 0
            one_cycle_p_accum = 0
            one_cycle_m_accum = 0
  
            one_cycle_p_count2 = 0
            one_cycle_m_count2 = 0
            one_cycle_p_accum2 = 0
            one_cycle_m_accum2 = 0
  
            one_cycle_p_accum_org = 0
            one_cycle_m_accum_org = 0
            counter_average_num = 0
          end
          if((counter_average_num >= (counter_average*2) + ((waste_cycle+squash_cycle) * counter_average*2)) and (one_cycle_p_count != 0) and (one_cycle_m_count != 0)):
            dist_enable = True
            cycle1_plus = one_cycle_p_accum / one_cycle_p_count
            cycle1_minus = one_cycle_m_accum / one_cycle_m_count
            cycle1_middle = (cycle1_plus+cycle1_minus)/2
            cycle1_plus_org = one_cycle_p_accum_org / one_cycle_p_count
            cycle1_minus_org = one_cycle_m_accum_org / one_cycle_m_count
            cycle1_middle_org = (cycle1_plus_org+cycle1_minus_org)/2
  
            cycle1_plus2 = one_cycle_p_accum2 / one_cycle_p_count2
            cycle1_minus2 = one_cycle_m_accum2 / one_cycle_m_count2
            cycle1_middle2 = (cycle1_plus2+cycle1_minus2)/2
            write_output_float_register(9,cycle1_middle)
            write_output_float_register(6,cycle1_plus)
            write_output_float_register(7,cycle1_minus)
            write_output_float_register(27,cycle1_plus2)
            write_output_float_register(28,cycle1_minus2)
            cycle_number = cycle_number + 1
            if(cycle_done == False):
              if(th_arc_sen[5] != 0):
                Standard_Arc_Current = th_arc_sen[5]
              else:
                if(th_par_2f):
                  Standard_Arc_Current = current_to_welding_m+10
                else:
                  Standard_Arc_Current = current_to_welding_m+15
                end
              end
              write_output_float_register(8,Standard_Arc_Current)
            end
            if(cycle_number==4):
              cycle_done = True
            end
            one_cycle_p_count = 0
            one_cycle_m_count = 0
            one_cycle_p_accum = 0
            one_cycle_m_accum = 0
            one_cycle_p_accum_org = 0
            one_cycle_m_accum_org = 0
  
            one_cycle_p_count2 = 0
            one_cycle_m_count2 = 0
            one_cycle_p_accum2 = 0
            one_cycle_m_accum2 = 0
  
            # 데이터 축적
  
            # 용접 좌표계
            # Y Plus - 우측 (2F 바닥)
            # Y Minus - 좌측 (2F 벽)
            # minus- sin_dir = 1, plus - sin_dir = -1
  
            #---------------------------------------X offset --------------------------------------------
            global arc_sensing_diff = cycle1_plus - cycle1_minus
            if(norm(arc_sensing_diff) > 0.2 and record_multi==False):
              if(th_par_2f):
                if(norm(arc_sensing_diff)>15):
                  global p_gain_u = th_arc_sen[1] / 100 * 0.8
                  i_gain_u = th_arc_sen[2] / 1000 *4
                elif(norm(arc_sensing_diff)>12):
                  global p_gain_u = th_arc_sen[1] / 100 * 0.7
                  i_gain_u = th_arc_sen[2] / 1000 * 3
                elif(norm(arc_sensing_diff)>8):
                  global p_gain_u = th_arc_sen[1] / 100 * 0.6
                  i_gain_u = th_arc_sen[2] / 1000 * 3
                elif(norm(arc_sensing_diff)>5):
                  global p_gain_u = th_arc_sen[1] / 100 * 0.3
                  i_gain_u = th_arc_sen[2] / 1000 * 3
                else:
                  global p_gain_u = th_arc_sen[1] / 100 * 0.1
                  i_gain_u = th_arc_sen[2] / 1000 * 2
                end
              else:
                if(norm(arc_sensing_diff)>12):
                  p_gain_u = th_arc_sen[1] / 100 *2 #0.28
                  i_gain_u = th_arc_sen[2] / 1000 *2#0.004
                elif(norm(arc_sensing_diff)>7):
                  p_gain_u = th_arc_sen[1] / 100 * 1.5#0.14
                  i_gain_u = th_arc_sen[2] / 1000 * 1.5#0.004
                else:
                  p_gain_u = th_arc_sen[1] / 100 #0.14
                  i_gain_u = th_arc_sen[2] / 1000 #0.004
                end
              end
  
              Ts = 1/system_bus_ms
  
              if(th_par_2f):
                # arc_move = (arc_sensing_diff - th_wv_weldpar[8]) * p_gain_u
                arc_move = (arc_sensing_diff - 0) * p_gain_u
                # arc_move = (arc_sensing_diff - 3) * p_gain_u
                if(arc_move>1.5):
                  arc_move = 1.5
                elif(arc_move< -1.5):
                  arc_move = -1.5
                end
                Up = Up + arc_move
              else:
                arc_move = (arc_sensing_diff - 0) * p_gain_u
                if(arc_move>4):
                  arc_move = 4
                elif(arc_move< -4):
                  arc_move = -4
                end
                Up = Up + arc_move
              end
  
              Ui = Ui + arc_sensing_diff * i_gain_u * Ts
              Pi_sum = Up + Ui
  
              global arc_x_off = Pi_sum * arc_sens_onoff
              # if(th_par_2f==False):
              # # th_wv_wp2 = pose_add(th_wv_wp2,p[arc_x_off/1000,0,0,0,0,0])
              #   th_wv_wp2 = feature_offset(th_wv_wp2,p[0,-arc_x_off/1000,0,0,0,0],wv_Line_Feature2)
              # end
              write_output_float_register(10,Up)
              write_output_float_register(11,Ui)
  
            end
            #---------------------------------------Z offset --------------------------------------------
            #record 36-46
            global arc_sensing_diff_z = Standard_Arc_Current-cycle1_middle
            # if(norm(arc_sensing_diff_z) > 0.2 and record_multi==False):
            if(norm(arc_sensing_diff_z) > 0.2):
              if(th_par_2f):
                if(norm(arc_sensing_diff_z)>15):
                  global p_gain_u_z = th_arc_sen[3] / 100 * 1.7 #1.3 #0.05
                  i_gain_u_z = th_arc_sen[4] / 1000 * 2 #0.018
                elif(norm(arc_sensing_diff_z)>10):
                  global p_gain_u_z = th_arc_sen[3] / 100 * 1.4 #0.025
                  i_gain_u_z = th_arc_sen[4] / 1000 * 1.2 #0.008
                elif(norm(arc_sensing_diff_z)>5):
                  global p_gain_u_z = th_arc_sen[3] / 100 * 1.2 #0.025
                  i_gain_u_z = th_arc_sen[4] / 1000 * 1.2 #0.008
                else:
                  global p_gain_u_z = th_arc_sen[3] / 100 *0.4#0.015
                  i_gain_u_z = th_arc_sen[4] / 1000 *1#0.004
                end
              else:
                if(norm(arc_sensing_diff_z)>10):
                  global p_gain_u_z = th_arc_sen[3] / 100 * 3 #1.3 #0.05
                  i_gain_u_z = th_arc_sen[4] / 1000 * 3 #0.018
                elif(norm(arc_sensing_diff_z)>5):
                  global p_gain_u_z = th_arc_sen[3] / 100 * 0.8 #0.025
                  i_gain_u_z = th_arc_sen[4] / 1000 * 1.5 #0.008
                else:
                  global p_gain_u_z = th_arc_sen[3] / 100 #0.015
                  i_gain_u_z = th_arc_sen[4] / 1000 #0.004
                end
              end
  
              Ts = 1/system_bus_ms
  
              if(th_par_2f):
                arc_move_z = (arc_sensing_diff_z+0) * p_gain_u_z
                if(arc_move_z > 4):
                  arc_move_z = 4
                elif(arc_move_z < -4):
                  arc_move_z = -4
                end
                global Up_z = Up_z + arc_move_z
              else:
                arc_move_z = (arc_sensing_diff_z+0) * p_gain_u_z
                if(arc_move_z > 4):
                  arc_move_z = 4
                elif(arc_move_z < -4):
                  arc_move_z = -4
                end
                global Up_z = Up_z + arc_move_z
              end
  
              Ui_z = Ui_z + arc_sensing_diff_z * i_gain_u_z * Ts
              #
  
              global Pi_sum_z = Up_z + Ui_z
              global arc_z_off = Pi_sum_z *arc_sens_onoff
              write_output_float_register(12,Up_z)
              write_output_float_register(13,Ui_z)
              end
              counter_average_num = 0
  
              if(first_half):
                first_half = False
                th_arc_sen[1] = th_arc_sen[1] * 2
                th_arc_sen[2] = th_arc_sen[2] * 2
                th_arc_sen[3] = th_arc_sen[3] * 2
                th_arc_sen[4] = th_arc_sen[4] * 2
              end
          end
          counter_average_num = counter_average_num + 1
          sync()
        end
  
  
  
        if(th_wv_gap[0]==1):
          global T1 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          global get_angle_rx = welding_angle_cal_2f(T1[1],th_tilt_deg,vir_v,cal_off_ang_rx)
          global get_angle_ry = welding_angle_cal_3f(T1[2],th_tilt_deg,z_bottom,cal_off_ang_ry)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T1 = p[T1[0],T1[1],T1[2],T_angle[3],T_angle[4],T_angle[5]]
          ratio_t = ratio_t + 1/get_total
          write_output_float_register(19,ratio_t)
  
          T2 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T2 = p[T2[0],T2[1],T2[2],T_angle[3],T_angle[4],T_angle[5]]
  
          T_P = interpolate_pose(T1,T2,0.5)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T_P = p[T_P[0],T_P[1],T_P[2],T_angle[3],T_angle[4],T_angle[5]]
          global cur_dis = move_dis_total-get_line_dist(T1,th_wv_wp2)*1000
          global amplitude_gap = th_wv_weldpar[4] + (th_wv_gap[1]-th_wv_weldpar[4]) * (cur_dis/move_dis_total)
          global speed_gap = th_wv_weldpar[1] + (th_wv_gap[2]-th_wv_weldpar[1]) * (cur_dis/move_dis_total)
          if(th_par_2f):
            global wv_system_speed = calculate_2f(amplitude_gap,th_wv_wp1,th_wv_wp2,speed_gap,th_wv_weldpar[3],th_wving_delay,th_wving_crater)
          else:
            global wv_system_speed = calculate_3f(amplitude_gap,th_wv_wp1,th_wv_wp2,speed_gap,th_wv_weldpar[3],th_wving_delay)
          end
          y_radius = y_radius/1000
        else:
          global T1 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          global get_angle_rx = welding_angle_cal_2f(T1[1],th_tilt_deg,vir_v,cal_off_ang_rx)
          global get_angle_ry = welding_angle_cal_3f(T1[2],th_tilt_deg,z_bottom,cal_off_ang_ry)
          T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T1 = p[T1[0],T1[1],T1[2],T_angle[3],T_angle[4],T_angle[5]]
          ratio_t = ratio_t + 1/get_total
          write_output_float_register(19,ratio_t)
  
          T2 = interpolate_pose(th_wv_wp1,th_wv_wp2,ratio_t)
          # T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T2 = p[T2[0],T2[1],T2[2],T_angle[3],T_angle[4],T_angle[5]]
  
          T_P = interpolate_pose(T1,T2,0.5)
          # T_angle = feature_offset(th_wv_wp1,p[0,0,0,d2r(th_tilt_deg[0] + get_angle_rx),d2r(th_tilt_deg[1] + get_angle_ry),d2r(th_tilt_deg[2])],wv_Line_Feature2)
          T_P = p[T_P[0],T_P[1],T_P[2],T_angle[3],T_angle[4],T_angle[5]]
          global cur_dis = move_dis_total-get_line_dist(T1,th_wv_wp2)*1000
        end
  
        sin_dir = sin_dir * -1
        if(th_wv_weldpar[5]==1):
          T1 = feature_offset(T1,p[0,-(arc_x_off)/1000,(arc_z_off)/1000,0,0,0],wv_Line_Feature2)
          T2 = feature_offset(T2,p[0,-(arc_x_off)/1000,(arc_z_off)/1000,0,0,0],wv_Line_Feature2)
  
          Tp1 = T1
          Tp2 = feature_offset(T_P,p[0,th_dir*y_radius*sin_dir,0,0,0,0],wv_Line_Feature2)
          Tp3 = T2
  
          write_output_float_register(4,arc_x_off)
          write_output_float_register(5,-arc_z_off)
  
          if(ratio_t + 1/get_total >= 1):
            background_pose = [Tp3,Tp3,Tp3,dumy_p]
          else:
            background_pose = [Tp1,Tp2,Tp3,dumy_p]
          end
        elif(th_wv_weldpar[5]==2):
          # 사선
          # y_radius = y_radius_bak/2
          #WORKPIEC BASE X (왼쪽,오른쪽 부터)
          # T1 = feature_offset(T1,p[(arc_x_off+plus_alpha_x)/1000,0,0,0,0,0],wp_Feature)
          # T2 = feature_offset(T2,p[(arc_x_off+plus_alpha_x)/1000,0,0,0,0,0],wp_Feature)
          #WORKPIEC BASE X (센터부터) (이녀석을 위해서 Tp1)
          T1 = feature_offset(T1,p[(arc_x_off+plus_alpha_x)/1000,0,0,0,0,0],wp_Feature)
          T2 = feature_offset(T2,p[(arc_x_off+plus_alpha_x)/1000,0,0,0,0,0],wp_Feature)
          #TOOL X
          # T1 = feature_offset(T1,p[0,-(arc_x_off+plus_alpha_x)/1000,0,0,0,0],wv_Line_Feature2)
          # T2 = feature_offset(T2,p[0,-(arc_x_off+plus_alpha_x)/1000,0,0,0,0],wv_Line_Feature2)
          #BASE Z
          if(record_multi):
            T1 = feature_offset(T1,p[0,0,(arc_z_off+plus_alpha_z)/(1000*8),0,0,0],wv_Line_Feature2)
            T2 = feature_offset(T2,p[0,0,(arc_z_off+plus_alpha_z)/(1000*8),0,0,0],wv_Line_Feature2)
          else:
            T1 = pose_add(T1,p[0,0,-(arc_z_off+plus_alpha_z)/1000,0,0,0])
            T2 = pose_add(T2,p[0,0,-(arc_z_off+plus_alpha_z)/1000,0,0,0])
          end
          #TOOL Z
          # T1 = feature_offset(T1,p[0,0,(arc_z_off+plus_alpha_z)/1000,0,0,0],wv_Line_Feature2)
          # T2 = feature_offset(T2,p[0,0,(arc_z_off+plus_alpha_z)/1000,0,0,0],wv_Line_Feature2)
  
          #BASE
          write_output_float_register(4,arc_x_off)
          write_output_float_register(5,-arc_z_off)
          #BASE
  
          # global Tp1 = feature_offset(T1,p[0,th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          #센터까지
          global Tp1 = feature_offset(T1,p[0,-th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          # Tp1 = feature_offset(T1,p[0,y_radius,0,0,0,0],wv_Line_Feature2)
          global push_angle_wv = th_wving_crater[6]
          global push_dis_wv = norm(y_radius)/tan(d2r(push_angle_wv))
  
          if(th_wv_weldpar[6] == 1):
            Tp1 = feature_offset(Tp1,p[push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
          else:
            Tp1 = feature_offset(Tp1,p[-push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
          end
  
          if(ratio_t > 1/get_total):
            global Tp2 = interpolate_pose(Tp1,Tp3,0.5)
          else:
            global Tp2 = interpolate_pose(Tp1,get_actual_tcp_pose(),0.5)
          end
          Tp2 = p[Tp2[0],Tp2[1],Tp2[2],Tp1[3],Tp1[4],Tp1[5]]
  
          # global Tp3 = feature_offset(T2,p[0,-th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
          #센터까지
          global Tp3 = feature_offset(T2,p[0,th_dir*y_radius,0,0,0,0],wv_Line_Feature2)
  
          # if(th_wv_weldpar[6] == 1):
          #   Tp3 = feature_offset(Tp3,p[push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
          # else:
          #   Tp3 = feature_offset(Tp3,p[-push_dis_wv,0,0,0,0,0],wv_Line_Feature2)
          # end
  
          global Tp4 = interpolate_pose(Tp1,Tp3,0.5)
  
          gcp = get_actual_tcp_pose()
  
          if(ratio_t + 1/get_total >= 1):
            background_pose = [Tp2,Tp1,Tp4,Tp3]
          elif(ratio_t < 1/get_total):
            background_pose = [Tp3,Tp3,Tp3,Tp3]
          else:
            background_pose = [Tp2,Tp1,Tp4,Tp3]
          end
        end
      end
      #168:arc on/off,  169:stick +- 1 mm 170 - 2 next
      get_stick_2 = read_port_register(169)
      if(welding_off_t == 1 and weld_onoff == True):
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
      elif(welding_off_t == 2 and weld_onoff == False and program_weld_on == True and next_path_c == False):
        write_welder(0,True)
      end
      if(get_stick_2==1):
        th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,2/1000,0,0,0],wv_Line_Feature2)
        write_port_register(169,0)
      elif(get_stick_2==2):
        th_wv_wp2 = feature_offset(th_wv_wp2,p[0,0,-2/1000,0,0,0],wv_Line_Feature2)
        write_port_register(169,0)
      end
      if(read_port_register(167)>=1):
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
        next_path_c = True
        ratio_t = 1.5
        global current_list=999
      end
      background_ready=1
      sync()
    end
  end
  
  def welding_angle_cal_2f_old(c_pos,tilt_deg,vir_v,cal_off_ang_rx):
    if(cal_off_ang_rx==1):
      global wdangle = (((c_pos*1000 / 500*0.65)+0.35*vir_v) * tilt_deg[0])-tilt_deg[0]
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def welding_angle_cal_2f(c_pos,tilt_deg,vir_v,cal_off_ang_rx):
    if(cal_off_ang_rx==1):
      global wdangle = ((c_pos*1000 / 500) * tilt_deg[0])-tilt_deg[0]
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def welding_angle_cal_3f(c_pos,tilt_deg,z_bottom,cal_off_ang_ry):
    if(cal_off_ang_ry==1):
      global wdangle = (((c_pos-z_bottom)*1000) / 600) * 47 # start -27
    else:
      global wdangle = 0
    end
    return wdangle
  end
  
  def inv_inching(time = 0.3):
    write_welder(2,True)
    sleep(time)
    write_welder(2,False)
  end
  
  def read_welder(status):
    if(isHicomm):
      return read_welder_hicomm(status)
    else:
      return read_welder_analog(status)
    end
  end
  
  def read_welder_hicomm(status):
    #status 4 - stick, 5 - WCR
    status_addr = [1,2,4,8,16,32,64,128]
    global r_data = read_port_register(211)
    global b_data = integer_to_binary_list(r_data)
    if(status_addr[status]<=r_data):
      return b_data[status]
    else:
      return False
    end
  end
  #0 - wcr, 1 - stick
  def read_welder_analog(status):
    #status 4 - stick, 5 - WCR
    # stick 1, WCR - 0번 digital INPUT
    status_addr = [6,6,6,6,1,0,6,6]
    return get_standard_digital_in(status_addr[status])
  end
  
  def read_welder_control(status):
    if(isHicomm):
      return read_welder_control_hicomm(status)
    else:
      return read_welder_control_analog(status)
    end
  end
  
  def read_welder_control_hicomm(status):
    #status 0 - torch, 1 - inch, 2 - inverse inch, 3 - gas check, 4 - stick check, 6 - robot error
    status_addr = [1,2,4,8,16,32,64,128]
    global r_data = read_port_register(202)
    global b_data = integer_to_binary_list(r_data)
    if(status_addr[status]<=r_data):
      return b_data[status]
    else:
      return False
    end
  end
  #DI 0: wcr, 1:stick , 2:error
  #DO - 0:torch,1:inching,2:invser,3:gas check, 4:touch
  #status 0 - torch, 1 - inchX, 2 - inverse inchX, 3 - gas checkX, 4 - stick check, 6 - robot errorX
  # touch 4 ,torch - 0 digital INPUT
  def read_welder_control_analog(status):
    status_addr = [0,1,2,3,4,5]
    return get_standard_digital_out(status_addr[status])
  end
  
  def write_welder(status,w_value):
    if(isHicomm):
      write_welder_hicomm(status,w_value)
    else:
      write_welder_analog(status,w_value)
    end
  end
  
  def write_welder_hicomm(status,w_value):
    #status 0 - torch, 1 - inch, 2 - inverse inch, 3 - gas check, 4 - stick check, 6 - robot error
    status_addr = [1,2,4,8,16,64]
    write_port_register(201,1)
    if(w_value):
      r_data = status_addr[status]
    elif(w_value==False):
      r_data = 0
    end
    write_port_register(202,r_data)
    write_port_register(149,r_data)
    # write_output_float_register(22,r_data)
  end
  
    #status 0 - torch, 1 - inchX, 2 - inverse inchX, 3 - gas checkX, 4 - stick check, 6 - robot errorX
    # touch 4, touch - 0 digital INPUT
  def write_welder_analog(status,w_value):
    status_addr = [0,1,2,3,4,5]
    set_standard_digital_out(status_addr[status],w_value)
    # write_output_float_register(22,status_addr[status])
  end
  
  def ori_move(origin_pose,angle_pose):
    global get_ori_p = p[origin_pose[0],origin_pose[1],origin_pose[2],angle_pose[3],angle_pose[4],angle_pose[5]]
    movel(get_ori_p,a=0.8,v=0.4)
  end
  
  def ori_pose(origin_pose,angle_pose):
    return p[origin_pose[0],origin_pose[1],origin_pose[2],angle_pose[3],angle_pose[4],angle_pose[5]]
  end
  
  def put_pose(origin_pose,put_index,put_value):
    origin_pose[put_index]=put_value
    return origin_pose
  end
  
  def register_read(register_num):
    r_data = read_port_register(register_num)
    if(r_data> 32768):
      return r_data - 65535
    else:
      return r_data
    end
  end
  
  def tilt_2f_fun(get_p,tilt_deg,welding_dir,rotat = False,get_feature=p[0,0,0,0,0,0]):
    if(get_feature==p[0,0,0,0,0,0]):
      get_feature = get_p
    end
    if(welding_dir==-1):
      vir_v = -1
    else:
      vir_v = 1
    end
    cal_off_ang_rx = 1
    get_angle_rx = welding_angle_cal_2f(get_p[1],tilt_deg,vir_v,cal_off_ang_rx)
  
    if(rotat==False):
      get_p = pose_trans(get_p,p[0,0,0,0,0,d2r(-90)])
    end
    get_p = feature_offset(get_p,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1]),d2r(tilt_deg[2])],get_feature)
    return get_p
  end
  
  def tilt_3f_fun(get_p,tilt_deg,z_bottom,get_feature=p[0,0,0,0,0,0]):
    if(get_feature==p[0,0,0,0,0,0]):
      get_feature = get_p
    end
    cal_off_ang_ry = 1
    global get_angle_ry = welding_angle_cal_3f(get_p[2],tilt_deg,z_bottom,cal_off_ang_ry)
    get_p = feature_offset(get_p,p[0,0,0,d2r(tilt_deg[0]),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],get_feature)
    return get_p
  end
  
  def calculate_3f(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay):
    # y_radius of tri wave is wving_amplitude (mm)
    global y_radius = wving_amplitude / 2
    # get total line distance without rotation (mm)
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis2 = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
    #global wving_frequency_2 = wving_frequency
  
    #Circle_Speed=(a2_speed_cpm/6)*(a4_wv_frequency*(b3_wv_delay1+b4_wv_delay2+b5_wv_delay3+b6_wv_delay4)+1)*1.2
    #cpm - cm per minute 1 cpm - 10mm per minute = 1/6mm per second = cpm * 1/6 mm/sec
    # total running time (sec) - cir_speed_org cpm.
    global wv_times_org = move_dis/(cir_speed_org/6)
    global wv_times = wv_times_org
  
    # wv tri total count (times) - speed and arrive right position is more important so floor hz
    # dwell time 0.4 초면 1.4초당 3.3회를 해야 한다.
    # total time 100초, delay 1초, hz5 - 2sec 5times. 100/5*2
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
  
    system_delay = 0.12044 + (wving_frequency-1)*0.038
    wv_times = wv_times_org - (wv_total_hz*2*system_delay)
    # wv_total_hz = floor(wv_times*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
  
    # wv tri_half total count (times)
    global get_total = wv_total_hz*2
    # wv step -> final value should be same with get_total
  
    # x radius of tri wave
    global x_radius = (move_dis/wv_total_hz)
    # single wave distance
    global wave_dis = sqrt((x_radius*x_radius)+(y_radius*y_radius))*4
    # total robot distance
    global total_dis = wv_total_hz * wave_dis
  
    # robot speed distance/time = speed
    wv_system_speed = total_dis / (wv_times)
    if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  
  
  def set_current_voltage(o_cur,o_vol):
    if(isHicomm):
      set_current_voltage_hicomm(o_cur,o_vol)
    else:
      set_current_voltage_analog(o_cur,o_vol)
    end
  end
  
  def set_current_voltage_hicomm(o_cur,o_vol):
      write_port_register(204,o_cur)
      write_port_register(205,o_vol*10)
      write_port_register(133,o_cur)
      write_port_register(134,o_vol*10)
  end
  
  def set_current_voltage_analog(o_cur,o_vol):
      vol_an=((o_vol-14)/2.8)/10
      amp_an=((o_cur-60)/44)/10
      set_standard_analog_out(0,vol_an)
      set_standard_analog_out(1,amp_an)
      write_port_register(133,o_cur)
      write_port_register(134,o_vol*10)
  end
  
  def calculate_2f(wving_amplitude,tg_wv_wp1,tg_wv_wp2,cir_speed_org,wving_frequency,wving_delay,wving_crater,wving_dir):
    # 진폭
    global y_radius = wving_amplitude / 2
    # 이동 거리
    global move_dis = point_dist(tg_wv_wp1,tg_wv_wp2)*1000
    global move_dis_total = move_dis
    # total running time (sec) - cir_speed_org cpm.
    global wv_times_org = move_dis/(cir_speed_org/6)
    global wv_times = wv_times_org
    global wv_total_hz = floor(wv_times_org*wving_frequency/(1+wving_delay[0]+wving_delay[1]+wving_delay[2]+wving_delay[3]))
    global get_total = wv_total_hz
  
    dir=1
  
    ratio_t_sam = 1/get_total
    T1_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    ratio_t_sam = ratio_t_sam + 1/get_total
    T2_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
    ratio_t_sam = ratio_t_sam + 1/get_total
    T3_sam = interpolate_pose(tg_wv_wp1,tg_wv_wp2,ratio_t_sam)
  
    push_angle = wving_crater[6]
    push_dis_sam = norm(y_radius)/tan(d2r(push_angle))
    Tp1_sam = feature_offset(T2_sam,p[0,y_radius/1000,0,0,0,0],wv_Line_Feature2)
    Tp2_sam = feature_offset(T2_sam,p[0,-y_radius/1000,0,0,0,0],wv_Line_Feature2)
    Tp1_sam = feature_offset(Tp1_sam,p[wving_dir*push_dis_sam/1000,0,0,0,0,0],wv_Line_Feature2)
    Tp3_sam = feature_offset(T3_sam,p[0,-y_radius/1000,0,0,0,0],wv_Line_Feature2)
    total_step = (get_line_dist(Tp1_sam,Tp2_sam)+get_line_dist(Tp1_sam,Tp3_sam))*1000
    total_dis = wv_total_hz * total_step
  
    wv_system_speed = (total_dis / wv_times)
  
    if(wv_times == 0 or cir_speed_org == 0):
      write_port_register(142,111)
      sleep(0.5)
      halt
    end
    return wv_system_speed
  end
  def weaving_simple(wv_wp1,wv_wp3,cir_speed_org,wving_frequency,wving_amplitude,welding_on):
    wv_dist = 0
    tilt_deg = [0,0,0]
    wving_delay = [0,0,0,0]
    wving_type = 1
    Arc_sen=[0,0,0,0,0,0]
    wv_gap=[0,0,0,0]
    welding_dir=1
    z_param=[0,0,0,0,0]
    par_2f=False
    wving_crater=[0,0,0,0,0,0,0,0,0,0]
    ext_fun=[0,0,0,0,0,0,0,0,0,0,0]
    wv_seq = [0,-1]
    wv_feature=p[0,0,0,0,0,0]
    wv_weldpar=[0,cir_speed_org,0,wving_frequency,wving_amplitude,wving_type,welding_dir]
    line_weaving_tp(wv_wp1,wv_wp3,wv_weldpar,tilt_deg,wving_delay,welding_on,Arc_sen,wv_gap,z_param,par_2f,wving_crater,ext_fun,wv_seq,wv_feature)
  end
  
  def line_weaving_tp(wv_wp1,wv_wp3,wv_weldpar=[100,10,0,1,5,1,1,1,0],tilt_deg=[0,0,0],wving_delay=[0,0,0,0],welding_on=False,Arc_sen=[0,0,0,0,0,0],wv_gap=[0,0,0,0],z_param=[0,0,0,0,0],par_2f=False,wving_crater=[0,0,0,0,0,0,0,0,0,0],ext_fun=[0,0,0,0,0,0,0,0,0,0,0],wv_seq = [0,-1],wv_feature=p[0,0,0,0,0,0]):
    global start_gas_time = 2
    global counter_average = 1
    global counter_average_num = 0
    global waste_cycle = ext_fun[8]
    if(first_half):
      Arc_sen[1] = Arc_sen[1]/2
      Arc_sen[2] = Arc_sen[2]/2
      Arc_sen[3] = Arc_sen[3]/2
      Arc_sen[4] = Arc_sen[4]/2
    end
    global arc_x_off=0
    global arc_z_off=0
    global Up = 0
    global Ui = 0
    global Up_z = 0
    global Ui_z = 0
    if(wv_weldpar[7] == 1):
      global record_multi = False
    else:
      global record_multi = True
    end
    global th_ext_fun = ext_fun
    RTDE_init()
  
    # e-Series 2, CB-Seris 8
    global system_bus_ms = 2
  
    global sin_dir = wv_seq[1]
    global start_trig = False
    dir=1
    if(par_2f):
      global squash_cycle = 0
      # sin_dir = sin_dir
      sin_dir = sin_dir * -1
    else:
      global squash_cycle = ext_fun[7]
    end
    global tri_count=0
  
    global z_bottom = z_param[0]/1000
    if(wv_weldpar[6]==-1):
      #right
      global vir_v = -1
    else:
      #left
      global vir_v = 1
    end
  
    if(par_2f):
      global cal_off_ang_rx = 1
      global cal_off_ang_ry = 0
    else:
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 1
    end
  
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      tilt_deg = [0,0,0]
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 0
    end
  
    global wv_Line_Feature2 = wv_wp1
    if(wv_weldpar[0] > 650 and par_2f == False):
      wv_weldpar[0] = 650
    end
    if(wv_wp3==p[0,0,0,0,0,0]):
      global wv_wp2 = feature_offset(wv_wp1,p[wv_weldpar[0]/1000,0,0,0,0,0],wv_Line_Feature2)
    else:
      global wv_wp2 = wv_wp3
      wv_weldpar[0] = point_dist(wv_wp1,wv_wp2)*1000
      global wv_dist_bak = point_dist(wv_wp1,wv_wp2)*1000
    end
    if(wv_feature != p[0,0,0,0,0,0]):
      wv_Line_Feature2 = wv_feature
    end
    if(vir_v==1):
      line_x = get_feature_Line(wv_wp1,wv_wp2)
    else:
      line_x = get_feature_Line(wv_wp2,wv_wp1)
    end
    pp1 = feature_offset(wv_wp1,p[0,20/1000,0,0,0,0],line_x)
    pp2 = pose_add(wv_wp1,p[0,0,20/1000,0,0,0])
    global wp_Feature = get_feature_plane_yz(wv_wp1,pp1,pp2)
  
    #setting
    if(par_2f):
      #todo - 1
      global offset_2f_k = -1 * ext_fun[9]
      global offset_2f_z = 1 * ext_fun[10]
      if(wv_seq[0] == 0 or wv_seq[0] == 1):
        # line_feature = get_feature_Line(wv_wp1,wv_wp2)
        line_feature = get_feature_Line(wv_wp2,wv_wp1)
        b_p1 = wv_wp1
        b_p2 = feature_offset(wv_wp1,p[0,0.02*vir_v,0,0,0,0],line_feature)
        # b_p2 = feature_offset(wv_wp1,p[0,0.01,0,0,0,0],line_feature)
        b_p3 = pose_add(wv_wp1,p[0,0,0.02,0,0,0])
  
        global back_feature = get_feature_plane_xz(b_p1,b_p2,b_p3)
  
        wv_wp1 = pose_trans(wv_wp1,p[0,0,0,0,0,d2r(-90)])
        wv_wp1 = feature_offset(wv_wp1,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp1 = pose_add(wv_wp1,p[0,0,offset_2f_z/1000,0,0,0])
        global bak_wv_wp1 = wv_wp1
      end
        wv_wp2 = feature_offset(wv_wp2,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp2 = pose_add(wv_wp2,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp2 = p[wv_wp2[0],wv_wp2[1],wv_wp2[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        global bak_wv_wp2 = wv_wp2
    end
    if(ext_fun[2]==1 and par_2f==False):
      w_voltage = ext_fun[3]
      w_current = ext_fun[4]
      set_current_voltage(w_current,w_voltage)
      global cir_speed_org_bak = wv_weldpar[1]
      global wving_amplitude_bak = wv_weldpar[4]
      wv_weldpar[1] = ext_fun[6]
      wv_weldpar[4] = ext_fun[5]
    end
    if(par_2f):
      global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater,wv_weldpar[6])
    else:
      global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay)
      x_radius = x_radius / 1000
    end
    global wv_set_speed = wv_system_speed
    ratio_t=0
    global y_radius = y_radius / 1000
    global y_radius_bak = y_radius
    global ext_stick = 0
    global th_arc_sen=Arc_sen
    global th_wv_gap=wv_gap
    global th_tilt_deg=tilt_deg
    global last_tilt_deg = th_tilt_deg
    global last_wv_wp1 = wv_wp1
    global last_wv_line = wv_Line_Feature2
    global last_z_bottom = z_bottom
    global th_wving_crater=wving_crater
    global th_par_2f = par_2f
    global th_cir_speed_org=wv_weldpar[1]
    global th_wv_wp1 = wv_wp1
    global th_wv_wp2 = wv_wp2
    global th_wv_wp3 = wv_wp3
    global th_wv_weldpar=wv_weldpar
    global th_wving_delay=wving_delay
    global th_z_param=z_param
    global th_wv_seq = wv_seq
    global th_wv_feature=wv_feature
    global th_dir = dir
  
    # if want to use approach position
    if(wv_seq[0] ==0 or wv_seq[0] == 1):
      global get_angle_rx = welding_angle_cal_2f(wv_wp1[1],tilt_deg,vir_v,cal_off_ang_rx)
      global get_angle_ry = welding_angle_cal_3f(wv_wp1[2],tilt_deg,z_bottom,cal_off_ang_ry)
  
      target_p = feature_offset(wv_wp1,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],wv_Line_Feature2)
  
      if(wv_weldpar[2]==1):
        target_p_appr = feature_offset(target_p,p[0,0,-0.02,0,0,0],wv_Line_Feature2)
        movel(target_p_appr,a=0.5,v=0.125)
      end
      movel(target_p,a=0.5,v=0.125)
    end
    CThread = run CalThread()
    DThread = run diff_Thread()
    TThread = run thread_timer()
    AThread = run Arc_Thread()
    TTRRhread = run thread_dist_rec()
  
    global timer_counting=True
    global program_weld_on = True
  
    if(a9_wv_weldingon==True):
      while(welding_off_t==55):
        sync()
      end
      if(wving_crater[2]>0):
        set_current_voltage(wving_crater[0],wving_crater[1])
      end
      if(welding_off_t != 1):
        if(isHicomm):
          write_welder(0,True)
        else:
          set_standard_digital_out(0,True)
        end
        while(read_welder(5)==False):
          if(weld_onoff==False):
              write_welder(0,True)
          end
          sync()
        end
        if(wving_crater[2]>0):
          #Crater Begin option
          write_output_float_register(1,1)
          sleep(wving_crater[2])
          set_current_voltage(ext_fun[1],ext_fun[0])
        end
      end
    end
    start_gas_time = 0
  
    background_cal=1
    background_ready=0
    FT_trig=True
    timer_1_is_counting = True
    global welding_program = False
  
    while((ratio_t < 1)):
      if( (norm(tri_count)>=2 and par_2f==False or FT_trig==True) or (norm(tri_count)>=4 and par_2f or FT_trig==True) ):
        FT_trig = False
        while(background_ready==0):
          sync()
        end
        tri_count = 0
        background_ready = 0
        global move_p = background_pose
        wv_wp2 = th_wv_wp2
        if(par_2f):
          background_cal=1
        else:
          background_cal=1
        end
        global a_val = 3
        if(a_val >= 30):
          write_port_register(142,112)
          sleep(0.5)
          halt
        end
      end
      if(wv_weldpar[5] ==1):
          if( (sin_dir==1 and wving_delay[0]==0) or (sin_dir==-1 and wving_delay[2]==0)):
           tri_count = tri_count + 1
          end
          global target_p = move_p[tri_count]
          # write_output_float_register(24,tri_count)
          # target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
          tri_count = tri_count + 1
      elif(wv_weldpar[5] ==2):
        if((tri_count==0 and wving_delay[2]==0) or (tri_count==2 and wving_delay[0]==0)):
         tri_count = tri_count + 1
        end
        global target_p = move_p[tri_count]
        # write_output_float_register(24,tri_count)
        # target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
        tri_count = tri_count + 1
      else:
        popup("Please insert 0 - sin or 1 - triangle")
      end
      if(target_p == p[0,0,0,0,0,0]):
        target_p = get_actual_tcp_pose()
      end
      #3F tri_count 2 는 tri_count가 계속 move_p[1]만 간다
  
      # write_output_float_register(23,sin_dir)
  
      ARC_T_ONOFF = True
      ARC_T_s_pose = get_actual_tcp_pose()
      ARC_T_e_pose = target_p
      if((norm(tri_count)== 2) and wving_delay[1]>0 and par_2f):
        #down
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[1])
      elif((norm(tri_count)== 4) and wving_delay[3]>0 and par_2f):
        #4
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[3])
      elif((norm(tri_count)== 2) and sin_dir==1 and wving_delay[1]>0 and par_2f == False):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[1])
      elif((norm(tri_count)== 2) and sin_dir==-1 and wving_delay[3]>0 and par_2f == False):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[3])
      elif((norm(tri_count)== 1) and wving_delay[2]>0 and par_2f):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[2])
      elif((norm(tri_count)== 3) and wving_delay[0]>0 and par_2f):
        #3
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[0])
      else:
        movel(target_p,a=a_val,v=wv_system_speed/1000)
      end
      global last_pose = target_p
    end
    timer_1_is_counting = False
  
    if(a9_wv_weldingon == True and wving_crater[5]!=0):
      #crater end option
      set_current_voltage(wving_crater[3],wving_crater[4])
      sleep(wving_crater[5])
      program_weld_on = False
      set_current_voltage(ext_fun[1],ext_fun[0])
      if(isHicomm):
        write_port_register(202,0)
        write_port_register(149,0)
      else:
        set_standard_digital_out(0,False)
      end
      while(read_welder(5)==True):
        if(weld_onoff==True):
          write_welder(0,False)
        end
        sync()
      end
    end
    timer_counter = 0
    kill CThread
    kill DThread
    kill TThread
    kill AThread
    kill TTRRhread
    ARC_T_ONOFF=False
    timer_counter = 0
    timer_counting = False
    wcr_counter = 0
    wcr_counting = False
    get_wcr = False
    welding_off_t = 0
    plus_alpha_x = 0
    plus_alpha_z = 0
  
    if(wv_seq[0] == 0 or wv_seq[0] == 3):
      if(a9_wv_weldingon==True):
        program_weld_on = False
        write_port_register(202,0)
        write_port_register(149,0)
        write_welder(0,False)
        if(wv_weldpar[2]==1):
          target_pos = feature_offset(get_actual_tcp_pose(),p[0,0,-0.01,0,0,0],wv_Line_Feature2)
          movel(target_pos,0.5,0.01)
        end
      end
    end
    background_pose = [dumy_p,dumy_p,dumy_p,dumy_p]
    move_p = background_pose
    return sin_dir
  end
  
  
  def line_weaving_tp_l(wv_wp1,wv_wp3,wv_weldpar=[100,10,0,1,5,1,1,1,0],tilt_deg=[0,0,0],wving_delay=[0,0,0,0],welding_on=False,Arc_sen=[0,0,0,0,0,0],wv_gap=[0,0,0,0],z_param=[0,0,0,0,0],par_2f=False,wving_crater=[0,0,0,0,0,0,0,0,0,0],ext_fun=[0,0,0,0,0,0,0,0,0,0,0],wv_seq = [0,-1],wv_feature=p[0,0,0,0,0,0]):
    global start_gas_time = 2
    global counter_average = 1
    global counter_average_num = 0
    global waste_cycle = ext_fun[8]
    if(first_half):
      Arc_sen[1] = Arc_sen[1]/2
      Arc_sen[2] = Arc_sen[2]/2
      Arc_sen[3] = Arc_sen[3]/2
      Arc_sen[4] = Arc_sen[4]/2
    end
    global current_list = 0
    global wv_wp4 = wv_wp3
    global A_T1 = wv_wp4[0]
    global A_T2 = wv_wp4[1]
    global A_T3 = wv_wp4[2]
  
    global arc_x_off=0
    global arc_z_off=0
    global Up = 0
    global Ui = 0
    global Up_z = 0
    global Ui_z = 0
    global th_ext_fun = ext_fun
    if(wv_weldpar[7] == 1):
      global record_multi = False
    else:
      global record_multi = True
    end
    RTDE_init()
  
    if (wv_gap[0]==1):
      gap_check = True
      wv_gap[0]=0
    else:
      gap_check= False
    end
    # e-Series 2, CB-Seris 8
    global system_bus_ms = 2
  
    global sin_dir = wv_seq[1]
    if(par_2f):
      global squash_cycle = 0
      # sin_dir = sin_dir
      sin_dir = sin_dir * -1
    else:
      global squash_cycle = ext_fun[7]
    end
    global start_trig = False
    dir=1
  
    global tri_count=0
  
    global z_bottom = z_param[0]/1000
    if(wv_weldpar[6]==-1):
      global vir_v = -1
    else:
      global vir_v = 1
    end
  
    if(par_2f):
      global cal_off_ang_rx = 1
      global cal_off_ang_ry = 0
    else:
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 1
    end
  
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      tilt_deg = [0,0,0]
      global cal_off_ang_rx = 0
      global cal_off_ang_ry = 0
    end
  
    global wv_Line_Feature2 = wv_wp1
    if(wv_weldpar[0] > 700 and par_2f == False):
      wv_weldpar[0] = 700
    end
    if(wv_wp3[0]==p[0,0,0,0,0,0]):
      global wv_wp2 = feature_offset(wv_wp1,p[wv_weldpar[0]/1000,0,0,0,0,0],wv_Line_Feature2)
    else:
      global wv_wp2 = wv_wp4[0]
      wv_weldpar[0] = point_dist(wv_wp1,wv_wp2)*1000
      global wv_dist_bak = point_dist(wv_wp1,wv_wp2)*1000
    end
    if(wv_seq[0] == 2 or wv_seq[0] == 3):
      wv_Line_Feature2 = wv_feature
    end
    if(vir_v==1):
      line_x = get_feature_Line(wv_wp1,wv_wp2)
    else:
      line_x = get_feature_Line(wv_wp2,wv_wp1)
    end  pp1 = feature_offset(wv_wp1,p[0,20/1000,0,0,0,0],line_x)
    pp2 = pose_add(wv_wp1,p[0,0,20/1000,0,0,0])
    global wp_Feature = get_feature_plane_yz(wv_wp1,pp1,pp2)
  
    #setting
    if(par_2f):
      #todo - 1
      offset_2f_k = -1 * ext_fun[9]
      offset_2f_z = 1 * ext_fun[10]
      if(wv_seq[0] == 0 or wv_seq[0] == 1):
        line_feature = get_feature_Line(wv_wp1,wv_wp2)
        b_p1 = wv_wp1
        b_p2 = feature_offset(wv_wp1,p[0,0.01*vir_v,0,0,0,0],line_feature)
        b_p3 = pose_add(wv_wp1,p[0,0,0.01,0,0,0])
  
        back_feature = get_feature_plane_xz(b_p1,b_p2,b_p3)
        wv_wp1 = pose_trans(wv_wp1,p[0,0,0,0,0,d2r(-90)])
        wv_wp1 = feature_offset(wv_wp1,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp1 = pose_add(wv_wp1,p[0,0,offset_2f_z/1000,0,0,0])
        # wv_wp1 = pose_add(wv_wp1,p[offset_2f_k/1000,0,0,0,0,0])
      end
        # wv_wp2 = pose_add(wv_wp2,p[offset_2f_k/1000,0,0,0,0,0])
        wv_wp2 = feature_offset(wv_wp2,p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp2 = pose_add(wv_wp2,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp2 = p[wv_wp2[0],wv_wp2[1],wv_wp2[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[0],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[0] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[1],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[1] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
  
        wv_wp3_p = feature_offset(wv_wp3[2],p[0,offset_2f_k/1000,0,0,0,0],back_feature)
        wv_wp3_p = pose_add(wv_wp3_p,p[0,0,offset_2f_z/1000,0,0,0])
        wv_wp3_p = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
        wv_wp4[2] = p[wv_wp3_p[0],wv_wp3_p[1],wv_wp3_p[2],wv_wp1[3],wv_wp1[4],wv_wp1[5]]
    end
    if(ext_fun[2]==1 and par_2f==False):
      #squash
      w_voltage = ext_fun[3]
      w_current = ext_fun[4]
      set_current_voltage(w_current,w_voltage)
      global cir_speed_org_bak = wv_weldpar[1]
      global wving_amplitude_bak = wv_weldpar[4]
      wv_weldpar[1] = ext_fun[6]
      wv_weldpar[4] = ext_fun[5]
    end
    if(par_2f):
      global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater,wv_weldpar[6])
    else:
      global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp1,wv_wp2,wv_weldpar[1],wv_weldpar[3],wving_delay)
      x_radius = x_radius / 1000
    end
    global wv_set_speed = wv_system_speed
    ratio_t=0
    # mm -> m
    global y_radius = y_radius / 1000
    global y_radius_bak = y_radius
    #init for thread
    global ext_stick = 0
    global th_arc_sen=Arc_sen
    global th_wv_gap=wv_gap
    global th_tilt_deg=tilt_deg
  
    global last_tilt_deg =th_tilt_deg
    global last_wv_wp1 = wv_wp1
    global last_wv_line = wv_Line_Feature2
    global th_wving_crater=wving_crater
    global last_z_bottom = z_bottom
    global th_par_2f = par_2f
    global th_cir_speed_org=wv_weldpar[1]
    global th_wv_wp1 = wv_wp1
    global th_wv_wp2 = wv_wp2
    global th_wv_wp3 = wv_wp3[0]
    global th_wv_weldpar=wv_weldpar
    global th_wving_delay=wving_delay
    global th_z_param=z_param
    global th_wv_seq = wv_seq
    global th_wv_feature=wv_feature
    global th_dir = dir
  
    # if want to use approach position
    if(wv_seq[0] ==0 or wv_seq[0] == 1):
      global get_angle_rx = welding_angle_cal_2f(wv_wp1[1],tilt_deg,vir_v,cal_off_ang_rx)
      global get_angle_ry = welding_angle_cal_3f(wv_wp1[2],tilt_deg,z_bottom,cal_off_ang_ry)
  
      target_p = feature_offset(wv_wp1,p[0,0,0,d2r(tilt_deg[0] + get_angle_rx),d2r(tilt_deg[1] + get_angle_ry),d2r(tilt_deg[2])],wv_Line_Feature2)
  
      if(wv_weldpar[2]==1):
        target_p_appr = feature_offset(target_p,p[0,0,-0.02,0,0,0],wv_Line_Feature2)
        movel(target_p_appr,a=0.5,v=0.125)
      end
      movel(target_p,a=0.5,v=0.125)
    end
  
    CThread = run CalThread()
    DThread = run diff_Thread()
    TThread = run thread_timer()
    AThread = run Arc_Thread()
    TTRRhread = run thread_dist_rec()
  
    global timer_counting=True
    global program_weld_on = True
  
    if(a9_wv_weldingon==True):
      while(welding_off_t==55):
        sync()
      end
      if(wving_crater[2]>0):
        set_current_voltage(wving_crater[0],wving_crater[1])
      end
      if(welding_off_t != 1):
        write_welder(0,True)
        while(get_wcr==False):
          if(weld_onoff==False):
            write_welder(0,True)
          end
          sync()
        end
        if(wving_crater[2]>0):
          #Crater Begin option
          write_output_float_register(1,1)
          sleep(wving_crater[2])
          set_current_voltage(ext_fun[1],ext_fun[0])
        end
      end
    end
    start_gas_time = 0
  
    background_cal=1
    background_ready=0
    FT_trig=True
  
    timer_1_is_counting = True
  
    while((ratio_t < 1) or current_list==0 or current_list==1):
      if(ratio_t>=1 and current_list!=2):
        if (gap_check):
          gap_check = True
          wv_gap[0]=1
          th_wv_gap[0]=1
          gap_check= False
        end
        ratio_t=0
        if(current_list==0):
          wving_amp_bak = wv_weldpar[4]
          wv_weldpar[4] = wv_weldpar[4] * 1
          th_wv_weldpar[4] = wv_weldpar[4]
          circle_speed_bak = wv_weldpar[1]
          wv_weldpar[1]= wv_weldpar[1]*0.7
          th_wv_weldpar[1]= wv_weldpar[1]
        elif(current_list==1):
          wv_weldpar[4] = wving_amp_bak
          th_wv_weldpar[4] = wv_weldpar[4]
          wv_weldpar[1] = circle_speed_bak
          th_wv_weldpar[1]= wv_weldpar[1]
        end
        wv_wp1=wv_wp4[current_list]
        wv_wp2=wv_wp4[current_list+1]
        global th_wv_wp1 = wv_wp4[current_list]
        global th_wv_wp2 = wv_wp4[current_list+1]
        global th_wv_wp3 = wv_wp4[current_list+1]
        wv_system_speed_bak = wv_system_speed
        if(par_2f):
          global wv_system_speed = calculate_2f(wv_weldpar[4],wv_wp4[current_list],wv_wp4[current_list+1],wv_weldpar[1],wv_weldpar[3],wving_delay,wving_crater)
          global y_radius = y_radius / 1000
          global y_radius_bak = y_radius
        else:
          global wv_system_speed = calculate_3f(wv_weldpar[4],wv_wp4[current_list],wv_wp4[current_list+1],wv_weldpar[1],wv_weldpar[3],wving_delay)
          x_radius = x_radius / 1000
        end
        wv_system_speed = wv_system_speed_bak
        current_list=current_list+1
      end
  
      if( (norm(tri_count)>=2 and par_2f==False or FT_trig==True) or (norm(tri_count)>=4 and par_2f==True or FT_trig==True)   ):
        FT_trig = False
        while(background_ready==0):
          sync()
        end
        tri_count = 0
        background_ready = 0
        global move_p = background_pose
        wv_wp2 = th_wv_wp2
        if(par_2f):
          background_cal=1
        else:
          background_cal=1
        end
        global a_val = 3
        if(a_val >= 30):
          write_port_register(142,112)
          sleep(0.5)
          halt
        end
      end
  
      if(wv_weldpar[5] ==1):
          if( (sin_dir==1 and wving_delay[0]==0) or (sin_dir==-1 and wving_delay[2]==0)):
           tri_count = tri_count + 1
          end
          # write_output_float_register(24,tri_count)
          global target_p = move_p[tri_count]
          target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
          tri_count = tri_count + 1
      elif(wv_weldpar[5] ==2):
        if( (tri_count==1 and sin_dir==1 and wving_delay[0]==0) or (tri_count==1 and sin_dir==-1 and wving_delay[2]==0)):
         tri_count = tri_count + 1
        end
        # write_output_float_register(24,tri_count)
        global target_p = move_p[tri_count]
        target_p=p[target_p[0],target_p[1],target_p[2],target_p[3],target_p[4],target_p[5]]
        tri_count = tri_count + 1
      else:
        popup("Please insert 0 - sin or 1 - triangle")
      end
  
      if(target_p == p[0,0,0,0,0,0]):
        target_p = get_actual_tcp_pose()
      end
      # write_output_float_register(23,sin_dir)
      ARC_T_ONOFF = True
      ARC_T_s_pose = get_actual_tcp_pose()
      ARC_T_e_pose = target_p
      if((norm(tri_count)== 2) and wving_delay[1]>0 and par_2f):
        # DOWN
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[1])
      elif((norm(tri_count)== 4) and wving_delay[3]>0 and par_2f):
        #UP
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[3])
      elif((norm(tri_count)== 2) and sin_dir==1 and wving_delay[1]>0 and par_2f == False):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[1])
      elif((norm(tri_count)== 2) and sin_dir==-1 and wving_delay[3]>0 and par_2f == False):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[3])
      elif((norm(tri_count)== 1) and wving_delay[0]>0 and par_2f):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[0])
      elif((norm(tri_count)== 3) and wving_delay[2]>0 and par_2f):
        movel(target_p,a=a_val,v=wv_system_speed/1000)
        sleep(wving_delay[2])
      else:
        movel(target_p,a=a_val,v=wv_system_speed/1000)
      end
      global last_pose = target_p
    end
  
    timer_1_is_counting = False
    welding_program = True
    if(a9_wv_weldingon == True and wving_crater[5]!=0):
      #crater end option
      set_current_voltage(wving_crater[3],wving_crater[4])
      sleep(wving_crater[5])
      program_weld_on = False
      set_current_voltage(ext_fun[1],ext_fun[0])
      if(isHicomm):
        write_port_register(202,0)
        write_port_register(149,0)
      else:
        set_standard_digital_out(0,False)
      end
      while(get_wcr==True):
        if(weld_onoff==True):
          if(isHicomm):
            write_port_register(202,0)
            write_port_register(149,0)
          else:
            set_standard_digital_out(0,False)
          end
        end
        sync()
      end
    end
  
    kill CThread
    kill DThread
    kill TThread
    kill AThread
    kill TTRRhread
    ARC_T_ONOFF=False
    timer_counting = False
    wcr_counter = 0
    wcr_counting = False
    get_wcr = False
    welding_off_t = 0
    plus_alpha_x = 0
    plus_alpha_z = 0
  
    if(wv_seq[0] == 0 or wv_seq[0] == 3):
      if(a9_wv_weldingon==True):
        program_weld_on = False
        if(isHicomm):
          write_port_register(202,0)
          write_port_register(149,0)
        else:
          set_standard_digital_out(0,False)
        end
        if(wv_weldpar[2]==1):
          target_pos = feature_offset(get_actual_tcp_pose(),p[0,0,-0.01,0,0,0],wv_Line_Feature2)
          movel(target_pos,0.5,0.01)
        end
      end
    end
    background_pose = [dumy_p,dumy_p,dumy_p,dumy_p]
    move_p = background_pose
    return sin_dir
  end
  $ 152 "Reset"
  $ 153 "If Reset_Trig"
  if (Reset_Trig):
    $ 154 "Reset_Trig≔ False "
    global Reset_Trig=  False  
    $ 155 "Call robotand_cell_initalizat"
    robotand_cell_initalizat()
    $ 156 "Auto_trig≔ False "
    global Auto_trig=  False  
    $ 157 "write_port_register(cell_3f_2f_151,0)"
    write_port_register(cell_3f_2f_151,0)
    $ 158 "write_port_register(cell_info_152,0)"
    write_port_register(cell_info_152,0)
    $ 159 "write_port_register(weld_req_153,0)"
    write_port_register(weld_req_153,0)
    $ 160 "write_port_register(return_done_240,0)"
    write_port_register(return_done_240,0)
    $ 161 "write_port_register(robot_move_163,0)"
    write_port_register(robot_move_163,0)
    $ 162 "write_port_register(robot_pose_164,0)"
    write_port_register(robot_pose_164,0)
    $ 163 "write_port_register(182,0)"
    write_port_register(182,0)
    $ 164 "write_port_register(185,0)"
    write_port_register(185,0)
    $ 165 "write_port_register(201,0)"
    write_port_register(201,0)
    $ 166 "write_port_register(202,0)"
    write_port_register(202,0)
  end
  $ 167 "Welding_Init"
  $ 168 "'welding parameter initialization'"
  # 'welding parameter initialization'
  $ 169 "welding_etc"
  $ 197 "c5_wv_gap_y≔0"
  global c5_wv_gap_y=0
  $ 198 "c6_wv_gap_cpm≔0"
  global c6_wv_gap_cpm=0
  $ 199 "c9_wv_gap_freq≔0"
  global c9_wv_gap_freq=0
  $ 200 "c4_gap_enable≔0"
  global c4_gap_enable=0
  $ 201 "c7_wv_gap≔[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]"
  global c7_wv_gap=[c4_gap_enable,c5_wv_gap_y,c6_wv_gap_cpm,c9_wv_gap_freq]
  $ 202 "init_reset_modbus_server"
  $ 203 "set_tool_voltage(24)"
  set_tool_voltage(24)
  $ 204 "write_port_register(163,0)"
  write_port_register(163,0)
  $ 205 "write_port_register(164,0)"
  write_port_register(164,0)
  $ 207 "write_port_register(201,1)"
  write_port_register(201,1)
  $ 208 "write_port_register(202,0)"
  write_port_register(202,0)
  $ 1310 "Thread_2"
  thread Thread_2():
    while (True):
      $ 1311 "Thread_heartbeat"
      $ 1312 "heartbeat≔heartbeat+1"
      global heartbeat=heartbeat+1
      $ 1313 "If heartbeat>499"
      if (heartbeat>499):
        $ 1314 "heartbeat≔0"
        global heartbeat=0
      end
      $ 1315 "write_port_register(128,heartbeat)"
      write_port_register(128,heartbeat)
      $ 1325 "Wait: 1.0"
      sleep(1.0)
    end
  end
  threadId_Thread_2 = run Thread_2()
  $ 1326 "Thread_1"
  thread Thread_1():
    while (True):
      $ 1327 "thread main"
      $ 1328 "a0_Job_Mode≔read_port_register(162)"
      global a0_Job_Mode= read_port_register (162)
      $ 1329 "a1_job_move≔read_port_register(163)"
      global a1_job_move= read_port_register (163)
      $ 1330 "If red_led≟ True "
      if (get_tool_digital_out(0) ==   True  ):
        $ 1331 "Set red_led=Off"
        set_tool_digital_out(0, False)
      end
      $ 1332 "If a0_Job_Mode≟2"
      if (a0_Job_Mode == 2):
        $ 1333 "If read_port_register(arc_onoff_168)≟2"
        if ( read_port_register (arc_onoff_168) == 2):
          $ 1334 "a9_wv_weldingon≔ True "
          global a9_wv_weldingon=  True  
        else:
          $ 1335 "Else" "noBreak"
          $ 1336 "a9_wv_weldingon≔ False "
          global a9_wv_weldingon=  False  
        end
        $ 1337 "If Auto_trig"
        if (Auto_trig):
          $ 1338 "get_next_number≔read_port_register(166)"
          global get_next_number= read_port_register (166)
          $ 1339 "get_move_trig≔read_port_register(167)"
          global get_move_trig= read_port_register (167)
          $ 1340 "If get_move_trig≟1 and running_trig≟ True "
          if (get_move_trig == 1  and  running_trig ==   True  ):
            $ 1341 "If get_next_number<0 or get_next_number>30"
            if (get_next_number<0  or  get_next_number>30):
              $ 1342 "write_port_register(142,141)"
              write_port_register(142,141)
              $ 1343 "Halt"
              halt
            end
            $ 1344 "If get_next_number≠Auto_cur_cell"
            if (get_next_number != Auto_cur_cell):
              $ 1345 "running_trig≔ False "
              global running_trig=  False  
              $ 1346 "write_welder(0, False )"
              write_welder(0,  False  )
              $ 1347 "write_port_register(149,0)"
              write_port_register(149,0)
              $ 1348 "write_port_register(202,0)"
              write_port_register(202,0)
            else:
              $ 1349 "Else" "noBreak"
              $ 1350 "write_port_register(166,0)"
              write_port_register(166,0)
              $ 1351 "write_port_register(167,0)"
              write_port_register(167,0)
            end
          end
        end
        $ 1352 "If t_time>timer_1"
        if (t_time>timer_1):
          $ 1353 "write_port_register(143,timer_1)"
          write_port_register(143,timer_1)
        else:
          $ 1354 "Else" "noBreak"
          $ 1355 "write_port_register(143,timer_1)"
          write_port_register(143,timer_1)
          $ 1356 "write_port_register(144,timer_1)"
          write_port_register(144,timer_1)
        end
        $ 1357 "Monitoring touch and welding"
        $ 1358 "If read_welder_control(0) and read_port_register(130)≠1"
        if (read_welder_control(0)  and   read_port_register (130) != 1):
          $ 1359 "write_port_register(130,1)"
          write_port_register(130,1)
        else:
          $ 1360 "ElseIf read_welder_control(0) and read_port_register(130)≠0"
          if (read_welder_control(0)  and   read_port_register (130) != 0):
            $ 1361 "write_port_register(130,0)"
            write_port_register(130,0)
          end
        end
        $ 1362 "If read_welder(5)"
        if (read_welder(5)):
          $ 1363 "'check wcr in (digital)'"
          # 'check wcr in (digital)'
          $ 1364 "write_output_float_register(20,1)"
          write_output_float_register(20,1)
        else:
          $ 1365 "Else" "noBreak"
          $ 1366 "write_output_float_register(20,0)"
          write_output_float_register(20,0)
        end
        $ 1367 "If read_welder(4)"
        if (read_welder(4)):
          $ 1368 "'check touch (digital)'"
          # 'check touch (digital)'
          $ 1369 "write_output_float_register(21,1)"
          write_output_float_register(21,1)
        else:
          $ 1370 "Else" "noBreak"
          $ 1371 "write_output_float_register(21,0)"
          write_output_float_register(21,0)
        end
        $ 1372 "If read_welder_control(0)"
        if (read_welder_control(0)):
          $ 1373 "'check welding out (digital)'"
          # 'check welding out (digital)'
          $ 1374 "write_output_float_register(17,1)"
          write_output_float_register(17,1)
        else:
          $ 1375 "Else" "noBreak"
          $ 1376 "write_output_float_register(17,0)"
          write_output_float_register(17,0)
        end
        $ 1377 "If read_welder_control(4)"
        if (read_welder_control(4)):
          $ 1378 "'check touch out (digital)'"
          # 'check touch out (digital)'
          $ 1379 "write_output_float_register(18,1)"
          write_output_float_register(18,1)
        else:
          $ 1380 "Else" "noBreak"
          $ 1381 "write_output_float_register(18,0)"
          write_output_float_register(18,0)
        end
      end
      $ 1382 "If get_tool_digital_in(1)≟ True "
      if (get_tool_digital_in(1) ==   True  ):
        $ 1383 "set_tool_digital_out(1, False )"
        set_tool_digital_out(1,  False  )
      else:
        $ 1384 "Else" "noBreak"
        $ 1385 "set_tool_digital_out(1, True )"
        set_tool_digital_out(1,  True  )
      end
      $ 1386 "If red_led≟ True "
      if (get_tool_digital_out(0) ==   True  ):
        $ 1387 "Set red_led=Off"
        set_tool_digital_out(0, False)
        $ 1388 "end_freedrive_mode()"
        end_freedrive_mode()
      end
      $ 1389 "check_speed()"
      check_speed()
      $ 1390 "Wait: 0.05"
      sleep(0.05)
    end
  end
  threadId_Thread_1 = run Thread_1()
  thread EventThread():
    while (True):
      if (event_cal_on):
        $ 1392 "calculate_position"
        $ 1395 "move_i_f≔1"
        global move_i_f=1
        $ 1396 "get_pose_side≔0"
        global get_pose_side=0
        $ 1397 "Loop move_i_f<10"
        while (move_i_f<10):
          $ 1398 "If A_Touch_trig_l[move_i_f]≟ True "
          if (A_Touch_trig_l[move_i_f] ==   True  ):
            $ 1399 "If move_i_f≟A_VL1 or move_i_f≟A_VL2"
            if (move_i_f == A_VL1  or  move_i_f == A_VL2):
              $ 1400 "A_sel_v≔move_i_f"
              global A_sel_v=move_i_f
              $ 1401 "If simulation_mode"
              if (simulation_mode):
                $ 1402 "Call welding_parameter_sim"
                welding_parameter_sim()
              else:
                $ 1403 "Else" "noBreak"
                $ 1404 "Call welding_parameter_init"
                welding_parameter_init()
              end
              $ 1405 "If a8_wv_distance<5"
              if (a8_wv_distance<5):
                $ 1406 "write_port_register(142,143)"
                write_port_register(142,143)
                $ 1407 "Halt"
                halt
              end
              $ 1408 "b2_left_par≔ True "
              global b2_left_par=  True  
              $ 1409 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 1410 "If move_i_f≟A_VL2"
              if (move_i_f == A_VL2):
                $ 1411 "callar_hor≔a6_callar_hor"
                global callar_hor=a6_callar_hor
                $ 1412 "If b1_cell_info_L≟E or b1_cell_info_L≟e"
                if (b1_cell_info_L == E  or  b1_cell_info_L == e):
                  $ 1413 "'For bottom touch(zero) after offset not used now'"
                  # 'For bottom touch(zero) after offset not used now'
                  $ 1414 "vert_scallup_l≔a5_f_hole[1]"
                  global vert_scallup_l=a5_f_hole[1]
                end
                $ 1415 "b2_cell≔b1_cell_info_L"
                global b2_cell=b1_cell_info_L
                $ 1416 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)"
                global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)
              else:
                $ 1419 "Else" "noBreak"
                $ 1420 "callar_hor≔0"
                global callar_hor=0
                $ 1421 "'For bottom touch(zero) after offset not used now'"
                # 'For bottom touch(zero) after offset not used now'
                $ 1422 "vert_scallup_l≔a5_f_hole[1]"
                global vert_scallup_l=a5_f_hole[1]
                $ 1423 "b2_cell≔b1_cell_info_L"
                global b2_cell=b1_cell_info_L
                $ 1424 "get_pos≔get_lr(left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)"
                global get_pos=get_lr(p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)
              end
              $ 1425 "pre_tp≔tilt_3f_fun(get_pos,[0,0,0],0)"
              global pre_tp=tilt_3f_fun(get_pos,[0,0,0],0)
              $ 1426 "A_Prepos_l[move_i_f]=pre_tp"
              A_Prepos_l[move_i_f]=pre_tp
            else:
              $ 1427 "ElseIf move_i_f≟A_VR1 or move_i_f≟A_VR2"
              if (move_i_f == A_VR1  or  move_i_f == A_VR2):
                $ 1428 "A_sel_v≔move_i_f"
                global A_sel_v=move_i_f
                $ 1429 "If simulation_mode"
                if (simulation_mode):
                  $ 1430 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1431 "Else" "noBreak"
                  $ 1432 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1433 "If a8_wv_distance<5"
                if (a8_wv_distance<5):
                  $ 1434 "write_port_register(142,143)"
                  write_port_register(142,143)
                  $ 1435 "Halt"
                  halt
                end
                $ 1436 "b2_left_par≔ False "
                global b2_left_par=  False  
                $ 1437 "b8_wv_2f≔ False "
                global b8_wv_2f=  False  
                $ 1438 "If move_i_f≟A_VR2"
                if (move_i_f == A_VR2):
                  $ 1439 "callar_hor≔a6_callar_hor"
                  global callar_hor=a6_callar_hor
                  $ 1440 "If b1_cell_info_R≟E or b1_cell_info_R≟e"
                  if (b1_cell_info_R == E  or  b1_cell_info_R == e):
                    $ 1441 "vert_scallup_r≔a5_f_hole[1]"
                    global vert_scallup_r=a5_f_hole[1]
                  end
                  $ 1442 "b2_cell≔b1_cell_info_R"
                  global b2_cell=b1_cell_info_R
                  $ 1443 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)"
                  global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)
                else:
                  $ 1446 "Else" "noBreak"
                  $ 1447 "callar_hor≔0"
                  global callar_hor=0
                  $ 1448 "vert_scallup_r≔a5_f_hole[1]"
                  global vert_scallup_r=a5_f_hole[1]
                  $ 1449 "b2_cell≔b1_cell_info_R"
                  global b2_cell=b1_cell_info_R
                  $ 1450 "get_pos≔get_lr(right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)"
                  global get_pos=get_lr(p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,callar_hor,b2_cell,center_line)
                end
                $ 1451 "pre_tp≔tilt_3f_fun(get_pos,[0,0,0],0)"
                global pre_tp=tilt_3f_fun(get_pos,[0,0,0],0)
                $ 1452 "A_Prepos_l[move_i_f]=pre_tp"
                A_Prepos_l[move_i_f]=pre_tp
              else:
                $ 1453 "ElseIf move_i_f≟A_HOR"
                if (move_i_f == A_HOR):
                  $ 1454 "A_sel_v≔A_HOR"
                  global A_sel_v=A_HOR
                  $ 1455 "If simulation_mode"
                  if (simulation_mode):
                    $ 1456 "Call welding_parameter_sim"
                    welding_parameter_sim()
                  else:
                    $ 1457 "Else" "noBreak"
                    $ 1458 "Call welding_parameter_init"
                    welding_parameter_init()
                  end
                  $ 1459 "hor_l_scallup≔a5_f_hole[1]"
                  global hor_l_scallup=a5_f_hole[1]
                  $ 1460 "b8_wv_2f≔ True "
                  global b8_wv_2f=  True  
                  $ 1461 "b2_left_par≔ True "
                  global b2_left_par=  True  
                  $ 1462 "b2_cell≔b1_cell_info_L"
                  global b2_cell=b1_cell_info_L
                  $ 1463 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,0,b2_cell,center_line)"
                  global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,0,b2_cell,center_line)
                  $ 1464 "pre_tp≔get_pos"
                  global pre_tp=get_pos
                  $ 1465 "A_Prepos_l[move_i_f]=pre_tp"
                  A_Prepos_l[move_i_f]=pre_tp
                else:
                  $ 1466 "ElseIf move_i_f≟A_HOR_R"
                  if (move_i_f == A_HOR_R):
                    $ 1467 "A_sel_v≔A_HOR"
                    global A_sel_v=A_HOR
                    $ 1468 "If simulation_mode"
                    if (simulation_mode):
                      $ 1469 "Call welding_parameter_sim"
                      welding_parameter_sim()
                    else:
                      $ 1470 "Else" "noBreak"
                      $ 1471 "Call welding_parameter_init"
                      welding_parameter_init()
                    end
                    $ 1472 "hor_r_scallup≔a5_f_hole[2]"
                    global hor_r_scallup=a5_f_hole[2]
                    $ 1473 "b2_left_par≔ False "
                    global b2_left_par=  False  
                    $ 1474 "b8_wv_2f≔ True "
                    global b8_wv_2f=  True  
                    $ 1475 "b2_cell≔b1_cell_info_R"
                    global b2_cell=b1_cell_info_R
                    $ 1476 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,0,b2_cell,center_line)"
                    global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,0,b2_cell,center_line)
                    $ 1477 "pre_tp≔get_pos"
                    global pre_tp=get_pos
                    $ 1478 "A_Prepos_l[move_i_f]=pre_tp"
                    A_Prepos_l[move_i_f]=pre_tp
                  else:
                    $ 1479 "ElseIf move_i_f≟A_HOR_ML"
                    if (move_i_f == A_HOR_ML):
                      $ 1480 "A_sel_v≔A_HOR_ML"
                      global A_sel_v=A_HOR_ML
                      $ 1481 "If simulation_mode"
                      if (simulation_mode):
                        $ 1482 "Call welding_parameter_sim"
                        welding_parameter_sim()
                      else:
                        $ 1483 "Else" "noBreak"
                        $ 1484 "Call welding_parameter_init"
                        welding_parameter_init()
                      end
                      $ 1485 "b8_wv_2f≔ True "
                      global b8_wv_2f=  True  
                      $ 1486 "b2_left_par≔ True "
                      global b2_left_par=  True  
                      $ 1487 "b2_cell≔b1_cell_info_L"
                      global b2_cell=b1_cell_info_L
                      $ 1488 "Touch_dis≔-1*Touch_dis"
                      global Touch_dis=-1*Touch_dis
                      $ 1489 "get_pos≔get_lr(up_left,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,a6_callar_hor,b2_cell,center_line)"
                      global get_pos=get_lr(p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,a6_callar_hor,b2_cell,center_line)
                      $ 1490 "Touch_dis≔-1*Touch_dis"
                      global Touch_dis=-1*Touch_dis
                      $ 1491 "pre_tp≔get_pos"
                      global pre_tp=get_pos
                      $ 1492 "A_Prepos_l[move_i_f]=pre_tp"
                      A_Prepos_l[move_i_f]=pre_tp
                    else:
                      $ 1493 "ElseIf move_i_f≟A_HOR_MR"
                      if (move_i_f == A_HOR_MR):
                        $ 1494 "A_sel_v≔A_HOR_MR"
                        global A_sel_v=A_HOR_MR
                        $ 1495 "If simulation_mode"
                        if (simulation_mode):
                          $ 1496 "Call welding_parameter_sim"
                          welding_parameter_sim()
                        else:
                          $ 1497 "Else" "noBreak"
                          $ 1498 "Call welding_parameter_init"
                          welding_parameter_init()
                        end
                        $ 1499 "b2_left_par≔ False "
                        global b2_left_par=  False  
                        $ 1500 "b8_wv_2f≔ True "
                        global b8_wv_2f=  True  
                        $ 1501 "b2_cell≔b1_cell_info_R"
                        global b2_cell=b1_cell_info_R
                        $ 1502 "Touch_dis≔-1*Touch_dis"
                        global Touch_dis=-1*Touch_dis
                        $ 1503 "get_pos≔get_lr(up_right,a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,a6_callar_hor,b2_cell,center_line)"
                        global get_pos=get_lr(p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133],a6_f_width,a5_f_hole,a7_f_distance,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,a6_callar_hor,b2_cell,center_line)
                        $ 1504 "Touch_dis≔-1*Touch_dis"
                        global Touch_dis=-1*Touch_dis
                        $ 1505 "pre_tp≔get_pos"
                        global pre_tp=get_pos
                        $ 1506 "A_Prepos_l[move_i_f]=pre_tp"
                        A_Prepos_l[move_i_f]=pre_tp
                      end
                    end
                  end
                end
              end
            end
            $ 1507 "If move_i_f≤4"
            if (move_i_f <= 4):
              $ 1508 "A_Prepos_l[move_i_f+9]=p[0,0,0,0,0,0]"
              A_Prepos_l[move_i_f+9]=p[0,0,0,0,0,0]
            end
          end
          $ 1511 "move_i_f≔move_i_f+1"
          global move_i_f=move_i_f+1
        end
        $ 1512 "event_cal_on≔ False "
        global event_cal_on=  False  
      elif (event_side_on):
        $ 1514 "calculate_side"
        $ 1517 "Wait event_cal_on≟ False "
        while (not(event_cal_on ==   False  )):
          sync()
        end
        $ 1518 "move_i_f≔1"
        global move_i_f=1
        $ 1519 "get_pose_side≔get_pose_side_t"
        global get_pose_side=get_pose_side_t
        $ 1520 "Loop move_i_f<10"
        while (move_i_f<10):
          $ 1521 "If A_Touch_trig_l[move_i_f]≟ True "
          if (A_Touch_trig_l[move_i_f] ==   True  ):
            $ 1522 "If move_i_f≟A_VL1 or move_i_f≟A_VL2"
            if (move_i_f == A_VL1  or  move_i_f == A_VL2):
              $ 1523 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
              A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
            else:
              $ 1524 "ElseIf move_i_f≟A_VR1 or move_i_f≟A_VR2"
              if (move_i_f == A_VR1  or  move_i_f == A_VR2):
                $ 1525 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
              else:
                $ 1526 "ElseIf move_i_f≟A_HOR"
                if (move_i_f == A_HOR):
                  $ 1527 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                  A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                else:
                  $ 1528 "ElseIf move_i_f≟A_HOR_R"
                  if (move_i_f == A_HOR_R):
                    $ 1529 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                    A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                  else:
                    $ 1530 "ElseIf move_i_f≟A_HOR_ML"
                    if (move_i_f == A_HOR_ML):
                      $ 1531 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                      A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                    else:
                      $ 1532 "ElseIf move_i_f≟A_HOR_MR"
                      if (move_i_f == A_HOR_MR):
                        $ 1533 "A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)"
                        A_Prepos_l[move_i_f]=side_apply(A_Prepos_l[move_i_f],center_line,get_pose_side)
                      end
                    end
                  end
                end
              end
            end
          end
          $ 1534 "move_i_f≔move_i_f+1"
          global move_i_f=move_i_f+1
        end
        $ 1535 "event_side_on≔ False "
        global event_side_on=  False  
      elif (reset_trig):
        $ 1537 "Call reset_weld_param"
        reset_weld_param()
        $ 1538 "reset_trig≔ False "
        global reset_trig=  False  
      elif (time_cal_trig):
        $ 1540 "t_time≔time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,0)"
        global t_time=time_cal(Auto_W_num,Auto_total_cell,A_Speed_list,A_Distance_list,A_Touch_p,0)
        $ 1541 "write_port_register(144,t_time)"
        write_port_register(144,t_time)
        $ 1542 "time_cal_trig≔ False "
        global time_cal_trig=  False  
      elif (pause_trig):
        $ 1544 "s_conn≔socket_open('192.168.1.7',29999)"
        global s_conn=socket_open("192.168.1.7",29999)
        $ 1545 "s_send≔socket_send_string('pause')"
        global s_send=socket_send_string("pause")
        $ 1546 "s_send≔socket_send_byte(10)"
        global s_send=socket_send_byte(10)
        $ 1547 "socket_close()"
        socket_close()
        $ 1548 "pause_trig≔ False "
        global pause_trig=  False  
      end
      sync()
    end
  end
  eventThread = run EventThread()
  while (True):
    $ 209 "Robot Program"
    $ 227 "If simulation_mode"
    if (simulation_mode):
      $ 228 "'work mode 2'"
      # 'work mode 2'
      $ 229 "write_port_register(162,2)"
      write_port_register(162,2)
      $ 230 "touch_temp≔0"
      global touch_temp=0
    end
    $ 231 "If a0_Job_Mode≟1"
    if (a0_Job_Mode == 1):
      $ 232 "job mode 1"
      $ 233 "'JOB_MANUAL'"
      # 'JOB_MANUAL'
      $ 234 "write_port_register(robot_ready_141,1)"
      write_port_register(robot_ready_141,1)
      $ 235 "If freedrive≟ True  and freedrive_trg≟ False "
      if (get_tool_digital_in(1) ==   True    and  freedrive_trg ==   False  ):
        $ 236 "freedrive_trg≔ True "
        global freedrive_trg=  True  
        $ 237 "freedrive_mode()"
        freedrive_mode()
      else:
        $ 238 "ElseIf freedrive≟ False  and freedrive_trg≟ True "
        if (get_tool_digital_in(1) ==   False    and  freedrive_trg ==   True  ):
          $ 239 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 240 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
      end
      $ 244 "If freedrive≟ True  and save_tool≟ True "
      if (get_tool_digital_in(1) ==   True    and  get_tool_digital_in(0) ==   True  ):
        $ 248 "Wait: 0.01"
        sleep(0.01)
      else:
        $ 249 "ElseIf a1_job_move≟1"
        if (a1_job_move == 1):
          $ 250 "'Manual - Move Home/Packing/Warmup'"
          # 'Manual - Move Home/Packing/Warmup'
          $ 251 "If read_port_register(robot_pose_164)≟1"
          if ( read_port_register (robot_pose_164) == 1):
            $ 252 "write_port_register(robot_ready_141,0)"
            write_port_register(robot_ready_141,0)
            $ 253 "homeing()"
            homeing()
            $ 254 "MoveJ"
            $ 255 "Packing_pos" "breakAfter"
            movej([1.5877798795700073, -0.0173419157611292, -2.4983108679400843, -1.4065726439105433, 1.626846194267273, 3.0169763565063477], a=0.9599310885968813, v=0.9599310885968813)
          else:
            $ 256 "ElseIf read_port_register(robot_pose_164)≟2"
            if ( read_port_register (robot_pose_164) == 2):
              $ 257 "write_port_register(robot_ready_141,0)"
              write_port_register(robot_ready_141,0)
              $ 258 "homeing()"
              homeing()
            else:
              $ 259 "ElseIf read_port_register(robot_pose_164)≟3"
              global thread_flag_259=0
              thread Thread_if_259():
                $ 260 "write_port_register(robot_ready_141,0)"
                write_port_register(robot_ready_141,0)
                $ 261 "Warm-up"
                $ 262 "Loop 22 times"
                Loop_9 = 0
                while (Loop_9 < 22):
                  $ 263 "MoveJ"
                  $ 264 "Warming_1" "breakAfter"
                  movej([1.0598392486572266, -1.0896032492267054, -1.2158034483539026, -2.3403762022601526, 1.497584342956543, 2.354665517807007], a=0.17453292519943295, v=0.08726646259971647)
                  $ 265 "Warming_2" "breakAfter"
                  movej([0.7106529474258423, -1.0894954840289515, -1.215731445943014, -2.3402441183673304, 1.4977161884307861, 2.3545455932617188], a=0.17453292519943295, v=0.08726646259971647)
                  $ 266 "Warming_3" "breakAfter"
                  movej([0.8852421641349792, -1.0894234816180628, -1.215863052998678, -2.340435806904928, 1.497644305229187, 2.3545212745666504], a=0.17453292519943295, v=0.08726646259971647)
                  $ 267 "Warming_4" "breakAfter"
                  movej([0.885266125202179, -1.263935391102926, -1.2099388281451624, -2.352635685597555, 1.4888625144958496, 2.3787333965301514], a=0.17453292519943295, v=0.08726646259971647)
                  $ 268 "Wariming_5" "breakAfter"
                  movej([0.8852541446685791, -0.9149578253375452, -1.217938248311178, -2.335618321095602, 1.501125693321228, 2.3452301025390625], a=0.17453292519943295, v=0.08726646259971647)
                  $ 269 "Warming_6" "breakAfter"
                  movej([0.8852177858352661, -1.0895074049579065, -1.3828147093402308, -2.343850914631979, 1.489568829536438, 2.3598153591156006], a=0.17453292519943295, v=0.08726646259971647)
                  $ 270 "Warming_7" "breakAfter"
                  movej([0.885229766368866, -1.0894115606891077, -1.220372502003805, -2.335630242024557, 1.5009583234786987, 2.3453502655029297], a=0.17453292519943295, v=0.08726646259971647)
                  $ 271 "Warming_8" "breakAfter"
                  movej([0.6920775233962951, -1.0506328608604214, -1.2152130579572011, -2.5072867131215766, 1.4917910996963177, 2.3459413556024855], a=0.17453292519943295, v=0.08726646259971647)
                  $ 272 "Warming_9" "breakAfter"
                  movej([0.6929177641868591, -1.0475013891803187, -1.2503178755389612, -2.327541176472799, 1.5014369487762451, 2.345398187637329], a=0.17453292519943295, v=0.08726646259971647)
                  $ 273 "Warming_10" "breakAfter"
                  movej([0.8162043690681458, -1.1462538878070276, -1.3285825888263147, -2.3897975126849573, 1.2906681299209595, 2.3704988956451416], a=0.17453292519943295, v=0.08726646259971647)
                  $ 274 "Warming_11" "breakAfter"
                  movej([0.6952417412291937, -1.0226626805382075, -1.3187663864026051, -2.3852732107244847, 1.5281305955128988, 2.3484138521676003], a=0.17453292519943295, v=0.08726646259971647)
                  $ 275 "Warming_12" "breakAfter"
                  movej([0.6938896179199219, -1.0222962538348597, -1.3204510847674769, -2.403698269520895, 1.7271294593811035, 2.3448219299316406], a=0.17453292519943295, v=0.08726646259971647)
                  $ 276 "Warming_13" "breakAfter"
                  movej([0.685538113117218, -1.038980786000387, -1.3163254896747034, -2.3712590376483362, 1.5282130241394043, 2.0345256328582764], a=0.17453292519943295, v=0.08726646259971647)
                  $ 277 "Warming_14" "breakAfter"
                  movej([0.721284806728363, -1.0075753370868128, -1.3205111662494105, -2.399587933217184, 1.5282011032104492, 2.539506673812866], a=0.17453292519943295, v=0.08726646259971647)
                  Loop_9 = Loop_9 + 1
                end
                $ 278 "homeing()"
                homeing()
                $ 279 "Wait: 2.0"
                sleep(2.0)
                thread_flag_259 = 1
              end
              if ( read_port_register (robot_pose_164) == 3):
                global thread_handler_259=run Thread_if_259()
                while (thread_flag_259 == 0):
                  if not( read_port_register (robot_pose_164) == 3):
                    kill thread_handler_259
                    thread_flag_259 = 2
                  else:
                    sync()
                  end
                end
              else:
                thread_flag_259 = 2
              end
              if (thread_flag_259 == 2):
                $ 280 "ElseIf read_port_register(robot_pose_164)≟4"
                if ( read_port_register (robot_pose_164) == 4):
                  $ 281 "write_port_register(robot_ready_141,0)"
                  write_port_register(robot_ready_141,0)
                  $ 282 "homeing()"
                  homeing()
                  $ 283 "MoveJ"
                  $ 284 "pre_mounting" "breakAfter"
                  movej([1.2356762886047363, -0.8703244368182581, -0.942230526600973, -2.3905327955829065, 1.3216267824172974, 2.6514604091644287], a=0.7853981633974483, v=0.7853981633974483)
                  $ 285 "Mounting_pos" "breakAfter"
                  movej([0.6231353085164267, -0.6300961531972575, -0.9034285948871803, -1.770059340221131, 1.417516049558281, 1.7792033261567348], a=0.7853981633974483, v=0.7853981633974483)
                else:
                  $ 286 "ElseIf read_port_register(robot_pose_164)≟5"
                  if ( read_port_register (robot_pose_164) == 5):
                    $ 287 "c_p≔get_actual_tcp_pose()"
                    global c_p= get_actual_tcp_pose ()
                    $ 288 "MoveL"
                    $ 289 "m_p≔pose_trans(c_p, p[0,0,0,d2r(tilt_deg_man),0,0])"
                    global m_p= pose_trans (c_p, p[0,0,0,d2r(tilt_deg_man),0,0])
                    $ 290 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 291 "m_p≔pose_trans(c_p, p[0,0,0,d2r(-tilt_deg_man),0,0])"
                    global m_p= pose_trans (c_p, p[0,0,0,d2r(-tilt_deg_man),0,0])
                    $ 292 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 293 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                    $ 294 "m_p≔pose_trans(c_p, p[0,0,0,0,d2r(tilt_deg_man),0])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,d2r(tilt_deg_man),0])
                    $ 295 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 296 "m_p≔pose_trans(c_p, p[0,0,0,0,d2r(-tilt_deg_man),0])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,d2r(-tilt_deg_man),0])
                    $ 297 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 298 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                    $ 299 "m_p≔pose_trans(c_p, p[0,0,0,0,0,d2r(tilt_deg_man)])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,0,d2r(tilt_deg_man)])
                    $ 300 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 301 "m_p≔pose_trans(c_p, p[0,0,0,0,0,d2r(-tilt_deg_man)])"
                    global m_p= pose_trans (c_p, p[0,0,0,0,0,d2r(-tilt_deg_man)])
                    $ 302 "m_p" "breakAfter"
                    movel(pose_trans(Base, m_p), a=0.03, v=0.03)
                    $ 303 "c_p" "breakAfter"
                    movel(pose_trans(Base, c_p), a=0.03, v=0.03)
                  end
                end
              end
            end
          end
          $ 304 "Call Move_done"
          Move_done()
        end
      end
      $ 305 "Call robotand_cell_initalizat"
      robotand_cell_initalizat()
    else:
      $ 306 "ElseIf a0_Job_Mode≟2"
      global thread_flag_306=0
      thread Thread_if_306():
        $ 307 "'JOB_AUTO'"
        # 'JOB_AUTO'
        $ 308 "auto_on≔ True "
        global auto_on=  True  
        $ 309 "Init"
        $ 310 "If freedrive_trg"
        if (freedrive_trg):
          $ 311 "end_freedrive_mode()"
          end_freedrive_mode()
          $ 312 "freedrive_trg≔ False "
          global freedrive_trg=  False  
        end
        $ 313 "write_port_register(202,0)"
        write_port_register(202,0)
        $ 314 "write_port_register(robot_ready_141,0)"
        write_port_register(robot_ready_141,0)
        $ 315 "homeing()"
        homeing()
        $ 316 "Wait: 0.2"
        sleep(0.2)
        $ 317 "Cell_calculation"
        $ 318 "'setting'"
        # 'setting'
        $ 319 "Auto_trig≔ False "
        global Auto_trig=  False  
        $ 320 "If Auto_trig≟ False "
        if (Auto_trig ==   False  ):
          $ 321 "If simulation_mode"
          if (simulation_mode):
            $ 322 "b1_cell_info_L≔B"
            global b1_cell_info_L=B
            $ 323 "b1_cell_info_R≔B"
            global b1_cell_info_R=B
            $ 324 "b1_cell_select≔motion_num([A_VL1,A_VR1,A_HOR,0,0,0])"
            global b1_cell_select=motion_num([A_VL1,A_VR1,A_HOR,0,0,0])
            $ 325 "b1_cell_select≔motion_num([A_HOR,0,0,0,0,0])"
            global b1_cell_select=motion_num([A_HOR,0,0,0,0,0])
            $ 326 "EXT_flag1≔integer_to_binary_list(read_port_register(2048))"
            global EXT_flag1= integer_to_binary_list ( read_port_register (2048))
            $ 327 "b1_cell_thickne≔6"
            global b1_cell_thickne=6
            $ 328 "A_Touch_trig_l≔touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)"
            global A_Touch_trig_l=touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)
            $ 329 "Auto_W_num≔cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)"
            global Auto_W_num=cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)
            $ 331 "Auto_total_cell≔cell_num(Auto_W_num)"
            global Auto_total_cell=cell_num(Auto_W_num)
            $ 332 "Auto_trig≔ True "
            global Auto_trig=  True  
            $ 333 "A_sel_v≔Auto_W_num[0]"
            global A_sel_v=Auto_W_num[0]
          else:
            $ 334 "Else" "noBreak"
            $ 335 "b1_cell_info_L≔read_port_register(171)"
            global b1_cell_info_L= read_port_register (171)
            $ 336 "b1_cell_info_R≔read_port_register(172)"
            global b1_cell_info_R= read_port_register (172)
            $ 337 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
            global EXT_flag1= integer_to_binary_list ( read_port_register (179))
            $ 338 "b1_cell_select≔read_port_register(178)"
            global b1_cell_select= read_port_register (178)
            $ 339 "b1_cell_thickne≔read_port_register(183)"
            global b1_cell_thickne= read_port_register (183)
            $ 340 "A_Touch_trig_l≔touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)"
            global A_Touch_trig_l=touch_cal(b1_cell_info_L,b1_cell_info_R,b1_cell_select)
            $ 341 "Auto_W_num≔cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)"
            global Auto_W_num=cell_motion(A_Touch_trig_l,b1_cell_thickne,EXT_flag1,b1_cell_info_L,b1_cell_info_R)
            $ 342 "Auto_total_cell≔cell_num(Auto_W_num)"
            global Auto_total_cell=cell_num(Auto_W_num)
            $ 343 "Auto_trig≔ True "
            global Auto_trig=  True  
            $ 344 "A_sel_v≔Auto_W_num[0]"
            global A_sel_v=Auto_W_num[0]
          end
          $ 345 "write_port_register(139,Auto_total_cell-1)"
          write_port_register(139,Auto_total_cell-1)
        end
        $ 346 "Auto_cur_cell≔0"
        global Auto_cur_cell=0
        $ 347 "Touch,Welding"
        $ 348 "'Calculate total sequence and decide way'"
        # 'Calculate total sequence and decide way'
        $ 349 "Calculate & Move & Touch"
        $ 350 "touch_init"
        $ 351 "Call cell_info"
        cell_info()
        $ 352 "If simulation_mode"
        if (simulation_mode):
          $ 353 "Call welding_parameter_sim"
          welding_parameter_sim()
        else:
          $ 354 "Else" "noBreak"
          $ 355 "Call welding_parameter_init"
          welding_parameter_init()
          $ 356 "touch_temp≔read_port_register(180)"
          global touch_temp= read_port_register (180)
          $ 357 "A_cur_2f≔0"
          global A_cur_2f=0
          $ 358 "wv_direction≔1"
          global wv_direction=1
        end
        $ 359 "If touch_temp≟0"
        if (touch_temp == 0):
          $ 360 "reset Variable"
          $ 361 "A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]"
          A_Prepos_l=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]
          $ 362 "A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]"
          A_Touch_p=[p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0], p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0, 0, 0, 0, 0, 0],p[0,0,0,0,0,0]]
          $ 363 "reset_par"
          $ 364 "for_cal_rot≔p[0,0,0,0,0,0]"
          global for_cal_rot=p[0,0,0,0,0,0]
          $ 365 "for_cal_zr≔p[0,0,0,0,0,0]"
          global for_cal_zr=p[0,0,0,0,0,0]
          $ 366 "for_z_VLR2≔p[0,0,0,0,0,0]"
          global for_z_VLR2=p[0,0,0,0,0,0]
          $ 367 "for_cal_x_wel≔p[0,0,0,0,0,0]"
          global for_cal_x_wel=p[0,0,0,0,0,0]
          $ 368 "for_cal_xy≔p[0,0,0,0,0,0]"
          global for_cal_xy=p[0,0,0,0,0,0]
          $ 369 "for_cal_y_wel≔p[0,0,0,0,0,0]"
          global for_cal_y_wel=p[0,0,0,0,0,0]
          $ 370 "for_x_HOR≔p[0,0,0,0,0,0]"
          global for_x_HOR=p[0,0,0,0,0,0]
          $ 371 "for_x_HOR_R≔p[0,0,0,0,0,0]"
          global for_x_HOR_R=p[0,0,0,0,0,0]
          $ 372 "for_z_VL1≔p[0,0,0,0,0,0]"
          global for_z_VL1=p[0,0,0,0,0,0]
          $ 373 "for_z_VR1≔p[0,0,0,0,0,0]"
          global for_z_VR1=p[0,0,0,0,0,0]
        end
        $ 374 "write_port_register(143,0)"
        write_port_register(143,0)
        $ 375 "write_port_register(144,0)"
        write_port_register(144,0)
        $ 376 "timer_1: Reset"
        timer_1 = 0
        $ 377 "EXT_flag1≔integer_to_binary_list(read_port_register(179))"
        global EXT_flag1= integer_to_binary_list ( read_port_register (179))
        $ 379 "If touch_temp≟0"
        if (touch_temp == 0):
          $ 380 "write_port_register(138,0)"
          write_port_register(138,0)
          $ 381 "Call reset_multi_record"
          reset_multi_record()
          $ 382 "get_touch_position"
          $ 383 "get pre-positions"
          $ 384 "If read_port_register(work_type_165)≟2"
          if ( read_port_register (work_type_165) == 2):
            $ 385 "freedrive touch"
            $ 386 "move_i≔1"
            global move_i=1
            $ 387 "Loop move_i<9"
            while (move_i<9):
              $ 388 "Wait: 0.1"
              sleep(0.1)
              $ 389 "Wait save_tool=LO"
              while (get_tool_digital_in(0) == True):
                sync()
              end
              $ 390 "If A_Touch_trig_l[move_i]≟ True "
              if (A_Touch_trig_l[move_i] ==   True  ):
                $ 391 "If move_i≟A_HOR"
                if (move_i == A_HOR):
                  $ 392 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                  if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                    $ 393 "write_port_register(touch_cell_155,5)"
                    write_port_register(touch_cell_155,5)
                    $ 394 "write_port_register(touch_num_156,1)"
                    write_port_register(touch_num_156,1)
                    $ 395 "Call touch_sub"
                    touch_sub()
                    $ 396 "g_cp≔get_actual_tcp_pose()"
                    global g_cp= get_actual_tcp_pose ()
                    $ 397 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                    if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                      $ 398 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                      g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                    end
                    $ 399 "A_Prepos_l[move_i]=g_cp"
                    A_Prepos_l[move_i]=g_cp
                  end
                else:
                  $ 400 "ElseIf move_i≟A_HOR_ML"
                  if (move_i == A_HOR_ML):
                    $ 401 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                    if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                      $ 402 "write_port_register(touch_cell_155,5)"
                      write_port_register(touch_cell_155,5)
                      $ 403 "write_port_register(touch_num_156,3)"
                      write_port_register(touch_num_156,3)
                      $ 404 "Call touch_sub"
                      touch_sub()
                      $ 405 "g_cp≔get_actual_tcp_pose()"
                      global g_cp= get_actual_tcp_pose ()
                      $ 406 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                      if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                        $ 407 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                        g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                      end
                      $ 408 "A_Prepos_l[move_i]=g_cp"
                      A_Prepos_l[move_i]=g_cp
                    end
                  else:
                    $ 409 "ElseIf move_i≟A_HOR_R"
                    if (move_i == A_HOR_R):
                      $ 410 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                      if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                        $ 411 "write_port_register(touch_cell_155,5)"
                        write_port_register(touch_cell_155,5)
                        $ 412 "write_port_register(touch_num_156,2)"
                        write_port_register(touch_num_156,2)
                        $ 413 "Call touch_sub"
                        touch_sub()
                        $ 414 "g_cp≔get_actual_tcp_pose()"
                        global g_cp= get_actual_tcp_pose ()
                        $ 415 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                        if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                          $ 416 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                          g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                        end
                        $ 417 "A_Prepos_l[move_i]=g_cp"
                        A_Prepos_l[move_i]=g_cp
                      end
                    else:
                      $ 418 "ElseIf move_i≟A_HOR_MR"
                      if (move_i == A_HOR_MR):
                        $ 419 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
                        if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                          $ 420 "write_port_register(touch_cell_155,5)"
                          write_port_register(touch_cell_155,5)
                          $ 421 "write_port_register(touch_num_156,4)"
                          write_port_register(touch_num_156,4)
                          $ 422 "Call touch_sub"
                          touch_sub()
                          $ 423 "g_cp≔get_actual_tcp_pose()"
                          global g_cp= get_actual_tcp_pose ()
                          $ 424 "If g_cp[2]<(get_margin_z+a7_cell_bottom)/1000"
                          if (g_cp[2]<(get_margin_z+a7_cell_bottom)/1000):
                            $ 425 "g_cp[2]=(get_margin_z+a7_cell_bottom)/1000"
                            g_cp[2]=(get_margin_z+a7_cell_bottom)/1000
                          end
                          $ 426 "A_Prepos_l[move_i]=g_cp"
                          A_Prepos_l[move_i]=g_cp
                        end
                      else:
                        $ 427 "Else" "noBreak"
                        $ 428 "write_port_register(touch_cell_155,move_i)"
                        write_port_register(touch_cell_155,move_i)
                        $ 429 "write_port_register(touch_num_156,1)"
                        write_port_register(touch_num_156,1)
                        $ 430 "Call touch_sub"
                        touch_sub()
                        $ 431 "A_Prepos_l[move_i]=get_actual_tcp_pose()"
                        A_Prepos_l[move_i]= get_actual_tcp_pose ()
                        $ 432 "If move_i≤4"
                        if (move_i <= 4):
                          $ 433 "write_port_register(touch_cell_155,move_i)"
                          write_port_register(touch_cell_155,move_i)
                          $ 434 "write_port_register(touch_num_156,2)"
                          write_port_register(touch_num_156,2)
                          $ 435 "Wait: 0.1"
                          sleep(0.1)
                          $ 436 "Call touch_sub"
                          touch_sub()
                          $ 437 "A_Prepos_l[move_i+9]=get_actual_tcp_pose()"
                          A_Prepos_l[move_i+9]= get_actual_tcp_pose ()
                        end
                      end
                    end
                  end
                end
              else:
                $ 438 "Else" "noBreak"
                $ 439 "A_Prepos_l[move_i]=p[0,0,0,0,0,0]"
                A_Prepos_l[move_i]=p[0,0,0,0,0,0]
                $ 440 "If move_i≤4"
                if (move_i <= 4):
                  $ 441 "A_Prepos_l[move_i+7]=p[0,0,0,0,0,0]"
                  A_Prepos_l[move_i+7]=p[0,0,0,0,0,0]
                else:
                  $ 442 "ElseIf move_i≟A_HOR"
                  if (move_i == A_HOR):
                    $ 443 "A_Prepos_l[A_HOR_ML]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_ML]=p[0,0,0,0,0,0]
                    $ 444 "A_Prepos_l[A_HOR_MR]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_MR]=p[0,0,0,0,0,0]
                    $ 445 "A_Prepos_l[A_HOR_M]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_M]=p[0,0,0,0,0,0]
                    $ 446 "A_Prepos_l[A_HOR_R]=p[0,0,0,0,0,0]"
                    A_Prepos_l[A_HOR_R]=p[0,0,0,0,0,0]
                  end
                end
              end
              $ 447 "move_i≔move_i+1"
              global move_i=move_i+1
            end
            $ 448 "change deg"
            $ 449 "move_i≔1"
            global move_i=1
            $ 450 "Loop move_i<14"
            while (move_i<14):
              $ 451 "If A_Prepos_l[move_i]≠p[0,0,0,0,0,0]"
              if (A_Prepos_l[move_i] != p[0,0,0,0,0,0]):
                $ 452 "If move_i≟A_VL1 or move_i≟A_VL2 or move_i≟A_VL1_END or move_i≟A_VL2_END"
                if (move_i == A_VL1  or  move_i == A_VL2  or  move_i == A_VL1_END  or  move_i == A_VL2_END):
                  $ 453 "b2_left_par≔ True "
                  global b2_left_par=  True  
                  $ 454 "b8_wv_2f≔ False "
                  global b8_wv_2f=  False  
                  $ 455 "get_pos≔A_Prepos_l[move_i]"
                  global get_pos=A_Prepos_l[move_i]
                  $ 456 "get_org≔left"
                  global get_org=p[.480496318984, .411279115151, .006998291210, -2.211681476386, -.899147924387, -1.383032568605]
                  $ 457 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                  global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                  $ 458 "pre_tp≔tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])"
                  global pre_tp=tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])
                else:
                  $ 459 "ElseIf move_i≟A_VR1 or move_i≟A_VR2 or move_i≟A_VR1_END or move_i≟A_VR2_END"
                  if (move_i == A_VR1  or  move_i == A_VR2  or  move_i == A_VR1_END  or  move_i == A_VR2_END):
                    $ 460 "b2_left_par≔ False "
                    global b2_left_par=  False  
                    $ 461 "b8_wv_2f≔ False "
                    global b8_wv_2f=  False  
                    $ 462 "get_pos≔A_Prepos_l[move_i]"
                    global get_pos=A_Prepos_l[move_i]
                    $ 463 "get_org≔right"
                    global get_org=p[.475000000000, -.421403215678, .026417194146, 1.917761036827, -1.141682393512, 1.523356199292]
                    $ 464 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                    global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                    $ 465 "pre_tp≔tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])"
                    global pre_tp=tilt_3f_fun(get_pos,[0,0],a5_f_hole[1])
                  else:
                    $ 466 "ElseIf move_i≟A_HOR or move_i≟A_HOR_ML"
                    if (move_i == A_HOR  or  move_i == A_HOR_ML):
                      $ 467 "b8_wv_2f≔ True "
                      global b8_wv_2f=  True  
                      $ 468 "b2_left_par≔ True "
                      global b2_left_par=  True  
                      $ 469 "get_pos≔A_Prepos_l[move_i]"
                      global get_pos=A_Prepos_l[move_i]
                      $ 470 "get_org≔up_left"
                      global get_org=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                      $ 471 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                      global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                      $ 472 "pre_tp≔tilt_2f_fun(get_pos,[0,0], True , True )"
                      global pre_tp=tilt_2f_fun(get_pos,[0,0],  True  ,  True  )
                    else:
                      $ 473 "ElseIf move_i≟A_HOR_R or move_i≟A_HOR_MR"
                      if (move_i == A_HOR_R  or  move_i == A_HOR_MR):
                        $ 474 "b8_wv_2f≔ True "
                        global b8_wv_2f=  True  
                        $ 475 "b2_left_par≔ False "
                        global b2_left_par=  False  
                        $ 476 "get_pos≔A_Prepos_l[move_i]"
                        global get_pos=A_Prepos_l[move_i]
                        $ 477 "get_org≔up_right"
                        global get_org=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                        $ 478 "get_pos≔p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]"
                        global get_pos=p[get_pos[0],get_pos[1],get_pos[2],get_org[3],get_org[4],get_org[5]]
                        $ 479 "pre_tp≔tilt_2f_fun(get_pos,[0,0], False , True )"
                        global pre_tp=tilt_2f_fun(get_pos,[0,0],  False  ,  True  )
                      end
                    end
                  end
                end
                $ 480 "A_Prepos_l[move_i]=pre_tp"
                A_Prepos_l[move_i]=pre_tp
              end
              $ 481 "move_i≔move_i+1"
              global move_i=move_i+1
            end
            $ 482 "homeing()"
            homeing()
            $ 483 "Wait read_port_register(170)≟1"
            while (not( read_port_register (170) == 1)):
              sync()
            end
            $ 484 "write_port_register(170,0)"
            write_port_register(170,0)
          else:
            $ 485 "Else" "noBreak"
            $ 486 "value from pendant"
            $ 487 "move_i≔1"
            global move_i=1
            $ 489 "Touch_FrontandSide"
            $ 490 "If EXT_flag1[11]≟ True "
            if (EXT_flag1[11] ==   True  ):
              $ 491 "Touch front and side_Right"
              $ 492 "move_center≔pose_add(first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])"
              global move_center= pose_add (first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])
              $ 493 "get_pose_side_t≔0"
              global get_pose_side_t=0
              $ 495 "move_center[2]=(center_height+a7_cell_bottom)/1000"
              move_center[2]=(center_height+a7_cell_bottom)/1000
              $ 497 "MoveL"
              $ 498 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 499 "touch_center≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 500 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 501 "get_center≔touch_center[0]*1000"
              global get_center=touch_center[0]*1000
              $ 502 "a7_f_distance≔get_center"
              global a7_f_distance=get_center
              $ 503 "move_center≔pose_add(move_center,p[0,sec_touch_dis/1000,0,0,0,0])"
              global move_center= pose_add (move_center,p[0,sec_touch_dis/1000,0,0,0,0])
              $ 504 "move_center[0]=touch_center[0]-20/1000"
              move_center[0]=touch_center[0]-20/1000
              $ 505 "MoveL"
              $ 506 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 507 "touch_center2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 508 "center_line≔get_feature_Line(touch_center,touch_center2)"
              global center_line=get_feature_Line(touch_center,touch_center2)
              $ 509 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 510 "g_current_p≔get_actual_tcp_pose()"
              global g_current_p= get_actual_tcp_pose ()
              $ 511 "g_current_p≔pose_trans(g_current_p, p[0,0,0,0,d2r(-3),0])"
              global g_current_p= pose_trans (g_current_p, p[0,0,0,0,d2r(-3),0])
              $ 512 "MoveL"
              $ 513 "g_current_p" "breakAfter"
              movel(pose_trans(Base, g_current_p), a=0.1, v=0.05)
              $ 514 "A_touch_bottom≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global A_touch_bottom=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 515 "direction(p[0,0,0,0,0,0],[0,0,1],15,180,200)"
              direction(p[0,0,0,0,0,0],[0,0,1],15,180,200)
              $ 517 "homeing()"
              homeing()
              $ 518 "b2_left_par≔ False "
              global b2_left_par=  False  
              $ 519 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 520 "b2_cell≔b1_cell_info_R"
              global b2_cell=b1_cell_info_R
              $ 521 "touch_side≔p[0,(-a6_f_width/2)/1000,0,0,0,0]"
              global touch_side=p[0,(-a6_f_width/2)/1000,0,0,0,0]
              $ 522 "get_pos≔get_lr(side_p_R,a6_f_width,[35,0,0,0,0],a7_f_distance-20,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,30,0,center_line, True )"
              global get_pos=get_lr(p[.471584857321, -.427242166643, .026448165242, 1.806736638758, -1.227818761912, 1.383474453522],a6_f_width,[35,0,0,0,0],a7_f_distance-20,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,30,0,center_line,  True  )
              $ 524 "pre_tp≔get_pos"
              global pre_tp=get_pos
              $ 525 "pre_tp≔pose_add(pre_tp, p[side_pos_x/1000,0,0,0,0,0])"
              global pre_tp= pose_add (pre_tp, p[side_pos_x/1000,0,0,0,0,0])
              $ 526 "pre_tp[2]=(center_height+a7_cell_bottom)/1000"
              pre_tp[2]=(center_height+a7_cell_bottom)/1000
              $ 527 "MoveL"
              $ 528 "pre_tp" "breakAfter"
              movel(pose_trans(Base, pre_tp), a=0.8, v=0.4)
              $ 529 "touch_side≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,13,13)"
              global touch_side=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,13,13)
              $ 530 "event_cal_on≔ True "
              global event_cal_on=  True  
              $ 531 "touch_side≔get_feature_pose(touch_side,center_line)"
              global touch_side=get_feature_pose(touch_side,center_line)
              $ 532 "direction(p[0,0,0,0,0,0],[0,1,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[0,1,0],10,180,200)
              $ 533 "write_welder(4, False )"
              write_welder(4,  False  )
              $ 534 "get_pose_side_t≔touch_side[1]*1000"
              global get_pose_side_t=touch_side[1]*1000
              $ 535 "get_pose_side_t≔get_pose_side_t+(a6_f_width/2)"
              global get_pose_side_t=get_pose_side_t+(a6_f_width/2)
              $ 536 "event_side_on≔ True "
              global event_side_on=  True  
              $ 537 "MoveL"
              $ 538 "Direction: Base"
              global move_thread_flag_538=0
              thread move_thread_538():
                enter_critical
                move_thread_flag_538 = 1
                local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,1,0], 0.03)
                movel(towardsPos, a=0.3, v=0.15)
                move_thread_flag_538 = 2
                exit_critical
              end
              move_thread_flag_538 = 0
              move_thread_han_538 = run move_thread_538()
              while (True):
                sleep(1.0E-10)
                if (move_thread_flag_538 > 1):
                  join move_thread_han_538
                  $ 539 "Until (distance)"
                  break
                end
                sync()
              end
              $ 540 "homeing()"
              homeing()
            else:
              $ 541 "Else" "noBreak"
              $ 542 "Touch front and side_Left"
              $ 543 "move_center≔pose_add(first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])"
              global move_center= pose_add (first_p_wp, p[-first_p_wp[0]+(get_center-work_touch_dis)/1000,0,0,0,0,0])
              $ 544 "get_pose_side_t≔0"
              global get_pose_side_t=0
              $ 546 "move_center[2]=(center_height+a7_cell_bottom)/1000"
              move_center[2]=(center_height+a7_cell_bottom)/1000
              $ 548 "MoveL"
              $ 549 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 550 "touch_center≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 551 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 552 "get_center≔touch_center[0]*1000"
              global get_center=touch_center[0]*1000
              $ 553 "a7_f_distance≔get_center"
              global a7_f_distance=get_center
              $ 554 "move_center≔pose_add(move_center,p[0,sec_touch_dis/1000,0,0,0,0])"
              global move_center= pose_add (move_center,p[0,sec_touch_dis/1000,0,0,0,0])
              $ 555 "move_center[0]=touch_center[0]-20/1000"
              move_center[0]=touch_center[0]-20/1000
              $ 556 "MoveL"
              $ 557 "move_center" "breakAfter"
              movel(pose_trans(Base, move_center), a=0.5, v=0.15)
              $ 558 "touch_center2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global touch_center2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 559 "center_line≔get_feature_Line(touch_center,touch_center2)"
              global center_line=get_feature_Line(touch_center,touch_center2)
              $ 560 "direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[-1,0,0],10,180,200)
              $ 561 "g_current_p≔get_actual_tcp_pose()"
              global g_current_p= get_actual_tcp_pose ()
              $ 562 "g_current_p≔pose_trans(g_current_p, p[0,0,0,0,d2r(-3),0])"
              global g_current_p= pose_trans (g_current_p, p[0,0,0,0,d2r(-3),0])
              $ 563 "MoveL"
              $ 564 "g_current_p" "breakAfter"
              movel(pose_trans(Base, g_current_p), a=0.1, v=0.05)
              $ 565 "A_touch_bottom≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global A_touch_bottom=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 566 "direction(p[0,0,0,0,0,0],[0,0,1],15,180,200)"
              direction(p[0,0,0,0,0,0],[0,0,1],15,180,200)
              $ 568 "homeing()"
              homeing()
              $ 569 "b2_left_par≔ True "
              global b2_left_par=  True  
              $ 570 "b8_wv_2f≔ False "
              global b8_wv_2f=  False  
              $ 571 "b2_cell≔b1_cell_info_L"
              global b2_cell=b1_cell_info_L
              $ 572 "touch_side≔p[0,(a6_f_width/2)/1000,0,0,0,0]"
              global touch_side=p[0,(a6_f_width/2)/1000,0,0,0,0]
              $ 573 "get_pos≔get_lr(side_p_L,a6_f_width,[35,0,0,0,0],a7_f_distance-20,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,30,0,center_line, True )"
              global get_pos=get_lr(p[.411215372122, .375785944375, -.010176539343, -1.953488355698, -1.125710367676, -1.228829273458],a6_f_width,[35,0,0,0,0],a7_f_distance-20,b2_left_par,b8_wv_2f,Touch_dis,get_margin_z,touch_side,30,0,center_line,  True  )
              $ 575 "pre_tp≔get_pos"
              global pre_tp=get_pos
              $ 576 "pre_tp≔pose_add(pre_tp, p[side_pos_x/1000,0,0,0,0,0])"
              global pre_tp= pose_add (pre_tp, p[side_pos_x/1000,0,0,0,0,0])
              $ 577 "pre_tp[2]=(center_height+a7_cell_bottom)/1000"
              pre_tp[2]=(center_height+a7_cell_bottom)/1000
              $ 578 "MoveL"
              $ 579 "pre_tp" "breakAfter"
              movel(pose_trans(Base, pre_tp), a=0.8, v=0.4)
              $ 580 "touch_side≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,13,13)"
              global touch_side=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,13,13)
              $ 581 "event_cal_on≔ True "
              global event_cal_on=  True  
              $ 582 "touch_side≔get_feature_pose(touch_side,center_line)"
              global touch_side=get_feature_pose(touch_side,center_line)
              $ 583 "direction(p[0,0,0,0,0,0],[0,-1,0],10,180,200)"
              direction(p[0,0,0,0,0,0],[0,-1,0],10,180,200)
              $ 584 "write_welder(4, False )"
              write_welder(4,  False  )
              $ 585 "get_pose_side_t≔touch_side[1]*1000"
              global get_pose_side_t=touch_side[1]*1000
              $ 586 "get_pose_side_t≔get_pose_side_t-(a6_f_width/2)"
              global get_pose_side_t=get_pose_side_t-(a6_f_width/2)
              $ 587 "event_side_on≔ True "
              global event_side_on=  True  
              $ 588 "MoveL"
              $ 589 "Direction: Base"
              global move_thread_flag_589=0
              thread move_thread_589():
                enter_critical
                move_thread_flag_589 = 1
                local towardsPos=calculate_point_to_move_towards(p[0.0,0.0,0.0,0.0,0.0,0.0], [-1,-1,0], 0.03)
                movel(towardsPos, a=0.3, v=0.15)
                move_thread_flag_589 = 2
                exit_critical
              end
              move_thread_flag_589 = 0
              move_thread_han_589 = run move_thread_589()
              while (True):
                sleep(1.0E-10)
                if (move_thread_flag_589 > 1):
                  join move_thread_han_589
                  $ 590 "Until (distance)"
                  break
                end
                sync()
              end
              $ 591 "homeing()"
              homeing()
            end
            $ 593 "Wait event_cal_on≟ False "
            while (not(event_cal_on ==   False  )):
              sync()
            end
          end
          $ 595 "move and touch"
          $ 596 "Touch Move"
          $ 597 "HOR_L"
          $ 598 "If A_Prepos_l[A_HOR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR] != p[0,0,0,0,0,0]):
            $ 599 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 600 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 601 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 602 "A_sel_v≔A_HOR"
            global A_sel_v=A_HOR
            $ 603 "wv_direction≔1"
            global wv_direction=1
            $ 604 "Call MoveandTouchFun_2f"
            MoveandTouchFun_2f()
            $ 605 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 606 "If A_Prepos_l[A_VL1]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VL1] == p[0,0,0,0,0,0]):
                $ 608 "g_tp≔A_Prepos_l[A_HOR]"
                global g_tp=A_Prepos_l[A_HOR]
                $ 611 "Folder"
                $ 612 "g_cp≔get_actual_tcp_pose()"
                global g_cp= get_actual_tcp_pose ()
                $ 613 "g_cp≔pose_trans(g_cp, p[0,0,0,d2r(12),d2r(5),0])"
                global g_cp= pose_trans (g_cp, p[0,0,0,d2r(12),d2r(5),0])
                $ 614 "MoveL"
                $ 615 "g_cp" "breakAfter"
                movel(pose_trans(Base, g_cp), a=0.08, v=0.08)
                $ 616 "for_x_HOR≔contact_fun(A_Touch_p[A_sel_v],[-1*wv_direction,0,0],10000,15,15,  False)"
                global for_x_HOR=contact_fun(A_Touch_p[A_sel_v],[-1*wv_direction,0,0],10000,15,15,  False)
                $ 617 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
                $ 618 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 619 "Else" "noBreak"
                $ 620 "for_x_HOR≔p[0,0,0,0,0,0]"
                global for_x_HOR=p[0,0,0,0,0,0]
              end
            end
            $ 628 "If point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032"
            if (point_dist(A_Prepos_l[A_HOR], A_Prepos_l[A_VL1])>0.032):
              $ 629 "homeing()"
              homeing()
            end
          end
          $ 630 "VL1"
          $ 631 "If A_Prepos_l[A_VL1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL1] != p[0,0,0,0,0,0]):
            $ 632 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 633 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 634 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 635 "A_sel_v≔A_VL1"
            global A_sel_v=A_VL1
            $ 636 "A_sel_v_end≔A_VL1_END"
            global A_sel_v_end=A_VL1_END
            $ 637 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 638 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 639 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 640 "Else" "noBreak"
              $ 641 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 642 "Call MoveandTouchFun_3f"
            MoveandTouchFun_3f()
            $ 643 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 644 "If A_Prepos_l[A_HOR]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_HOR] == p[0,0,0,0,0,0]):
                $ 645 "direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],8,120,160)
                $ 647 "AAgcp≔get_actual_tcp_pose()"
                global AAgcp= get_actual_tcp_pose ()
                $ 648 "AAgangle≔up_left"
                global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                $ 649 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                $ 650 "MoveL"
                $ 651 "AAgtp" "breakAfter"
                movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                $ 653 "for_z_VL1≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)"
                global for_z_VL1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)
                $ 654 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                $ 655 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 656 "Else" "noBreak"
                $ 657 "for_z_VL1≔p[0,0,0,0,0,0]"
                global for_z_VL1=p[0,0,0,0,0,0]
              end
            end
            $ 658 "If top_touch_3f"
            if (top_touch_3f):
              $ 659 "touch_3f_up"
              $ 660 "b_touch_pos≔pose_add(A_Prepos_l[A_VL1], p[0,0,a8_wv_distance/1000,0,0,0])"
              global b_touch_pos= pose_add (A_Prepos_l[A_VL1], p[0,0,a8_wv_distance/1000,0,0,0])
              $ 661 "b_touch_pos≔tilt_3f_fun(b_touch_pos,[0,0],a5_f_hole[1])"
              global b_touch_pos=tilt_3f_fun(b_touch_pos,[0,0],a5_f_hole[1])
              $ 662 "MoveL"
              $ 663 "b_touch_pos" "breakAfter"
              movel(pose_trans(Base, b_touch_pos), a=0.35, v=0.35)
              $ 664 "touch_result≔touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens)"
              global touch_result=touch_fun2(b_touch_pos,b2_left_par,b9_touch_sens)
              $ 665 "A_Touch_p[A_sel_v_end]=touch_result"
              A_Touch_p[A_sel_v_end]=touch_result
              $ 666 "If EXT_flag1[3]≟ True "
              if (EXT_flag1[3] ==   True  ):
                $ 667 "MoveL"
                $ 668 "manual_tp≔A_Touch_p[A_sel_v_end]"
                global manual_tp=A_Touch_p[A_sel_v_end]
                $ 669 "manual_tp≔tilt_3f_fun(A_Touch_p[A_sel_v_end],basic_tilt_3f,0)"
                global manual_tp=tilt_3f_fun(A_Touch_p[A_sel_v_end],basic_tilt_3f,0)
                $ 670 "manual_tp≔pose_trans(manual_tp, p[0,0,-10/1000,0,0,0])"
                global manual_tp= pose_trans (manual_tp, p[0,0,-10/1000,0,0,0])
                $ 671 "manual_tp" "breakAfter"
                movel(pose_trans(Base, manual_tp), a=0.3, v=0.15)
                $ 672 "Wait: 1.5"
                sleep(1.5)
              end
            end
          end
          $ 673 "HOR_ML"
          $ 674 "If A_Prepos_l[A_HOR_ML]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_ML] != p[0,0,0,0,0,0]):
            $ 675 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 676 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 677 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 678 "A_sel_v≔A_HOR_ML"
            global A_sel_v=A_HOR_ML
            $ 679 "If b1_cell_info_L≟C or b1_cell_info_L≟D"
            if (b1_cell_info_L == C  or  b1_cell_info_L == D):
              $ 680 "wv_direction≔1"
              global wv_direction=1
              $ 681 "Call MoveFun"
              MoveFun()
              $ 682 "for_cal_xy≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_xy=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 683 "direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)
              $ 684 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
              $ 685 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
              $ 686 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
              $ 687 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
              $ 688 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 689 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 690 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 691 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
              $ 692 "for_cal_rot≔A_Touch_p[A_HOR]"
              global for_cal_rot=A_Touch_p[A_HOR]
              $ 693 "A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_z_VLR2[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
              A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_z_VLR2[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
              $ 694 "A_Touch_p[A_sel_v]=pose_trans(A_Touch_p[A_sel_v], p[Touch_dis/1000,0,0,0,0,0])"
              A_Touch_p[A_sel_v]= pose_trans (A_Touch_p[A_sel_v], p[Touch_dis/1000,0,0,0,0,0])
              $ 695 "write_welder(4, False )"
              write_welder(4,  False  )
            else:
              $ 696 "Else" "noBreak"
              $ 697 "wv_direction≔1"
              global wv_direction=1
              $ 698 "for_cal_rot≔A_Touch_p[A_HOR]"
              global for_cal_rot=A_Touch_p[A_HOR]
              $ 699 "Call MoveFun_cd"
              MoveFun_cd()
              $ 700 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 701 "for_cal_y_wel[2]=for_cal_rot[2]"
              for_cal_y_wel[2]=for_cal_rot[2]
              $ 702 "dir_x_cal≔get_feature_Line(for_cal_rot,for_cal_y_wel)"
              global dir_x_cal=get_feature_Line(for_cal_rot,for_cal_y_wel)
              $ 703 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              $ 704 "direction(p[0,0,0,0,0,0],[0,-1,0],80,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],80,120,160)
              $ 705 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 706 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
              $ 707 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
              $ 708 "direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)
              $ 709 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
              $ 710 "get_ml≔get_feature_pose(for_cal_x_wel,for_cal_rot)"
              global get_ml=get_feature_pose(for_cal_x_wel,for_cal_rot)
              $ 712 "A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)"
              A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)
              $ 713 "direction(p[0,0,0,0,0,0],[0,1,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],5,120,160)
              $ 714 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 715 "write_welder(4, False )"
              write_welder(4,  False  )
            end
            $ 716 "homeing()"
            homeing()
          else:
            $ 717 "Else" "noBreak"
            $ 718 "homeing()"
            homeing()
          end
          $ 719 "VL2"
          $ 720 "If A_Prepos_l[A_VL2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL2] != p[0,0,0,0,0,0]):
            $ 721 "b2_left_par≔ True "
            global b2_left_par=  True  
            $ 722 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 723 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 724 "A_sel_v≔A_VL2"
            global A_sel_v=A_VL2
            $ 725 "A_sel_v_end≔A_VL2_END"
            global A_sel_v_end=A_VL2_END
            $ 726 "b2_par_cd≔1"
            global b2_par_cd=1
            $ 727 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 728 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 729 "Else" "noBreak"
              $ 730 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 731 "If b1_cell_info_L≟d or b1_cell_info_L≟c"
            if (b1_cell_info_L == d  or  b1_cell_info_L == c):
              $ 732 "Halt"
              halt
            else:
              $ 733 "Else" "noBreak"
              $ 734 "If A_Touch_p[A_VL1]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_VL1] == p[0,0,0,0,0,0]):
                $ 735 "Call MoveandTouchFun_3f"
                MoveandTouchFun_3f()
                $ 736 "If A_Prepos_l[A_HOR_ML]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_ML] == p[0,0,0,0,0,0]):
                  $ 737 "direction(p[0,0,0,0,0,0],[-1,-1,0],8,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,-1,0],8,120,160)
                  $ 738 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 739 "AAgangle≔up_left"
                  global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                  $ 740 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 741 "MoveL"
                  $ 742 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 744 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 745 "direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)"
                  direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)
                end
                $ 746 "touch_tmp≔A_Touch_p[A_sel_v]"
                global touch_tmp=A_Touch_p[A_sel_v]
                $ 747 "touch_tmp[2]=for_z_VLR2[2]"
                touch_tmp[2]=for_z_VLR2[2]
                $ 748 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 749 "for_cal_y_wel≔A_Touch_p[A_sel_v]"
                global for_cal_y_wel=A_Touch_p[A_sel_v]
                $ 750 "for_cal_x_wel≔A_Touch_p[A_sel_v]"
                global for_cal_x_wel=A_Touch_p[A_sel_v]
              else:
                $ 751 "Else" "noBreak"
                $ 752 "If A_Prepos_l[A_HOR_ML]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_ML] == p[0,0,0,0,0,0]):
                  $ 753 "Call MoveFun"
                  MoveFun()
                  $ 754 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 755 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
                  $ 756 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
                  $ 757 "var_2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global var_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 758 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
                  $ 759 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
                  $ 760 "direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)"
                  direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)
                  $ 761 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                  global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                  $ 762 "direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],20,120,160)
                  $ 763 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 764 "AAgangle≔up_left"
                  global AAgangle=p[.492775857339, .409517380626, -.029063830209, -2.419264859926, -.998084331190, -1.368689080860]
                  $ 765 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 766 "MoveL"
                  $ 767 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 769 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 770 "direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)"
                  direction(p[0,0,0,0,0,0],[0,0,1],10,120,160)
                  $ 771 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                end
                $ 772 "for_cal_rot≔A_Touch_p[A_VL1]"
                global for_cal_rot=A_Touch_p[A_VL1]
                $ 773 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                $ 774 "If Scallup_check≟ False "
                if (Scallup_check ==   False  ):
                  $ 775 "touch_tmp≔pose_trans(touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])"
                  global touch_tmp= pose_trans (touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])
                else:
                  $ 776 "Else" "noBreak"
                  $ 777 "Scallup_check≔ False "
                  global Scallup_check=  False  
                end
                $ 778 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 779 "write_welder(4, False )"
                write_welder(4,  False  )
              end
            end
            $ 780 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 781 "homeing()"
            homeing()
          else:
            $ 782 "Else" "noBreak"
            $ 783 "homeing()"
            homeing()
          end
          $ 784 "HOR_R"
          $ 785 "If A_Prepos_l[A_HOR_R]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_R] != p[0,0,0,0,0,0]):
            $ 786 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 787 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 788 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 789 "A_sel_v≔A_HOR_R"
            global A_sel_v=A_HOR_R
            $ 790 "wv_direction≔-1"
            global wv_direction=-1
            $ 791 "Call MoveandTouchFun_2f"
            MoveandTouchFun_2f()
            $ 793 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 794 "If A_Prepos_l[A_VR1]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_VR1] == p[0,0,0,0,0,0]):
                $ 796 "g_tp≔A_Prepos_l[A_HOR_R]"
                global g_tp=A_Prepos_l[A_HOR_R]
                $ 797 "Folder"
                $ 798 "g_cp≔get_actual_tcp_pose()"
                global g_cp= get_actual_tcp_pose ()
                $ 799 "g_cp≔pose_trans(g_cp, p[0,0,0,d2r(-12),d2r(5),0])"
                global g_cp= pose_trans (g_cp, p[0,0,0,d2r(-12),d2r(5),0])
                $ 800 "MoveL"
                $ 801 "g_cp" "breakAfter"
                movel(pose_trans(Base, g_cp), a=0.08, v=0.08)
                $ 804 "for_x_HOR_R≔contact_fun(A_Touch_p[A_HOR_R],[-1*wv_direction,0,0],10000,15,15,  False)"
                global for_x_HOR_R=contact_fun(A_Touch_p[A_HOR_R],[-1*wv_direction,0,0],10000,15,15,  False)
                $ 805 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                $ 806 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 807 "Else" "noBreak"
                $ 808 "for_x_HOR_R≔p[0,0,0,0,0,0]"
                global for_x_HOR_R=p[0,0,0,0,0,0]
              end
            end
            $ 809 "wv_direction≔1"
            global wv_direction=1
            $ 810 "If point_dist(A_Prepos_l[A_HOR_R], A_Prepos_l[A_VR1])>0.0327"
            if (point_dist(A_Prepos_l[A_HOR_R], A_Prepos_l[A_VR1])>0.0327):
              $ 811 "homeing()"
              homeing()
            end
          end
          $ 812 "VR1"
          $ 813 "If A_Prepos_l[A_VR1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR1] != p[0,0,0,0,0,0]):
            $ 814 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 815 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 816 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 817 "A_sel_v≔A_VR1"
            global A_sel_v=A_VR1
            $ 818 "A_sel_v_end≔A_VR1_END"
            global A_sel_v_end=A_VR1_END
            $ 819 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 820 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 821 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 822 "Else" "noBreak"
              $ 823 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 824 "Call MoveandTouchFun_3f"
            MoveandTouchFun_3f()
            $ 825 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 826 "If A_Prepos_l[A_HOR_R]≟p[0,0,0,0,0,0]"
              if (A_Prepos_l[A_HOR_R] == p[0,0,0,0,0,0]):
                $ 827 "direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],8,120,160)
                $ 828 "AAgcp≔get_actual_tcp_pose()"
                global AAgcp= get_actual_tcp_pose ()
                $ 829 "AAgangle≔up_right"
                global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                $ 830 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                $ 831 "MoveL"
                $ 832 "AAgtp" "breakAfter"
                movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                $ 834 "for_z_VR1≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)"
                global for_z_VR1=contact_fun(p[0,0,0,0,0,0],[0,0,-1],10000,15,15,  False)
                $ 835 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                $ 836 "write_welder(4, False )"
                write_welder(4,  False  )
              else:
                $ 837 "Else" "noBreak"
                $ 838 "for_z_VR1≔p[0,0,0,0,0,0]"
                global for_z_VR1=p[0,0,0,0,0,0]
              end
            end
          end
          $ 839 "HOR_MR"
          $ 840 "If A_Prepos_l[A_HOR_MR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_MR] != p[0,0,0,0,0,0]):
            $ 841 "INIT"
            $ 842 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 843 "b8_wv_2f≔ True "
            global b8_wv_2f=  True  
            $ 844 "b7_tilt_degree≔[0,0,0]"
            global b7_tilt_degree=[0,0,0]
            $ 845 "A_sel_v≔A_HOR_MR"
            global A_sel_v=A_HOR_MR
            $ 846 "If b1_cell_info_R≟C or b1_cell_info_R≟D"
            if (b1_cell_info_R == C  or  b1_cell_info_R == D):
              $ 847 "wv_direction≔-1"
              global wv_direction=-1
              $ 848 "Call MoveFun_cd"
              MoveFun_cd()
              $ 849 "for_cal_xy≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_xy=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 850 "direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],15,120,160)
              $ 851 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
              $ 852 "direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],20,120,160)
              $ 853 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
              $ 854 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
              $ 855 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 856 "direction(p[0,0,0,0,0,0],[-1,0,0],8,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],8,120,160)
              $ 857 "for_cal_zr≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
              global for_cal_zr=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
              $ 858 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
              direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
              $ 859 "for_cal_rot≔A_Touch_p[A_HOR_R]"
              global for_cal_rot=A_Touch_p[A_HOR_R]
              $ 860 "A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
              A_Touch_p[A_sel_v]=p[for_cal_xy[0],for_cal_xy[1],for_cal_zr[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
              $ 861 "A_Touch_p[A_sel_v]=pose_trans(A_Touch_p[A_sel_v], p[-Touch_dis/1000,0,0,0,0,0])"
              A_Touch_p[A_sel_v]= pose_trans (A_Touch_p[A_sel_v], p[-Touch_dis/1000,0,0,0,0,0])
              $ 862 "write_welder(4, False )"
              write_welder(4,  False  )
            else:
              $ 863 "Else" "noBreak"
              $ 864 "wv_direction≔-1"
              global wv_direction=-1
              $ 865 "for_cal_rot≔A_Touch_p[A_HOR_R]"
              global for_cal_rot=A_Touch_p[A_HOR_R]
              $ 866 "Call MoveFun_cd"
              MoveFun_cd()
              $ 867 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 868 "vr2_p1≔for_cal_y_wel"
              global vr2_p1=for_cal_y_wel
              $ 869 "for_cal_y_wel[2]=for_cal_rot[2]"
              for_cal_y_wel[2]=for_cal_rot[2]
              $ 870 "dir_x_cal≔get_feature_Line(for_cal_rot,for_cal_y_wel)"
              global dir_x_cal=get_feature_Line(for_cal_rot,for_cal_y_wel)
              $ 871 "vr2_p2≔feature_offset(vr2_p1,p[0,0.02,0,0,0,0],dir_x_cal)"
              global vr2_p2=feature_offset(vr2_p1,p[0,0.02,0,0,0,0],dir_x_cal)
              $ 872 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
              $ 873 "direction(p[0,0,0,0,0,0],[0,1,0],80,120,160)"
              direction(p[0,0,0,0,0,0],[0,1,0],80,120,160)
              $ 874 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
              global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
              $ 875 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
              $ 876 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
              $ 877 "direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)"
              direction(p[0,0,0,0,0,0],[1,0,0],7,120,160)
              $ 878 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
              global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
              $ 879 "vr2_p3≔for_cal_x_wel"
              global vr2_p3=for_cal_x_wel
              $ 880 "get_ml≔get_feature_pose(for_cal_x_wel,for_cal_rot)"
              global get_ml=get_feature_pose(for_cal_x_wel,for_cal_rot)
              $ 882 "A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,-get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)"
              A_Touch_p[A_sel_v]=feature_offset(for_cal_rot,p[0,-get_ml[0]+(-cd_offset+cd_extra_dis)/1000,0,0,0,0],dir_x_cal)
              $ 883 "vr2_p4≔A_Touch_p[A_HOR_MR]"
              global vr2_p4=A_Touch_p[A_HOR_MR]
              $ 884 "direction(p[0,0,0,0,0,0],[0,-1,0],5,120,160)"
              direction(p[0,0,0,0,0,0],[0,-1,0],5,120,160)
              $ 885 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
              direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              $ 886 "write_welder(4, False )"
              write_welder(4,  False  )
            end
            $ 887 "homeing()"
            homeing()
            $ 888 "wv_direction≔1"
            global wv_direction=1
          else:
            $ 889 "Else" "noBreak"
            $ 890 "homeing()"
            homeing()
          end
          $ 891 "VR2"
          $ 892 "If A_Prepos_l[A_VR2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR2] != p[0,0,0,0,0,0]):
            $ 893 "Init"
            $ 894 "b2_left_par≔ False "
            global b2_left_par=  False  
            $ 895 "b8_wv_2f≔ False "
            global b8_wv_2f=  False  
            $ 896 "b7_tilt_degree≔basic_tilt_3f"
            global b7_tilt_degree=basic_tilt_3f
            $ 897 "A_sel_v≔A_VR2"
            global A_sel_v=A_VR2
            $ 898 "A_sel_v_end≔A_VR2_END"
            global A_sel_v_end=A_VR2_END
            $ 899 "b2_par_cd≔1"
            global b2_par_cd=1
            $ 900 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 901 "Scallup_check≔ True "
              global Scallup_check=  True  
            else:
              $ 902 "Else" "noBreak"
              $ 903 "Scallup_check≔ False "
              global Scallup_check=  False  
            end
            $ 904 "If b1_cell_info_R≟d or b1_cell_info_R≟c"
            if (b1_cell_info_R == d  or  b1_cell_info_R == c):
              $ 905 "Halt"
              halt
              $ 906 "If vr2_p1≟p[0,0,0,0,0,0]"
              if (vr2_p1 == p[0,0,0,0,0,0]):
                $ 907 "Call MoveFun_cd"
                MoveFun_cd()
                $ 908 "vr2_p1≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p1=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 909 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 910 "direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)
                $ 911 "vr2_p2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 912 "direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)
                $ 913 "vr2_p3≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                global vr2_p3=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                $ 914 "direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)
                $ 915 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 916 "vr2_p4≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                global vr2_p4=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                $ 917 "direction(p[0,0,0,0,0,0],[0,0,1],40,120,160)"
                direction(p[0,0,0,0,0,0],[0,0,1],40,120,160)
                $ 918 "A_Touch_p[A_sel_v]=touch_xyz_get_middle(vr2_p1,vr2_p2,vr2_p3,vr2_p4)"
                A_Touch_p[A_sel_v]=touch_xyz_get_middle(vr2_p1,vr2_p2,vr2_p3,vr2_p4)
                $ 919 "var_4≔A_Touch_p[A_sel_v]"
                global var_4=A_Touch_p[A_sel_v]
                $ 920 "var_4≔pose_trans(var_4, p[a6_callar_vert/1000,0,0,0,0,0])"
                global var_4= pose_trans (var_4, p[a6_callar_vert/1000,0,0,0,0,0])
                $ 921 "var_5≔get_actual_tcp_pose()"
                global var_5= get_actual_tcp_pose ()
                $ 922 "var_5[2]=var_4[2]"
                var_5[2]=var_4[2]
                $ 923 "var_5≔pose_trans(var_5, p[0,0,0,0,d2r(10),0])"
                global var_5= pose_trans (var_5, p[0,0,0,0,d2r(10),0])
                $ 924 "MoveL"
                $ 925 "var_5" "breakAfter"
                movel(pose_trans(Base, var_5), a=0.1, v=0.1)
                $ 926 "vr2_p1_up≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p1_up=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 927 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                $ 928 "direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)"
                direction(p[0,0,0,0,0,0],[0,1,0],10,120,160)
                $ 929 "vr2_p2_up≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                global vr2_p2_up=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                $ 930 "direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],14,120,160)
                $ 931 "vr2_p3_up≔contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)"
                global vr2_p3_up=contact_fun(p[0,0,0,0,0,0],[0,1,0],20000,20,20)
                $ 932 "direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)"
                direction(p[0,0,0,0,0,0],[0,-1,0],30,120,160)
                $ 933 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
              end
              $ 934 "A_Touch_p[A_sel_v+9]=touch_4point(vr2_p1_up,vr2_p2_up,vr2_p3_up)"
              A_Touch_p[A_sel_v+9]=touch_4point(vr2_p1_up,vr2_p2_up,vr2_p3_up)
              $ 935 "A_Touch_p[A_sel_v+9]=ori_pose(A_Touch_p[A_sel_v+9],A_Touch_p[A_sel_v])"
              A_Touch_p[A_sel_v+9]=ori_pose(A_Touch_p[A_sel_v+9],A_Touch_p[A_sel_v])
            else:
              $ 936 "Else" "noBreak"
              $ 937 "If A_Touch_p[A_VR1]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_VR1] == p[0,0,0,0,0,0]):
                $ 938 "Call MoveandTouchFun_3f"
                MoveandTouchFun_3f()
                $ 939 "touch_tmp≔A_Touch_p[A_sel_v]"
                global touch_tmp=A_Touch_p[A_sel_v]
                $ 940 "If A_Prepos_l[A_HOR_MR]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_MR] == p[0,0,0,0,0,0]):
                  $ 941 "direction(p[0,0,0,0,0,0],[-1,1,0],8,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,1,0],8,120,160)
                  $ 942 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 943 "AAgangle≔up_right"
                  global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                  $ 944 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 945 "MoveL"
                  $ 946 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.08, v=0.08)
                  $ 948 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 949 "touch_tmp[2]=for_z_VLR2[2]"
                  touch_tmp[2]=for_z_VLR2[2]
                end
                $ 950 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 951 "for_cal_y_wel≔A_Touch_p[A_sel_v]"
                global for_cal_y_wel=A_Touch_p[A_sel_v]
                $ 952 "for_cal_x_wel≔A_Touch_p[A_sel_v]"
                global for_cal_x_wel=A_Touch_p[A_sel_v]
              else:
                $ 953 "Else" "noBreak"
                $ 954 "If A_Prepos_l[A_HOR_MR]≟p[0,0,0,0,0,0]"
                if (A_Prepos_l[A_HOR_MR] == p[0,0,0,0,0,0]):
                  $ 955 "Call MoveFun"
                  MoveFun()
                  $ 956 "for_cal_y_wel≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global for_cal_y_wel=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 957 "direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],40,120,160)
                  $ 958 "direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,-1,0],60,120,160)
                  $ 959 "var_2≔contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)"
                  global var_2=contact_fun(p[0,0,0,0,0,0],[1,0,0],20000,20,20)
                  $ 960 "direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],5,120,160)
                  $ 961 "direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],60,120,160)
                  $ 962 "direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)"
                  direction(p[0,0,0,0,0,0],[1,0,0],10,120,160)
                  $ 963 "for_cal_x_wel≔contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)"
                  global for_cal_x_wel=contact_fun(p[0,0,0,0,0,0],[0,-1,0],20000,20,20)
                  $ 964 "direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,1,0],20,120,160)
                  $ 965 "AAgcp≔get_actual_tcp_pose()"
                  global AAgcp= get_actual_tcp_pose ()
                  $ 966 "AAgangle≔up_right"
                  global AAgangle=p[.445203173045, -.406687378356, -.031125942276, 2.308490741423, -1.066468937023, 1.322151316133]
                  $ 967 "AAgtp≔p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]"
                  global AAgtp=p[AAgcp[0],AAgcp[1],AAgcp[2],AAgangle[3],AAgangle[4],AAgangle[5]]
                  $ 968 "MoveL"
                  $ 969 "AAgtp" "breakAfter"
                  movel(pose_trans(Base, AAgtp), a=0.1, v=0.1)
                  $ 971 "for_z_VLR2≔contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)"
                  global for_z_VLR2=contact_fun(p[0,0,0,0,0,0],[0,0,-1],20000,20,20)
                  $ 972 "direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)"
                  direction(p[0,0,0,0,0,0],[0,0,1],20,120,160)
                  $ 973 "direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)"
                  direction(p[0,0,0,0,0,0],[-1,0,0],20,120,160)
                end
                $ 974 "for_cal_rot≔A_Touch_p[A_VR1]"
                global for_cal_rot=A_Touch_p[A_VR1]
                $ 976 "touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]"
                touch_tmp=p[for_cal_y_wel[0],for_cal_x_wel[1],for_cal_x_wel[2],for_cal_rot[3],for_cal_rot[4],for_cal_rot[5]]
                $ 977 "If Scallup_check≟ False "
                if (Scallup_check ==   False  ):
                  $ 978 "touch_tmp≔pose_trans(touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])"
                  global touch_tmp= pose_trans (touch_tmp,p[-(Touch_dis)/1000,0,0,0,0,0])
                else:
                  $ 979 "Else" "noBreak"
                  $ 980 "Scallup_check≔ False "
                  global Scallup_check=  False  
                end
                $ 981 "A_Touch_p[A_sel_v]=touch_tmp"
                A_Touch_p[A_sel_v]=touch_tmp
                $ 982 "write_welder(4, False )"
                write_welder(4,  False  )
              end
            end
            $ 983 "b2_par_cd≔0"
            global b2_par_cd=0
            $ 984 "homeing()"
            homeing()
          else:
            $ 985 "Else" "noBreak"
            $ 986 "homeing()"
            homeing()
          end
          $ 987 "write_welder(4,False)"
          write_welder(4,False)
          $ 1044 "Touch After Offset"
          $ 1045 "touch_after_offset"
          $ 1046 "HOR"
          $ 1047 "If A_Prepos_l[A_HOR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR] != p[0,0,0,0,0,0]):
            $ 1048 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 1049 "If for_x_HOR≟p[0,0,0,0,0,0] and A_Touch_p[A_VL1]≠p[0,0,0,0,0,0]"
              if (for_x_HOR == p[0,0,0,0,0,0]  and  A_Touch_p[A_VL1] != p[0,0,0,0,0,0]):
                $ 1050 "for_x_HOR≔A_Touch_p[A_VL1]"
                global for_x_HOR=A_Touch_p[A_VL1]
              end
              $ 1051 "If for_x_HOR≠p[0,0,0,0,0,0]"
              if (for_x_HOR != p[0,0,0,0,0,0]):
                $ 1052 "x_diff≔get_feature_pose(for_x_HOR,A_Touch_p[A_HOR])"
                global x_diff=get_feature_pose(for_x_HOR,A_Touch_p[A_HOR])
                $ 1053 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[x_diff[0],0,0,0,0,0])"
                A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[x_diff[0],0,0,0,0,0])
                $ 1054 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or b1_cell_info_L≟E or b1_cell_info_L≟e"
                if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  b1_cell_info_L == E  or  b1_cell_info_L == e):
                  $ 1055 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[hor_l_scallup/1000,0,0,0,0,0])"
                  A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[hor_l_scallup/1000,0,0,0,0,0])
                end
              end
            end
            $ 1056 "A_Touch_p[A_HOR]=pose_trans(A_Touch_p[A_HOR], p[offset_2f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR]= pose_trans (A_Touch_p[A_HOR], p[offset_2f_begin/1000,0,0,0,0,0])
          end
          $ 1057 "VL1"
          $ 1058 "If A_Prepos_l[A_VL1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL1] != p[0,0,0,0,0,0]):
            $ 1059 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c):
              $ 1060 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1061 "If for_z_VL1≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR]≠p[0,0,0,0,0,0]"
              if (for_z_VL1 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR] != p[0,0,0,0,0,0]):
                $ 1062 "for_z_VL1≔A_Touch_p[A_HOR]"
                global for_z_VL1=A_Touch_p[A_HOR]
              end
              $ 1063 "Comment"
              # Comment
              $ 1064 "If for_z_VL1≠p[0,0,0,0,0,0]"
              if (for_z_VL1 != p[0,0,0,0,0,0]):
                $ 1065 "z_diff≔get_feature_pose(for_z_VL1,A_Touch_p[A_VL1])"
                global z_diff=get_feature_pose(for_z_VL1,A_Touch_p[A_VL1])
                $ 1066 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[z_diff[0],0,0,0,0,0])
              end
              $ 1067 "If b1_cell_info_L≟B or b1_cell_info_L≟D or b1_cell_info_L≟d or b1_cell_info_L≟E or b1_cell_info_L≟e"
              if (b1_cell_info_L == B  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  b1_cell_info_L == E  or  b1_cell_info_L == e):
                $ 1068 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[vert_scallup_l/1000,0,0,0,0,0])"
                A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[vert_scallup_l/1000,0,0,0,0,0])
              end
            end
            $ 1070 "A_Touch_p[A_VL1]=pose_trans(A_Touch_p[A_VL1], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VL1]= pose_trans (A_Touch_p[A_VL1], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1071 "VL2"
          $ 1072 "If A_Prepos_l[A_VL2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VL2] != p[0,0,0,0,0,0]):
            $ 1073 "If b1_cell_info_L≟A or b1_cell_info_L≟C or b1_cell_info_L≟c or b1_cell_info_L≟D or b1_cell_info_L≟d or b1_cell_info_L≟E"
            if (b1_cell_info_L == A  or  b1_cell_info_L == C  or  b1_cell_info_L == c  or  b1_cell_info_L == D  or  b1_cell_info_L == d  or  b1_cell_info_L == E):
              $ 1074 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1075 "If for_z_VLR2≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR_ML]≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR_ML] != p[0,0,0,0,0,0]):
                $ 1076 "for_z_VLR2≔A_Touch_p[A_HOR_ML]"
                global for_z_VLR2=A_Touch_p[A_HOR_ML]
              end
              $ 1077 "Comment"
              # Comment
              $ 1078 "If for_z_VLR2≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 != p[0,0,0,0,0,0]):
                $ 1079 "z_diff≔get_feature_pose(for_z_VLR2,A_Touch_p[A_VL2])"
                global z_diff=get_feature_pose(for_z_VLR2,A_Touch_p[A_VL2])
                $ 1080 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[z_diff[0],0,0,0,0,0])
              end
              $ 1081 "If b1_cell_info_L≟E or b1_cell_info_L≟e"
              if (b1_cell_info_L == E  or  b1_cell_info_L == e):
                $ 1082 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[vert_scallup_l/1000,0,0,0,0,0])"
                A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[vert_scallup_l/1000,0,0,0,0,0])
              end
            end
            $ 1083 "A_Touch_p[A_VL2]=pose_trans(A_Touch_p[A_VL2], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VL2]= pose_trans (A_Touch_p[A_VL2], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1084 "HOR_R"
          $ 1085 "If A_Prepos_l[A_HOR_R]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_R] != p[0,0,0,0,0,0]):
            $ 1086 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 1087 "If for_x_HOR_R≟p[0,0,0,0,0,0] and A_Touch_p[A_VR1]≠p[0,0,0,0,0,0]"
              if (for_x_HOR_R == p[0,0,0,0,0,0]  and  A_Touch_p[A_VR1] != p[0,0,0,0,0,0]):
                $ 1088 "for_x_HOR_R≔A_Touch_p[A_VR1]"
                global for_x_HOR_R=A_Touch_p[A_VR1]
              end
              $ 1089 "If for_x_HOR≠p[0,0,0,0,0,0]"
              if (for_x_HOR != p[0,0,0,0,0,0]):
                $ 1090 "x_diff≔get_feature_pose(for_x_HOR_R,A_Touch_p[A_HOR_R])"
                global x_diff=get_feature_pose(for_x_HOR_R,A_Touch_p[A_HOR_R])
                $ 1091 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[x_diff[0],0,0,0,0,0])"
                A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[x_diff[0],0,0,0,0,0])
                $ 1092 "If b1_cell_info_R≟B or b1_cell_info_R≟D or b1_cell_info_R≟d or b1_cell_info_R≟E or b1_cell_info_R≟e"
                if (b1_cell_info_R == B  or  b1_cell_info_R == D  or  b1_cell_info_R == d  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
                  $ 1093 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[-hor_r_scallup/1000,0,0,0,0,0])"
                  A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[-hor_r_scallup/1000,0,0,0,0,0])
                end
              end
            end
            $ 1094 "A_Touch_p[A_HOR_R]=pose_trans(A_Touch_p[A_HOR_R], p[-offset_2f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_R]= pose_trans (A_Touch_p[A_HOR_R], p[-offset_2f_begin/1000,0,0,0,0,0])
          end
          $ 1095 "VR1"
          $ 1096 "If A_Prepos_l[A_VR1]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR1] != p[0,0,0,0,0,0]):
            $ 1097 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c):
              $ 1098 "If for_z_VR1≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR_R]≠p[0,0,0,0,0,0]"
              if (for_z_VR1 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR_R] != p[0,0,0,0,0,0]):
                $ 1099 "for_z_VR1≔A_Touch_p[A_HOR_R]"
                global for_z_VR1=A_Touch_p[A_HOR_R]
              end
              $ 1100 "If for_z_VR1≠p[0,0,0,0,0,0]"
              if (for_z_VR1 != p[0,0,0,0,0,0]):
                $ 1101 "z_diff≔get_feature_pose(for_z_VR1,A_Touch_p[A_VR1])"
                global z_diff=get_feature_pose(for_z_VR1,A_Touch_p[A_VR1])
                $ 1102 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[z_diff[0],0,0,0,0,0])
              end
              $ 1103 "If b1_cell_info_R≟B or b1_cell_info_R≟D or b1_cell_info_R≟d or b1_cell_info_R≟E or b1_cell_info_R≟e"
              if (b1_cell_info_R == B  or  b1_cell_info_R == D  or  b1_cell_info_R == d  or  b1_cell_info_R == E  or  b1_cell_info_R == e):
                $ 1104 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[vert_scallup_r/1000,0,0,0,0,0])"
                A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[vert_scallup_r/1000,0,0,0,0,0])
              end
            end
            $ 1106 "A_Touch_p[A_VR1]=pose_trans(A_Touch_p[A_VR1], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VR1]= pose_trans (A_Touch_p[A_VR1], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1107 "VR2"
          $ 1108 "If A_Prepos_l[A_VR2]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_VR2] != p[0,0,0,0,0,0]):
            $ 1109 "If b1_cell_info_R≟A or b1_cell_info_R≟C or b1_cell_info_R≟c or b1_cell_info_R≟D or b1_cell_info_R≟d or b1_cell_info_R≟E"
            if (b1_cell_info_R == A  or  b1_cell_info_R == C  or  b1_cell_info_R == c  or  b1_cell_info_R == D  or  b1_cell_info_R == d  or  b1_cell_info_R == E):
              $ 1110 "'3f only does not apply offset'"
              # '3f only does not apply offset'
              $ 1111 "If for_z_VLR2≟p[0,0,0,0,0,0] and A_Touch_p[A_HOR_MR]≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 == p[0,0,0,0,0,0]  and  A_Touch_p[A_HOR_MR] != p[0,0,0,0,0,0]):
                $ 1112 "for_z_VLR2≔A_Touch_p[A_HOR_MR]"
                global for_z_VLR2=A_Touch_p[A_HOR_MR]
              end
              $ 1113 "Comment"
              # Comment
              $ 1114 "If for_z_VLR2≠p[0,0,0,0,0,0]"
              if (for_z_VLR2 != p[0,0,0,0,0,0]):
                $ 1115 "z_diff≔get_feature_pose(for_z_VLR2,A_Touch_p[A_VR2])"
                global z_diff=get_feature_pose(for_z_VLR2,A_Touch_p[A_VR2])
                $ 1116 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[z_diff[0],0,0,0,0,0])"
                A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[z_diff[0],0,0,0,0,0])
              end
              $ 1117 "If b1_cell_info_R≟E or b1_cell_info_R≟e"
              if (b1_cell_info_R == E  or  b1_cell_info_R == e):
                $ 1118 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[vert_scallup_r/1000,0,0,0,0,0])"
                A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[vert_scallup_r/1000,0,0,0,0,0])
              end
            end
            $ 1119 "A_Touch_p[A_VR2]=pose_trans(A_Touch_p[A_VR2], p[offset_3f_begin/1000,0,0,0,0,0])"
            A_Touch_p[A_VR2]= pose_trans (A_Touch_p[A_VR2], p[offset_3f_begin/1000,0,0,0,0,0])
          end
          $ 1120 "HOR_ML"
          $ 1121 "If A_Prepos_l[A_HOR_ML]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_ML] != p[0,0,0,0,0,0]):
            $ 1122 "A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_ML]"
            A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_ML]
            $ 1123 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])"
            global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])
            $ 1124 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_ML], p[x_welding_axis[0],0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_ML], p[x_welding_axis[0],0,0,0,0,0])
            $ 1125 "A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])"
            A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])
            $ 1126 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[10/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[10/1000,0,0,0,0,0])
            $ 1127 "If b1_cell_info_L≟C or b1_cell_info_L≟D"
            if (b1_cell_info_L == C  or  b1_cell_info_L == D):
              $ 1129 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])"
              global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_ML])
              $ 1130 "A_Touch_p[A_HOR_ML]=pose_trans(A_Touch_p[A_HOR_ML],p[x_welding_axis[0],0,0,0,0,0])"
              A_Touch_p[A_HOR_ML]= pose_trans (A_Touch_p[A_HOR_ML],p[x_welding_axis[0],0,0,0,0,0])
              $ 1131 "A_Touch_p[A_HOR_ML]=pose_trans(A_Touch_p[A_HOR_ML],p[0/1000,0,0,0,0,0])"
              A_Touch_p[A_HOR_ML]= pose_trans (A_Touch_p[A_HOR_ML],p[0/1000,0,0,0,0,0])
            end
          end
          $ 1132 "HOR_MR"
          $ 1133 "If A_Prepos_l[A_HOR_MR]≠p[0,0,0,0,0,0]"
          if (A_Prepos_l[A_HOR_MR] != p[0,0,0,0,0,0]):
            $ 1135 "A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_MR]"
            A_Touch_p[A_HOR_M]=A_Touch_p[A_HOR_MR]
            $ 1136 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])"
            global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])
            $ 1137 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[x_welding_axis[0],0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[x_welding_axis[0],0,0,0,0,0])
            $ 1138 "A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])"
            A_Touch_p[A_HOR_M]=put_pose(A_Touch_p[A_HOR_M],0,for_cal_y_wel[0])
            $ 1139 "A_Touch_p[A_HOR_M]=pose_trans(A_Touch_p[A_HOR_M], p[-10/1000,0,0,0,0,0])"
            A_Touch_p[A_HOR_M]= pose_trans (A_Touch_p[A_HOR_M], p[-10/1000,0,0,0,0,0])
            $ 1140 "If b1_cell_info_R≟C or b1_cell_info_R≟D"
            if (b1_cell_info_R == C  or  b1_cell_info_R == D):
              $ 1142 "x_welding_axis≔get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])"
              global x_welding_axis=get_feature_pose(for_cal_x_wel,A_Touch_p[A_HOR_MR])
              $ 1143 "A_Touch_p[A_HOR_MR]=pose_trans(A_Touch_p[A_HOR_MR],p[x_welding_axis[0],0,0,0,0,0])"
              A_Touch_p[A_HOR_MR]= pose_trans (A_Touch_p[A_HOR_MR],p[x_welding_axis[0],0,0,0,0,0])
              $ 1144 "A_Touch_p[A_HOR_MR]=pose_trans(A_Touch_p[A_HOR_MR],p[-0/1000,0,0,0,0,0])"
              A_Touch_p[A_HOR_MR]= pose_trans (A_Touch_p[A_HOR_MR],p[-0/1000,0,0,0,0,0])
            end
          end
          $ 1145 "'Touch Remember On/OFF'"
          # 'Touch Remember On/OFF'
          $ 1146 "write_port_register(180,1)"
          write_port_register(180,1)
        else:
          $ 1147 "Else" "noBreak"
          $ 1148 "Ignore Touch and check error"
          $ 1149 "Auto_cur_cell≔0"
          global Auto_cur_cell=0
          $ 1150 "Loop Auto_cur_cell<Auto_total_cell"
          while (Auto_cur_cell<Auto_total_cell):
            $ 1151 "A_sel_v≔Auto_W_num[Auto_cur_cell]"
            global A_sel_v=Auto_W_num[Auto_cur_cell]
            $ 1152 "If A_sel_v<A_HOR_2path"
            if (A_sel_v<A_HOR_2path):
              $ 1153 "If A_Touch_p[A_sel_v]≟p[0,0,0,0,0,0]"
              if (A_Touch_p[A_sel_v] == p[0,0,0,0,0,0]):
                $ 1154 "write_port_register(142,120)"
                write_port_register(142,120)
                $ 1155 "Halt"
                halt
              end
            end
            $ 1156 "Auto_cur_cell≔Auto_cur_cell+1"
            global Auto_cur_cell=Auto_cur_cell+1
          end
          $ 1157 "Auto_cur_cell≔0"
          global Auto_cur_cell=0
        end
        $ 1158 "welding"
        $ 1159 "weldings"
        $ 1160 "Auto_cur_cell≔read_port_register(138)"
        global Auto_cur_cell= read_port_register (138)
        $ 1161 "time_cal_trig≔ True "
        global time_cal_trig=  True  
        $ 1162 "Loop Auto_cur_cell<Auto_total_cell"
        while (Auto_cur_cell<Auto_total_cell):
          $ 1163 "write_port_register(138,Auto_cur_cell)"
          write_port_register(138,Auto_cur_cell)
          $ 1164 "running_trig≔ True "
          global running_trig=  True  
          $ 1165 "'[2F_AB - 30] , [2F_CD_LEFT - 100] , [2F_CD_RIGHT - 150] , [3F - ELSE]'"
          # '[2F_AB - 30] , [2F_CD_LEFT - 100] , [2F_CD_RIGHT - 150] , [3F - ELSE]'
          $ 1166 "If Auto_W_num[Auto_cur_cell]≥100 and Auto_W_num[Auto_cur_cell]≤149"
          if (Auto_W_num[Auto_cur_cell] >= 100  and  Auto_W_num[Auto_cur_cell] <= 149):
            $ 1167 "'2F CD LEFT'"
            # '2F CD LEFT'
            $ 1168 "A_sel_v≔A_HOR"
            global A_sel_v=A_HOR
            $ 1169 "A_sel_v_end≔A_HOR_ML"
            global A_sel_v_end=A_HOR_ML
            $ 1170 "A_sel_v2≔A_HOR_M"
            global A_sel_v2=A_HOR_M
            $ 1171 "A_sel_v_end2≔A_HOR_R"
            global A_sel_v_end2=A_HOR_R
            $ 1172 "If floor(Auto_W_num[Auto_cur_cell]/10)≟10"
            if (floor(Auto_W_num[Auto_cur_cell]/10) == 10):
              $ 1173 "current_path≔1"
              global current_path=1
              $ 1174 "multi_path≔1"
              global multi_path=1
            else:
              $ 1175 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟11"
              if (floor(Auto_W_num[Auto_cur_cell]/10) == 11):
                $ 1176 "current_path≔2"
                global current_path=2
                $ 1177 "multi_path≔2"
                global multi_path=2
              else:
                $ 1178 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟12"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 12):
                  $ 1179 "current_path≔3"
                  global current_path=3
                  $ 1180 "multi_path≔3"
                  global multi_path=3
                else:
                  $ 1181 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟13"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 13):
                    $ 1182 "current_path≔4"
                    global current_path=4
                    $ 1183 "multi_path≔4"
                    global multi_path=4
                  end
                end
              end
            end
            $ 1184 "current_2f≔current_2f+1"
            global current_2f=current_2f+1
            $ 1185 "CD_MLR≔ True "
            global CD_MLR=  True  
            $ 1186 "write_port_register(135,A_HOR)"
            write_port_register(135,A_HOR)
            $ 1187 "write_port_register(136,current_2f)"
            write_port_register(136,current_2f)
            $ 1188 "If simulation_mode"
            if (simulation_mode):
              $ 1189 "Call welding_parameter_sim"
              welding_parameter_sim()
            else:
              $ 1190 "Else" "noBreak"
              $ 1191 "Call welding_parameter_init"
              welding_parameter_init()
            end
            $ 1192 "wv_direction≔1"
            global wv_direction=1
            $ 1193 "If Auto_W_num[Auto_cur_cell]%10≟4"
            if (Auto_W_num[Auto_cur_cell]%10 == 4):
              $ 1194 "A_sel_v≔A_HOR_R"
              global A_sel_v=A_HOR_R
              $ 1195 "Call MoveFun"
              MoveFun()
              $ 1196 "A_sel_v≔A_HOR"
              global A_sel_v=A_HOR
            else:
              $ 1197 "ElseIf Auto_W_num[Auto_cur_cell]%10≟0 or Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2"
              if (Auto_W_num[Auto_cur_cell]%10 == 0  or  Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2):
                $ 1198 "Call MoveFun"
                MoveFun()
              end
            end
            $ 1199 "Call weav_welding_2f_CD"
            weav_welding_2f_CD()
          else:
            $ 1200 "ElseIf Auto_W_num[Auto_cur_cell]≥150 and Auto_W_num[Auto_cur_cell]≤189"
            if (Auto_W_num[Auto_cur_cell] >= 150  and  Auto_W_num[Auto_cur_cell] <= 189):
              $ 1201 "'2F CD RIGHT'"
              # '2F CD RIGHT'
              $ 1202 "A_sel_v≔A_HOR_R"
              global A_sel_v=A_HOR_R
              $ 1203 "A_sel_v_end≔A_HOR_MR"
              global A_sel_v_end=A_HOR_MR
              $ 1204 "A_sel_v2≔A_HOR_M"
              global A_sel_v2=A_HOR_M
              $ 1205 "A_sel_v_end2≔A_HOR"
              global A_sel_v_end2=A_HOR
              $ 1206 "If floor(Auto_W_num[Auto_cur_cell]/10)≟15"
              if (floor(Auto_W_num[Auto_cur_cell]/10) == 15):
                $ 1207 "current_path≔1"
                global current_path=1
                $ 1208 "multi_path≔1"
                global multi_path=1
              else:
                $ 1209 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟16"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 16):
                  $ 1210 "current_path≔2"
                  global current_path=2
                  $ 1211 "multi_path≔2"
                  global multi_path=2
                else:
                  $ 1212 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟17"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 17):
                    $ 1213 "current_path≔3"
                    global current_path=3
                    $ 1214 "multi_path≔3"
                    global multi_path=3
                  else:
                    $ 1215 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟18"
                    if (floor(Auto_W_num[Auto_cur_cell]/10) == 18):
                      $ 1216 "current_path≔4"
                      global current_path=4
                      $ 1217 "multi_path≔4"
                      global multi_path=4
                    end
                  end
                end
              end
              $ 1218 "current_2f≔current_2f+1"
              global current_2f=current_2f+1
              $ 1219 "CD_MLR≔ False "
              global CD_MLR=  False  
              $ 1220 "write_port_register(135,A_HOR)"
              write_port_register(135,A_HOR)
              $ 1221 "write_port_register(136,current_2f)"
              write_port_register(136,current_2f)
              $ 1222 "If simulation_mode"
              if (simulation_mode):
                $ 1223 "Call welding_parameter_sim"
                welding_parameter_sim()
              else:
                $ 1224 "Else" "noBreak"
                $ 1225 "Call welding_parameter_init"
                welding_parameter_init()
              end
              $ 1226 "wv_direction≔-1"
              global wv_direction=-1
              $ 1227 "If Auto_W_num[Auto_cur_cell]%10≟4"
              if (Auto_W_num[Auto_cur_cell]%10 == 4):
                $ 1228 "A_sel_v≔A_HOR"
                global A_sel_v=A_HOR
                $ 1229 "Call MoveFun"
                MoveFun()
                $ 1230 "A_sel_v≔A_HOR_R"
                global A_sel_v=A_HOR_R
              else:
                $ 1231 "ElseIf Auto_W_num[Auto_cur_cell]%10≟0 or Auto_W_num[Auto_cur_cell]%10≟1 or Auto_W_num[Auto_cur_cell]%10≟2"
                if (Auto_W_num[Auto_cur_cell]%10 == 0  or  Auto_W_num[Auto_cur_cell]%10 == 1  or  Auto_W_num[Auto_cur_cell]%10 == 2):
                  $ 1232 "Call MoveFun"
                  MoveFun()
                end
              end
              $ 1233 "Call weav_welding_2f_CD"
              weav_welding_2f_CD()
            else:
              $ 1234 "ElseIf Auto_W_num[Auto_cur_cell]≥30 and Auto_W_num[Auto_cur_cell]≤65"
              if (Auto_W_num[Auto_cur_cell] >= 30  and  Auto_W_num[Auto_cur_cell] <= 65):
                $ 1235 "'2F'"
                # '2F'
                $ 1236 "A_sel_v≔A_HOR"
                global A_sel_v=A_HOR
                $ 1237 "A_sel_v_end≔A_HOR_R"
                global A_sel_v_end=A_HOR_R
                $ 1238 "If floor(Auto_W_num[Auto_cur_cell]/10)≟3"
                if (floor(Auto_W_num[Auto_cur_cell]/10) == 3):
                  $ 1239 "current_path≔1"
                  global current_path=1
                  $ 1240 "multi_path≔1"
                  global multi_path=1
                else:
                  $ 1241 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟4"
                  if (floor(Auto_W_num[Auto_cur_cell]/10) == 4):
                    $ 1242 "current_path≔2"
                    global current_path=2
                    $ 1243 "multi_path≔2"
                    global multi_path=2
                  else:
                    $ 1244 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟5"
                    if (floor(Auto_W_num[Auto_cur_cell]/10) == 5):
                      $ 1245 "current_path≔3"
                      global current_path=3
                      $ 1246 "multi_path≔3"
                      global multi_path=3
                    else:
                      $ 1247 "ElseIf floor(Auto_W_num[Auto_cur_cell]/10)≟6"
                      if (floor(Auto_W_num[Auto_cur_cell]/10) == 6):
                        $ 1248 "current_path≔4"
                        global current_path=4
                        $ 1249 "multi_path≔4"
                        global multi_path=4
                      end
                    end
                  end
                end
                $ 1250 "current_2f≔current_2f+1"
                global current_2f=current_2f+1
                $ 1251 "write_port_register(135,A_HOR)"
                write_port_register(135,A_HOR)
                $ 1252 "write_port_register(136,current_2f)"
                write_port_register(136,current_2f)
                $ 1253 "If simulation_mode"
                if (simulation_mode):
                  $ 1254 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1255 "Else" "noBreak"
                  $ 1256 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1257 "If Auto_W_num[Auto_cur_cell]%10≟2"
                if (Auto_W_num[Auto_cur_cell]%10 == 2):
                  $ 1258 "A_sel_v≔A_HOR_R"
                  global A_sel_v=A_HOR_R
                  $ 1259 "Call MoveFun"
                  MoveFun()
                  $ 1260 "A_sel_v≔A_HOR"
                  global A_sel_v=A_HOR
                else:
                  $ 1261 "Else" "noBreak"
                  $ 1262 "Call MoveFun"
                  MoveFun()
                end
                $ 1263 "Call weav_welding_2f"
                weav_welding_2f()
              else:
                $ 1264 "Else" "noBreak"
                $ 1265 "A_sel_v≔Auto_W_num[Auto_cur_cell]"
                global A_sel_v=Auto_W_num[Auto_cur_cell]
                $ 1266 "write_port_register(135,A_sel_v)"
                write_port_register(135,A_sel_v)
                $ 1267 "current_path≔1"
                global current_path=1
                $ 1268 "current_2f≔0"
                global current_2f=0
                $ 1269 "write_port_register(136,current_2f)"
                write_port_register(136,current_2f)
                $ 1270 "If simulation_mode"
                if (simulation_mode):
                  $ 1271 "Call welding_parameter_sim"
                  welding_parameter_sim()
                else:
                  $ 1272 "Else" "noBreak"
                  $ 1273 "Call welding_parameter_init"
                  welding_parameter_init()
                end
                $ 1274 "A_sel_v_end≔A_sel_v+9"
                global A_sel_v_end=A_sel_v+9
                $ 1275 "Call weav_welding_3f"
                weav_welding_3f()
              end
            end
          end
          $ 1276 "Call reset_weld_param"
          reset_weld_param()
          $ 1277 "next_before"
          $ 1278 "If get_move_trig≟1"
          if (get_move_trig == 1):
            $ 1279 "If get_next_number≠Auto_cur_cell"
            if (get_next_number != Auto_cur_cell):
              $ 1280 "Auto_cur_cell≔get_next_number"
              global Auto_cur_cell=get_next_number
            else:
              $ 1281 "Else" "noBreak"
              $ 1282 "Auto_cur_cell≔Auto_cur_cell+1"
              global Auto_cur_cell=Auto_cur_cell+1
            end
            $ 1283 "write_port_register(166,0)"
            write_port_register(166,0)
            $ 1284 "write_port_register(167,0)"
            write_port_register(167,0)
            $ 1285 "get_move_trig≔0"
            global get_move_trig=0
          else:
            $ 1286 "Else" "noBreak"
            $ 1287 "Auto_cur_cell≔Auto_cur_cell+1"
            global Auto_cur_cell=Auto_cur_cell+1
          end
        end
        $ 1288 "homeing()"
        homeing()
        $ 1289 "write_port_register(162,1)"
        write_port_register(162,1)
        $ 1290 "write_port_register(180,0)"
        write_port_register(180,0)
        thread_flag_306 = 1
      end
      if (a0_Job_Mode == 2):
        global thread_handler_306=run Thread_if_306()
        while (thread_flag_306 == 0):
          if not(a0_Job_Mode == 2):
            kill thread_handler_306
            thread_flag_306 = 2
          else:
            sync()
          end
        end
      else:
        thread_flag_306 = 2
      end
    end
    $ 1291 "Wait: 0.01"
    sleep(0.01)
    $ 1292 "after init auto"
    $ 1293 "If auto_on"
    if (auto_on):
      $ 1294 "write_port_register(202,0)"
      write_port_register(202,0)
      $ 1295 "timer_1: Stop"
      timer_1_is_counting = False
      $ 1296 "write_welder(0, False )"
      write_welder(0,  False  )
      $ 1297 "write_welder(4, False )"
      write_welder(4,  False  )
      $ 1298 "Call reset_weld_param"
      reset_weld_param()
      $ 1299 "Call reset_multi_record"
      reset_multi_record()
      $ 1300 "multi_path≔1"
      global multi_path=1
      $ 1301 "auto_on≔ False "
      global auto_on=  False  
      $ 1302 "current_2f≔0"
      global current_2f=0
      $ 1303 "get_center≔get_center_bak"
      global get_center=get_center_bak
      $ 1304 "vr2_p1≔p[0,0,0,0,0,0]"
      global vr2_p1=p[0,0,0,0,0,0]
      $ 1305 "welding_program≔ False "
      global welding_program=  False  
      $ 1306 "start_num≔135"
      global start_num=135
      $ 1307 "Loop start_num<141"
      while (start_num<141):
        $ 1308 "write_port_register(start_num,0)"
        write_port_register(start_num,0)
        $ 1309 "start_num≔start_num+1"
        global start_num=start_num+1
      end
    end
  end
end
